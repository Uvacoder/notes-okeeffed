# Lesson One: Testing Smart Contracts with Truffle

Lesson link [here](https://cryptozombies.io/en/lesson/11).

By the end of this lesson, you will be able to:

1. Test your smart contracts with Truffle against Ganache
2. Use Chai to write more expressive assertions
3. Test against Loom

## Example project layout

This is for the course:

```s
├── build
  ├── contracts
      ├── Migrations.json
      ├── CryptoZombies.json
      ├── erc721.json
      ├── ownable.json
      ├── safemath.json
      ├── zombieattack.json
      ├── zombiefactory.json
      ├── zombiefeeding.json
      ├── zombiehelper.json
      ├── zombieownership.json
├── contracts
  ├── Migrations.sol
  ├── CryptoZombies.sol
  ├── erc721.sol
  ├── ownable.sol
  ├── safemath.sol
  ├── zombieattack.sol
  ├── zombiefactory.sol
  ├── zombiefeeding.sol
  ├── zombiehelper.sol
  ├── zombieownership.sol
├── migrations
└── test
. package-lock.json
. truffle-config.js
. truffle.js
```

## Build artefacts

Every time you compile a smart contract, the Solidity compiler generates a JSON file (referred to as build artifacts) which contains the binary representation of that contract and saves it in the `build/contracts` folder.

Next, when you run a migration, Truffle updates this file with the information related to that network.

The first thing you'll need to do every time you start writing a new test suite is to load the build artifacts of the contract you want to interact with. This way, Truffle will know how to format our function calls in a way the contract will understand.

Say there was a contract called myAwesomeContract. We could do something like the following to load the build artifacts:

```js
const myAwesomeContract = artifacts.require("myAwesomeContract")
```

The function returns something called a contract abstraction. In a nutshell, a contract abstraction hides the complexity of interacting with Ethereum and provides a convenient JavaScript interface to our Solidity smart contract. We'll be using it in the next chapters.

## The contract() function

Behind the scenes, Truffle adds a thin wrapper around Mocha in order to make testing simpler.

Here is a barebones example of the implementation:

```js
contract("MyAwesomeContract", (accounts) => {
  it("should be able to receive Ethers", () => {})
})
```

An example implementation of a test without asserting anything:

```js
const CryptoZombies = artifacts.require("CryptoZombies")

contract("CryptoZombies", (accounts) => {
  it("should be able to create a new zombie", () => {})
})
```

## Testing locally

Before deploying to Ethereum, it is best to test your smart contracts locally.

You can do so by using a tool called [Ganache](http://trufflesuite.com/ganache/), which sets up a local Ethereum network.
