{"version":3,"sources":["webpack:///../manual/Go/Go-Dev-Guide.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","alt","src","isMDXComponent"],"mappings":"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","file":"component---manual-go-go-dev-guide-md-e09b5ec8c26fd4ae15b4.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"the-complete-go-developer-guide\"\n    }}>{`The Complete Go Developer Guide`}</h1>\n    <h2 {...{\n      \"id\": \"intro-to-the-go-cli\"\n    }}>{`Intro to the Go CLI`}</h2>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Command`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Action`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`go build`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Compiles go source files`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`go run`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Compiles and executes one or two files`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`go fmt`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Formats all go code in current directory`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`go install`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Compiles and \"installs\" a package`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`go get`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Downloads the raw source code of someone else's pacakge`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`go test`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Runs any tests associated with the current project`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <h2 {...{\n      \"id\": \"hello-world\"\n    }}>{`Hello World`}</h2>\n    <p>{`Using the Go CLI, we can run a simple hello world as so.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport \"fmt\"\n\n/**\n * Basic hello world.\n * Run using go -o\n */\nfunc main() {\n  fmt.Println(\"Hi there!\")\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"go-packages\"\n    }}>{`Go Packages`}</h2>\n    <p>{`When you see lines like `}<inlineCode parentName=\"p\">{`package main`}</inlineCode>{`, that's like a workspace. `}</p>\n    <p>{`There are two types of packages in Golang: `}</p>\n    <ol>\n      <li parentName=\"ol\">{`Executable: Generates a file that we can run.`}</li>\n      <li parentName=\"ol\">{`Reuseable: Code used as \"helpers\" -- a good place to put reusable login.`}</li>\n    </ol>\n    <p>{`Take for example three files:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// main.go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n  fmt.Println(\"Hi there!\")\n}\n\n// support.go\npackage main\n\nfunc support() {\n  fmt.Println(\"Hi support!\")\n}\n\n// helper.go\npackage main\n\nfunc helper() {\n  fmt.Println(\"Hi helper!\")\n}\n`}</code></pre>\n    <p>{`How can we tell the difference between whether we are creating a `}<inlineCode parentName=\"p\">{`executable`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`reuseable`}</inlineCode>{` type of package? It actually depends on whether you use the name `}<inlineCode parentName=\"p\">{`package main`}</inlineCode>{`. If you ran `}<inlineCode parentName=\"p\">{`go build`}</inlineCode>{` and you did not use `}<inlineCode parentName=\"p\">{`package main`}</inlineCode>{`, it will not spit out an executable file.`}</p>\n    <p>{`Any executable package also needs a func called `}<inlineCode parentName=\"p\">{`main`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"variable-declarations\"\n    }}>{`Variable Declarations`}</h2>\n    <p>{`Variables in Go can generally be inferred from the right hand side. Linters will generally help you out with this.`}</p>\n    <p>{`Shorthand declarations with initialisation can be done with `}<inlineCode parentName=\"p\">{`:=`}</inlineCode>{`, although it should be noted you can omit the `}<inlineCode parentName=\"p\">{`:`}</inlineCode>{` when declaring new values for variables.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nfunc main() {\n  var card string = \"Ace of spades\"\n  easierCard := \"Ace of hearts\"\n  easierCard = \"Five of Diamonds\"\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"functions-and-return-types\"\n    }}>{`Functions and Return Types`}</h2>\n    <p>{`The patter for declaring a return type is to name that return type after a func is called.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n  card := newCard()\n\n  fmt.Println(card)\n}\n\nfunc newCard() string {\n  return \"Ace of spades\"\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"slices-and-for-loops\"\n    }}>{`Slices and For Loops`}</h2>\n    <p>{`Go has two basic structures for handling lists: `}</p>\n    <ol>\n      <li parentName=\"ol\">{`Array: fixed length list of things`}</li>\n      <li parentName=\"ol\">{`Slice: an array that can grow or shrink`}</li>\n    </ol>\n    <p>{`Every slice must also be of the same type.`}</p>\n    <p>{`For a slice, we create it like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`func main() {\n  cards := []string{newCard()}\n  cards = append(cards, \"Six of Spades\")\n  \n  for i, card := range cards {\n  fmt.Println(i, card)\n  }\n}\n`}</code></pre>\n    <p>{`Note that the cards variable is immutable and a new slice is returned when we use the `}<inlineCode parentName=\"p\">{`append`}</inlineCode>{` function to add to the slice.`}</p>\n    <p>{`We can use the `}<inlineCode parentName=\"p\">{`range`}</inlineCode>{` keyword to iterate over a slice.`}</p>\n    <h2 {...{\n      \"id\": \"object-oriented-approach-vs-go-approach\"\n    }}>{`Object Oriented approach vs Go approach`}</h2>\n    <p>{`Note that there are no classes in Go.`}</p>\n    <p>{`In Go, what we do is declare a new type and then create `}<inlineCode parentName=\"p\">{`functions with a receiver`}</inlineCode>{`. This is a common pattern that repeats throughout Go courses.`}</p>\n    <p>{`In practice, we can update the `}<inlineCode parentName=\"p\">{`main.go`}</inlineCode>{` file with a new type we create:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// main.go\npackage main\n\nfunc main() {\n  cards := deck{newCard()}\n  cards = append(cards, \"Six of Spades\")\n\n  cards.print()\n}\n\nfunc newCard() string {\n  return \"Ace of spades\"\n}\n\n// deck.go\npackage main\n\nimport \"fmt\"\n\n// Create a new type of 'deck'\n// which is a slice of strings\ntype deck []string\n\n// Creating a receiver function\nfunc (d deck) print() {\n  for i, card := range d {\n  fmt.Println(i, card)\n  }\n}\n`}</code></pre>\n    <p>{`It is important to note that if your other `}<inlineCode parentName=\"p\">{`package main`}</inlineCode>{` files are not in the `}<inlineCode parentName=\"p\">{`$GOPATH`}</inlineCode>{` that you need to include them during your run state ie `}<inlineCode parentName=\"p\">{`go run main.go deck.go`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"slice-range-syntax\"\n    }}>{`Slice range syntax`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// [StartingAt : UpToButNotInclusive]\nslice := [\"one\", \"two\", \"three\"]\n// Get \"one\", \"two\"\nsliceRange := slice[0:2]\n// Same as...\nsliceRangeTwo  := [:2]\n// Get just the last\nsliceRangeThree := [2:]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"returning-multiple-values\"\n    }}>{`Returning multiple values`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// Use slices\nfunc deal(d deck, handSize int) (deck, deck) {\n  return d[:handSize], d[handSize:]\n}\n\nfunc main() {\n  cards := newDeck()\n\n  // init and assign return values\n  hand, remainingDeck := deal(cards, 5)\n  hand.print()\n  remainingDeck.print()\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"converting-to-bite-slices-type-conversion\"\n    }}>{`Converting to bite slices (type conversion)`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`byteSlice := []byte(\"Hi there\")\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"writing-to-file\"\n    }}>{`Writing to file`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// main.go\npackage main\n\nfunc main() {\n  cards := newDeck()\n  cards.saveToFile(\"my_cards\")\n}\n\n// deck.go\n\n// omit newDeck()\nfunc (d deck) saveToFile(filename string) error {\n   return ioutil.WriteFile(filename, []byte(d.toString()), 0666)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"reading-from-hard-drive\"\n    }}>{`Reading from hard drive`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// main.go\n// main.go\npackage main\n\nfunc main() {\n  cards := newDeckFromFile(\"my_cards\")\n  cards.print()\n}\n\n// deck.go\nfunc newDeckFromFile(filename string) deck {\n    // bs = byteSlice\n    bs, err := ioutil.ReadFile(filename)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        os.Exit(1)\n    }\n\n    s := strings.Split(string(bs), \",\")\n    return deck(s)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"shuffling-a-deck\"\n    }}>{`Shuffling a Deck`}</h2>\n    <p>{`There is no inbuilt function to randomise a slice.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// main.go\npackage main\nimport (\n  \"math/rand\"\n  \"time\"\n)\n\n// Use slices\nfunc deal(d deck, handSize int) (deck, deck) {\n  return d[:handSize], d[handSize:]\n}\n\nfunc (d deck) shuffle() {\n  source := rand.NewSource(time.Now().UnixNano())\n  r := rand.New(source)\n\n  for i := range d {\n    newPosition := r.Intn(len(d) - 1)\n\n    // fancy one line swap\n    d[i], d[newPosition] = d[newPosition], d[i]\n  }\n}\n\nfunc main() {\n   func main() {\n     cards := newDeck()\n\n     // init and assign return values\n     cards.shuffle()\n     cards.print()\n   }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"testing-with-go\"\n    }}>{`Testing with Go`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// deck_test.go\npackage main\n\nimport \"testing\"\n\nfunc TestNewDeck(t *testing.T) {\n  d := newDeck()\n\n  if len(d) != 16 {\n    t.Errorf(\"Expected deck length of 16, but got %v\", len(d))\n  }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"asserting-elements\"\n    }}>{`Asserting Elements`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// deck_test.go\npackage main\n\nimport \"testing\"\n\nfunc TestNewDeck(t *testing.T) {\n  d := newDeck()\n\n  if len(d) != 16 {\n    t.Errorf(\"Expected deck length of 16, but got %v\", len(d))\n  }\n\n  if d[0] != \"Ace of Spaces\" {\n    t.Errorf(\"Expected first card of Ace of Spaces, but got %v\", d[0]);\n  }\n\n  if d[len(d-1)] != \"Four of Clubs\" {\n    t.Errorf(\"Expected first card of Four of Clubs, but got %v\", d[len(d-1)]);\n  }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"clean-up-for-file-writing\"\n    }}>{`Clean up for file writing`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// deck_test.go\npackage main\n\nimport (\n  \"testing\"\n  \"os\"\n)\n\nfunc TestNewDeck(t *testing.T) {\n  d := newDeck()\n\n  if len(d) != 16 {\n    t.Errorf(\"Expected deck length of 16, but got %v\", len(d))\n  }\n\n  if d[0] != \"Ace of Spaces\" {\n    t.Errorf(\"Expected first card of Ace of Spaces, but got %v\", d[0]);\n  }\n\n  if d[len(d-1)] != \"Four of Clubs\" {\n    t.Errorf(\"Expected first card of Four of Clubs, but got %v\", d[len(d-1)]);\n  }\n}\n\n// although long name, the test \nfunc TestSaveToDeckAndNewDeckFromFile(t *testing.T) {\n  os.Remove(\"_decktesting\")\n\n  d := new Deck()\n  d.saveToFile(\"_decktesting\")\n\n  loadedDeck := newDeckFromFile(\"_decktesting\")\n\n  if len(loadedDeck) != 16 {\n    t.Errorf(\"Expected 16 cards in deck, got %v\", len(loadedDeck))\n  }\n\n  os.Remove(\"_decktesting\")\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"structs-in-go\"\n    }}>{`Structs in Go`}</h2>\n    <p>{`Structs are a collection of different properties linked with a particular purpose.`}</p>\n    <p>{`If we want to convert the string \"Ace of Spaces\" to become more flexible and as a structure, we could create a struct:`}</p>\n    <p>{`If you init a struct with no values, the zero values are assigned as the following:`}</p>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Type`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Zero Value`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`string`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`\"\"`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`int`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`0`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`float`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`0`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`bool`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`false`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`type card struct {\n  house string\n  value string\n}\n\n// usage\nfunc main() {\n  card := card{\"Spaces\", \"Ace\"}\n  // being more definitive\n  cardTwo := card{house: \"Spaces\", value: \"Ace\"}\n  fmt.Println(card)\n\n  // non-init - sets the zero value\n  // %+v will print out all field names and values\n  var cardThree card\n  fmt.Printf(\"%+v\", cardThree)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"embedding-structs\"\n    }}>{`Embedding Structs`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`type contactInfo struct {\n  email string\n  zipCode int\n}\n\ntype person struct {\n  firstName string\n  lastName string\n  contactInfo\n}\n\nfunc main() {\n  jim := person{\n    firstName: \"Jim\",\n    lastName: \"Party\",\n    contactInfo: contactInfo{\n      email: \"jim@gmail.com\",\n      zipCode: 94000\n    }\n  }\n\n  fmt.Printf(\"%+v\", jim)\n  // same as\n  jim.print()\n\n  // Update name\n  jim.updateNameIncorrect(\"jimmy\")\n  jim.print() // still shows jim instead of jimmy\n\n  // Correct\n  jimPointer := &jim\n  jimPointer.updateName(\"jimmy\")\n  jim.print() // prints jimmy\n\n  // Also works - shortcut for the receiver\n  jim.updatename(\"jimmy\")\n  jim.print()\n}\n\nfunc (p person) print() {\n  fmt.Printf(\"%+v\", p)\n}\n\n// updateName without a pointer\nfunc (p person) updateNameIncorrect(newFirstName string) {\n  p.firstName = newFirstname\n}\n\n// updateName correctly\n// note that taking *type means we're working with a pointer\n// *variable means we want to manipulate the value it is pointing at\nfunc (p *person) updateName(newFirstName string) {\n  (*p).firstName = newFirstname\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"pointer-operations\"\n    }}>{`Pointer operations`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Turn `}<inlineCode parentName=\"li\">{`address`}</inlineCode>{` into `}<inlineCode parentName=\"li\">{`value`}</inlineCode>{` with `}<inlineCode parentName=\"li\">{`*address`}</inlineCode></li>\n      <li parentName=\"ul\">{`Turn `}<inlineCode parentName=\"li\">{`value`}</inlineCode>{` into `}<inlineCode parentName=\"li\">{`address`}</inlineCode>{` with `}<inlineCode parentName=\"li\">{`&value`}</inlineCode></li>\n      <li parentName=\"ul\">{`Note that with slices vs structs, you can manipulate the slice directly without having to use a pointer, unlike structs.`}</li>\n      <li parentName=\"ul\">{`Slices with the underlying array get copied, but the array points to the same addresses.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"reference-vs-value-types\"\n    }}>{`Reference vs Value Types`}</h3>\n    <p>{`Use pointers for value types, don't worry about it for reference types.`}</p>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Value types`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Reference types`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`int`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`slices`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`float`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`maps`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`string`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`channels`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`bool`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`pointers`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`structs`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`functions`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <h2 {...{\n      \"id\": \"maps\"\n    }}>{`Maps`}</h2>\n    <p>{`Maps are similar to structs, but have some differences. These are basically `}<inlineCode parentName=\"p\">{`key:value`}</inlineCode>{` pairs.`}</p>\n    <p>{`These are comparable to `}<inlineCode parentName=\"p\">{`hash`}</inlineCode>{` in Ruby, `}<inlineCode parentName=\"p\">{`object`}</inlineCode>{` in JavaScript or `}<inlineCode parentName=\"p\">{`Dict`}</inlineCode>{` in Python.`}</p>\n    <p>{`For a map, the keys all need to be the same type, and the values all need to be the same type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"fmt\n)\n\nfunc main() {\n  // map: declare new map\n  // [string]: keys are type string\n  // string: values are type string\n  colors := map[string]string {\n    \"red\": \"#ff0000\",\n    \"green\": \"#4b9000\"\n  }\n\n  fmt.Println(colors)\n}\n`}</code></pre>\n    <p>{`Creating a zero value map can be done basically in two ways:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`var colors map[string]string\ncolorsEq = make(map[string]string)\n\n// adding in values\ncolorsEq[\"white\"] = \"#ffffff\"\n`}</code></pre>\n    <p>{`We MUST use square braces to access map values, NOT dot notation.`}</p>\n    <h2 {...{\n      \"id\": \"iterating-over-maps\"\n    }}>{`Iterating Over Maps`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`colors := map[string]string {\n  \"red\": \"#ff0000\",\n  \"green\": \"#4b9000\"\n}\n\n\nfunc printMap(c map[string]string) {\n  for color, hex := range c {\n    fmt.Println(\"Hex code for\", color, \"is\", hex)\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"maps-vs-structs\"\n    }}>{`Maps Vs Structs`}</h2>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Maps`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Structs`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`All keys must be same type`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Values can be different types`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Use to represent a collection of related properties`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Need to know all the different fields at compile time`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`All values must be the same type`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Keys don't support indexing`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Don't need to know all keys at compile time`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Use to represent a `}<inlineCode parentName=\"td\">{`thing`}</inlineCode>{` with a lot of properties`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Keys are indexed - can iterate over them`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Value type!`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Reference type !`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}></td>\n        </tr>\n      </tbody>\n    </table>\n    <h2 {...{\n      \"id\": \"interfaces\"\n    }}>{`Interfaces`}</h2>\n    <p>{`The following example shows similar types but returning different values.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\ntype englishBot struct {}\ntype spanishBot struct {}\n\n//\ntype bot interface {\n  getGreeting() string\n}\n\nfunc main() {\n  eb := englishBot()\n  sb := spanishBot()\n\n  printGreeting(eb)\n  printGreeting(sb)\n}\n\nfunc (eb englishBot) getGreeting() string {\n  // assume very custom logic to prove diff to spanishBot\n  return \"Hi There!\"\n}\n\nfunc (sb spanishBot) getGreeting() string {\n  // assume very custom logic to prove diff to spanishBot\n  return \"Hola!\"\n}\n\n// any type that implements getGreeting is now an \"honorary\" member of type bot\nfunc printGreet(b bot) {\n  fmt.Println(b.getGreeting())\n}\n`}</code></pre>\n    <p>{`More complex interfaces in Go might have signatures like the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`type bot interface {\n  getGreeting(string,int) (string, error)\n}\n`}</code></pre>\n    <p>{`If you want to set more \"qualifiers\" to conform to the interface, you can add more methods to the signature:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`type bot interface {\n  getGreeting(string,int) (string, error)\n  getBotVersion() float64\n  respondToUser(user) string\n}\n`}</code></pre>\n    <p>{`You can only create values out of the concrete types and not interface types.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Interfaces are not generic types (other langs have them, Go famously does not).`}</li>\n      <li parentName=\"ul\">{`Interfaces are \"implicit\", we don't have to say a custom type satisfies some interface.`}</li>\n      <li parentName=\"ul\">{`Interfaces are a contract to help us manage types.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"http-package\"\n    }}>{`HTTP Package`}</h2>\n    <p>{`Using http and getting a body response back and helping us understanding how structs work a little better.`}</p>\n    <p><img alt=\"Diagram of how to access return body\" src=\"https://res.cloudinary.com/gitgoodclub/image/upload/v1550201024/developer-notes/Screen_Shot_2019-02-15_at_2.22.59_pm.png\" /></p>\n    <p>{`If we use an interface as a property of a struct, we can add any property there as long as it conforms to the interface.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`type example interface {\n  Reader\n}\n\ntype resp struct {\n  propOne example\n}\n`}</code></pre>\n    <p>{`We can also assemble multiple interfaces together to create another interface where all requirements need to be satisfied:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`type reader interface {}\ntype closer interface {}\n\ntype readCloser interface {\n  reader\n  closer\n}\n`}</code></pre>\n    <p>{`For an application of this in action with the http.Get func:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n  \"os\"\n  \"io\"\n)\n\nfunc main() {\n  resp, err := http.Get(\"https://google.com\")\n  if err != nil {\n    fmt.Println(\"Error:\", err)\n    os.Exit(1)\n  }\n\n  // Note: Reader interface manipulates byte slice -- it doesn't return it. Go also has easier help functions to simply reading responses.\n  bs := make([]byte, 99999)\n  resp.Body.Read(bs)\n  fmt.Println(string(bs))\n}\n`}</code></pre>\n    <p>{`In order to prevent ourselves from having to manually create a byte slice each time, we can use the `}<inlineCode parentName=\"p\">{`io.Copy`}</inlineCode>{` function instead. The method signature for this requires a destination that implements the `}<inlineCode parentName=\"p\">{`Writer`}</inlineCode>{` interface and a source that implements the `}<inlineCode parentName=\"p\">{`Reader`}</inlineCode>{` interface.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n  \"os\"\n  \"io\"\n)\n\nfunc main() {\n  resp, err := http.Get(\"https://google.com\")\n  if err != nil {\n    fmt.Println(\"Error:\", err)\n    os.Exit(1)\n  }\n\n  // Updated code to simplify the process and print the resp.Body to Stdout\n  io.Copy(os.Stdout, resp.Body)\n}\n`}</code></pre>\n    <p>{`With everything that we have learned so far about how `}<inlineCode parentName=\"p\">{`io.Copy`}</inlineCode>{` works, let's create something that implements the `}<inlineCode parentName=\"p\">{`Writer`}</inlineCode>{` interface:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n  \"os\"\n  \"io\"\n)\n\ntype logWriter struct {}\n\nfunc main() {\n  resp, err := http.Get(\"https://google.com\")\n  if err != nil {\n    fmt.Println(\"Error:\", err)\n    os.Exit(1)\n  }\n\n  lw := logWriter{}\n\n  // Updated code to simplify the process and print the resp.Body to Stdout\n  io.Copy(lw, resp.Body)\n}\n\nfunc (logWriter) Write(bs []byte) (int, error) {\n  fmt.Println(string(bs))\n  fmt.Println(\"Just wrote this many bytes\", len(bs))\n  return len(bs), nil\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"channels-and-go-routines\"\n    }}>{`Channels and Go Routines`}</h2>\n    <p>{`Both channels and go routines are used for cocurrency programming.`}</p>\n    <p>{`The project for this particular example will use a status checker.`}</p>\n    <p><img alt=\"Project layout\" src=\"https://res.cloudinary.com/gitgoodclub/image/upload/v1550533610/developer-notes/Screen_Shot_2019-02-19_at_9.59.38_am.png\" /></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"io/http\"\n)\n\nfunc main() {\n  ws := []string{\"http://google.com\", \"http://amazon.com\", \"http://facebook.com\"}\n\n  for _, link := range ws {\n    checkLink(link)\n  }\n}\n\n// this implementation will be synchronous\nfunc checkLink(link string) {\n  _, err := http.Get(link)\n  if err != nil {\n    fmt.Println(link, \"might be down!\")\n    return\n  }\n\n  fmt.Println(link, \"is up!\")\n}\n`}</code></pre>\n    <p>{`If we think of the main function as the `}<inlineCode parentName=\"p\">{`main go routine`}</inlineCode>{`, we can start to imagine the above working sequentially as a result. In order to create new go routines, we can use the keyword `}<inlineCode parentName=\"p\">{`go`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"io/http\"\n)\n\nfunc main() {\n  ws := []string{\n    \"http://google.com\",\n    \"http://amazon.com\",\n    \"http://facebook.com\"\n  }\n\n  for _, link := range ws {\n    // creates new Go routine\n    go checkLink(link)\n  }\n}\n\n// this implementation will be synchronous\nfunc checkLink(link string) {\n  _, err := http.Get(link)\n  if err != nil {\n    fmt.Println(link, \"might be down!\")\n    return\n  }\n\n  fmt.Println(link, \"is up!\")\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"go-scheduler-behind-the-scenes\"\n    }}>{`Go Scheduler Behind The Scenes`}</h3>\n    <p><img alt=\"Go scheduler\" src=\"https://res.cloudinary.com/gitgoodclub/image/upload/v1550533611/developer-notes/Screen_Shot_2019-02-19_at_10.46.20_am.png\" /></p>\n    <p>{`Not that with one CPU, the Go scheduler runs `}<inlineCode parentName=\"p\">{`one`}</inlineCode>{` routine until finished or hits a blocking call. If a blocking call is hit, the scheduler pausing execution on a routine and starts the next one.`}</p>\n    <p>{`If we insteads have multiple cores, the scheduler runs one thread on each \"logical\" core. This then truly runs multiple routines at the same time.`}</p>\n    <p>{`By default, Go tries to use one core.`}</p>\n    <p>{`In Go, you will constantly see `}<inlineCode parentName=\"p\">{`concurrency is not parallelism`}</inlineCode>{`. Concurrency is the case of multiple threads executing code. `}</p>\n    <p>{`If one thread blocks, another one is picked up and worked out. Parallelism is the use of multiple physical CPU cores at the same time.`}</p>\n    <h3 {...{\n      \"id\": \"returning-from-go-routines\"\n    }}>{`Returning from Go routines`}</h3>\n    <p>{`In order to get back to the `}<inlineCode parentName=\"p\">{`main`}</inlineCode>{` routine from child routines, we need to update the code to handle channels for communication.`}</p>\n    <p>{`Each `}<inlineCode parentName=\"p\">{`channel`}</inlineCode>{` communicates with a particular type - something incredibly important.`}</p>\n    <h3 {...{\n      \"id\": \"sending-data-with-channels\"\n    }}>{`Sending Data with Channels`}</h3>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Syntax`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Action`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`channel <- 5`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Send value 5 into this channel`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`myNumber <- channel`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Wait for value to be sent into the channel. When we get one, assign the value to 'myNumber'`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`fmt.Println(<- channel)`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Wait for value to be sent into channel. When we get one, log it out immediately`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <p>{`One of the challenging concepts with channels is that each message coming back from a channel is also `}<inlineCode parentName=\"p\">{`blocking`}</inlineCode>{` code. This means that for every iteration that uses a channel, it is important to have the appropriate amount of receivers ready on the main routine.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"io/http\"\n)\n\nfunc main() {\n  ws := []string{\n    \"http://google.com\",\n    \"http://amazon.com\",\n    \"http://facebook.com\"\n  }\n\n  // creating a channel\n  c := make(chan string)\n\n  for _, link := range ws {\n    // creates new Go routine - pass in a channel link\n    go checkLink(link, c)\n  }\n\n  // note that to receive, we need to handle all changes\n  // this is creating an infinite loop for all go routines receiving a value\n  for {\n    go checkLink(<-c, c)\n  }\n}\n\n// this implementation will be synchronous\n// you must now declare the channel and channel type\nfunc checkLink(link string, c chan string) {\n  _, err := http.Get(link)\n  if err != nil {\n    fmt.Println(link, \"might be down!\")\n    c <- link\n    return\n  }\n\n  fmt.Println(link, \"is up!\")\n  c <- link\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"alternative-loop-syntax\"\n    }}>{`Alternative loop syntax`}</h3>\n    <p>{`So we don't want to continually ping a request, we can update the control loop with the following:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"io/http\"\n)\n\nfunc main() {\n  ws := []string{\n    \"http://google.com\",\n    \"http://amazon.com\",\n    \"http://facebook.com\"\n  }\n\n  // creating a channel\n  c := make(chan string)\n\n  for _, link := range ws {\n    // creates new Go routine - pass in a channel link\n    go checkLink(link, c)\n  }\n\n  // note that to receive, we need to handle all changes\n  // this is creating an infinite loop for all go routines receiving a value\n  // this range loop is equivalent to the above for loop\n  for l := range c {\n    go checkLink(l, c)\n  }\n}\n\n// this implementation will be synchronous\n// you must now declare the channel and channel type\nfunc checkLink(link string, c chan string) {\n  _, err := http.Get(link)\n  if err != nil {\n    fmt.Println(link, \"might be down!\")\n    c <- link\n    return\n  }\n\n  fmt.Println(link, \"is up!\")\n  c <- link\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"sleeping-a-routine\"\n    }}>{`Sleeping a routine`}</h3>\n    <p>{`We sleep a routine in order to generate a pause.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n  \"io/http\"\n  \"time\"\n)\n\nfunc main() {\n  ws := []string{\n    \"http://google.com\",\n    \"http://amazon.com\",\n    \"http://facebook.com\"\n  }\n\n  // creating a channel\n  c := make(chan string)\n\n  for _, link := range ws {\n    // creates new Go routine - pass in a channel link\n    go checkLink(link, c)\n  }\n\n  // note that to receive, we need to handle all changes\n  // this is creating an infinite loop for all go routines receiving a value\n  // this range loop is equivalent to the above for loop\n  for l := range c {\n    // invoke function literal\n    // ensure to pass the argument to have a copy in memory\n    go func(link string) {\n      time.Sleep(5*time.Second)\n      checkLink(link, c)\n    }(l)\n  }\n}\n\n// this implementation will be synchronous\n// you must now declare the channel and channel type\nfunc checkLink(link string, c chan string) {\n  _, err := http.Get(link)\n  if err != nil {\n    fmt.Println(link, \"might be down!\")\n    c <- link\n    return\n  }\n\n  fmt.Println(link, \"is up!\")\n  c <- link\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}