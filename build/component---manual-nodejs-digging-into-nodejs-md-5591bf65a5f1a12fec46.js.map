{"version":3,"sources":["webpack:///../manual/Nodejs/Digging-Into-Nodejs.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"sfAMO,IAAMA,EAAe,Q,sNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,uBADR,uBAGA,iBAAQ,CACN,GAAM,aADR,aAGA,sBACE,kBAAIC,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,2DADQ,sBAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,gDADQ,2BAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,gFADQ,kBAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,kCADQ,yCAItB,iBAAQ,CACN,GAAM,WADR,WAGA,iGACA,sBACE,kBAAIA,WAAW,MAAf,8CACA,kBAAIA,WAAW,MAAf,mFAEF,uJACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qMAQL,8BACE,iBAAGA,WAAW,cAAd,qFAEF,2EAA0D,0BAAYA,WAAW,KAAvB,SAA1D,4CACA,wHACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4RAYL,iBAAQ,CACN,GAAM,4BADR,4BAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mPAWL,8BACE,iBAAGA,WAAW,cAAd,8EAEF,iBAAQ,CACN,GAAM,oBADR,oBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gqBA2BL,iBAAQ,CACN,GAAM,sBADR,sBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qxBAkCL,iBAAQ,CACN,GAAM,8BADR,8BAGA,+FACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mmCAgDL,8BACE,iBAAGA,WAAW,cAAd,8DAEF,8BACE,iBAAGA,WAAW,cAAd,iBAA6C,0BAAYA,WAAW,KAAvB,iBAA7C,+CAEF,iBAAQ,CACN,GAAM,6BADR,6BAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,ylCAkDL,iBAAQ,CACN,GAAM,uCADR,wCAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0yCA0DL,iBAAQ,CACN,GAAM,mBADR,mBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0NAUL,iBAAQ,CACN,GAAM,cADR,cAGA,mEACA,yBACE,qBAAOA,WAAW,SAChB,kBAAIA,WAAW,SACb,oBAAIA,WAAW,MAAS,CACtB,MAAS,OADX,QAGA,oBAAIA,WAAW,MAAS,CACtB,MAAS,OADX,aAKJ,qBAAOA,WAAW,SAChB,kBAAIA,WAAW,SACb,oBAAIA,WAAW,MAAS,CACtB,MAAS,OADX,KAGA,oBAAIA,WAAW,MAAS,CACtB,MAAS,OADX,YAIF,kBAAIA,WAAW,SACb,oBAAIA,WAAW,MAAS,CACtB,MAAS,OADX,KAGA,oBAAIA,WAAW,MAAS,CACtB,MAAS,OADX,WAMN,oCAAmB,0BAAYA,WAAW,KAAvB,2BAAnB,iD,6MAKJJ,EAAWK,gBAAiB","file":"component---manual-nodejs-digging-into-nodejs-md-5591bf65a5f1a12fec46.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"digging-into-nodejs\"\n    }}>{`Digging Into Nodejs`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://frontendmasters.com/courses/digging-into-node/\"\n        }}>{`FE Masters Course`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/substack/stream-handbook\"\n        }}>{`GitHub Stream handbook`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\"\n        }}>{`readable.pipe`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/getify/caf\"\n        }}>{`Cancelable Async Functions - GitHub`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"streams\"\n    }}>{`Streams`}</h2>\n    <p>{`There are two stream modes that are known as \"simplex\" (unidirectional):`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Read/readable stream that you can consume.`}</li>\n      <li parentName=\"ol\">{`Write/writeable stream that they can receive inputs and you can write to them.`}</li>\n    </ol>\n    <p>{`There is also a \"duplex\" stream that is bidirectional (can be written to and read from). Duplex is not covered in this course.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var stream1; // readable\nvar stream2; // writeable\n\n// \"Take my readable stream and pipe it to my writeable\"\nvar stream3 = stream1.pipe(stream2); // chunks at a time using binary buffers\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Think of streams as gardens hoses that you want to be able to connect things to.`}</p>\n    </blockquote>\n    <p>{`It is important to know that a return value from a `}<inlineCode parentName=\"p\">{`.pipe`}</inlineCode>{` call stream is another readable stream.`}</p>\n    <p>{`This also means that we can keep chaining and piping as many writables as possible as possible.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var stream1; // readable\nvar stream2; // writeable\n\n// \"Take my readable stream and pipe it to my writeable\"\n// stream1 into stream2 into stream5 into final\nvar stream3 = stream1\n  .pipe(stream2)\n  .pipe(stream5)\n  .pipe(final); // chunks at a time using binary buffers\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"creating-the-read-stream\"\n    }}>{`Creating the read stream`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`let stream = fs.createReadStream('path/to/file');\nprocessFile(stream);\n\nfunction processFile(inStream) {\n  var outStream = inStream;\n  var targetStream = process.stdout;\n  outStream.pipe(targetStream); // pipe to process.stdout\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This difference here is that we don't keep the entire file in the buffer.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"transform-stream\"\n    }}>{`Transform Stream`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// other requires omitted for brevity\nvar Transform = require('stream').transform;\n\nlet stream = fs.createReadStream('path/to/file');\nprocessFile(stream);\n\nfunction processFile(inStream) {\n  var outStream = inStream;\n\n  var upperStream = new Transform({\n    // Note: next is a callback\n    transform(chunk, enc, next) {\n      this.push(chunk.toString().toUpperCase());\n      // Only using set time out to prove stream.\n      // Normally you just call next().\n      setTimeout(next, 500);\n    },\n  });\n\n  outStream = outStream.pipe(upperStream);\n\n  var targetStream = process.stdout;\n  outStream.pipe(targetStream); // pipe to process.stdout\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"outputting-to-file\"\n    }}>{`Outputting to file`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// other requires omitted for brevity\nvar Transform = require('stream').transform;\n\nlet stream = fs.createReadStream('path/to/file');\nprocessFile(stream);\n\nfunction processFile(inStream) {\n  var outStream = inStream;\n\n  var upperStream = new Transform({\n    // Note: next is a callback\n    transform(chunk, enc, next) {\n      this.push(chunk.toString().toUpperCase());\n      // Only using set time out to prove stream.\n      // Normally you just call next().\n      setTimeout(next, 500);\n    },\n  });\n\n  outStream = outStream.pipe(upperStream);\n\n  var targetStream;\n\n  if (args.out) {\n    targetStream = process.stdout;\n  } else {\n    targetStream = fs.createWriteStream('path/to/file');\n  }\n\n  outStream.pipe(targetStream); // pipe to process.stdout\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"gzip-compression-with-zlib\"\n    }}>{`gzip Compression with zlib`}</h2>\n    <p>{`A common transformation is the unzip, process them, then rezipping it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// other requires omitted for brevity\nvar Transform = require('stream').transform;\nvar zlin = require('zlip');\n\nlet stream = fs.createReadStream('path/to/file');\nprocessFile(stream);\n\nfunction processFile(inStream) {\n  var outStream = inStream;\n\n  // handling compressed files\n  if (args.uncompress) {\n    let gunzipStream = zlib.createGunzip();\n    outStream = outStream.pipe(gunzipStream);\n  }\n\n  var upperStream = new Transform({\n    // Note: next is a callback\n    transform(chunk, enc, next) {\n      this.push(chunk.toString().toUpperCase());\n      next();\n    },\n  });\n\n  outStream = outStream.pipe(upperStream);\n\n  // Compression code!\n  if (args.compress) {\n    let gzipStream = zlin.createGzip();\n    // adding additional stream\n    outStream = outStream.pipe(gzipStream);\n    // ensure name output changes\n    OUTSTREAM_NAME = \\`\\${OUTSTREAM_NAME}.gz\\`;\n  }\n\n  var targetStream;\n\n  if (args.out) {\n    targetStream = process.stdout;\n  } else {\n    targetStream = fs.createWriteStream('path/to/file');\n  }\n\n  outStream.pipe(targetStream); // pipe to process.stdout\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Gzip was designed for streams, that is why it is so easy.`}</p>\n    </blockquote>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note that for `}<inlineCode parentName=\"p\">{`vi out.txt.gz`}</inlineCode>{` that Vim automatically unzips it for you!`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"determining-end-of-stream\"\n    }}>{`Determining End of Stream`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// building a helper\nfunction streamComplete(stream) {\n  return new Promise(function c(res) {\n    stream.on('end', res);\n  });\n}\n\nasync function processFile(inStream) {\n  var outStream = inStream;\n\n  // handling compressed files\n  if (args.uncompress) {\n    let gunzipStream = zlib.createGunzip();\n    outStream = outStream.pipe(gunzipStream);\n  }\n\n  var upperStream = new Transform({\n    // Note: next is a callback\n    transform(chunk, enc, next) {\n      this.push(chunk.toString().toUpperCase());\n      next();\n    },\n  });\n\n  outStream = outStream.pipe(upperStream);\n\n  // Compression code!\n  if (args.compress) {\n    let gzipStream = zlin.createGzip();\n    // adding additional stream\n    outStream = outStream.pipe(gzipStream);\n    // ensure name output changes\n    OUTSTREAM_NAME = \\`\\${OUTSTREAM_NAME}.gz\\`;\n  }\n\n  var targetStream;\n\n  if (args.out) {\n    targetStream = process.stdout;\n  } else {\n    targetStream = fs.createWriteStream('path/to/file');\n  }\n\n  outStream.pipe(targetStream); // pipe to process.stdout\n\n  await streamComplete(outStream);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"asynchronous-cancellation--timeouts\"\n    }}>{`Asynchronous Cancellation & Timeouts`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`var CAF = require('caf');\n\nprocessFile = CAF(processFile);\n\nfunction* processFile(signal, inStream) {\n  var outStream = inStream;\n\n  // handling compressed files\n  if (args.uncompress) {\n    let gunzipStream = zlib.createGunzip();\n    outStream = outStream.pipe(gunzipStream);\n  }\n\n  var upperStream = new Transform({\n    // Note: next is a callback\n    transform(chunk, enc, next) {\n      this.push(chunk.toString().toUpperCase());\n      next();\n    },\n  });\n\n  outStream = outStream.pipe(upperStream);\n\n  // Compression code!\n  if (args.compress) {\n    let gzipStream = zlin.createGzip();\n    // adding additional stream\n    outStream = outStream.pipe(gzipStream);\n    // ensure name output changes\n    OUTSTREAM_NAME = \\`\\${OUTSTREAM_NAME}.gz\\`;\n  }\n\n  var targetStream;\n\n  if (args.out) {\n    targetStream = process.stdout;\n  } else {\n    targetStream = fs.createWriteStream('path/to/file');\n  }\n\n  outStream.pipe(targetStream); // pipe to process.stdout\n\n  signal.pr.catch(function f() {\n    outStream.unpipe(targetStream);\n    outStream.destroy(); // kill the stream process\n  });\n\n  yield streamComplete(outStream);\n}\n\n// later\nlet tooLong = CAF.timeout(3); // cancel at 3\nprocessFile(tooLong, stream)\n  .then(() => console.log('Complete'))\n  .catch(error);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"child-processes\"\n    }}>{`Child Processes`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const childProc = require('child_process');\nasync function main() {\n  var child = childProc.spawn('node', ['index.js']);\n  child.on('exit', function(code) {\n    console.log('Child finished', code);\n  });\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"exit-codes\"\n    }}>{`Exit Codes`}</h3>\n    <p>{`The commands are based on POSIX standards.`}</p>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Code`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Meaning`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`0`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Success`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`1`}</td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`Fail`}</td>\n        </tr>\n      </tbody>\n    </table>\n    <p>{`You can use `}<inlineCode parentName=\"p\">{`process.exitCode(value)`}</inlineCode>{` in the child processes to communicate back.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}