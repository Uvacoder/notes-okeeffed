{"version":3,"sources":["webpack:///../manual/TypeScript/TS-Fundamentals-v2.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---manual-type-script-ts-fundamentals-v-2-md-c90b093f1294cd9caa08.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"typescript-3-fundamentals-v2\"\n    }}>{`TypeScript 3 Fundamentals v2`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"vhttps://frontendmasters.com/courses/typescript-v2\"\n        }}>{`TS Resources`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/mike-works/typescript-fundamentals/\"\n        }}>{`GitHub Resource`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"variables\"\n    }}>{`Variables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// basic typing\nlet x: string = 'string';\nx = 42; // ERROR\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuples\"\n    }}>{`Tuples`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`let bb: [numer, string, string, number] = [\n  123,\n  'Fake Street',\n  'Nowhere, USA',\n  10110,\n];\n\nbb = [1, 2, 3]; // ERROR\nbb.push(1, 2); // no type safety error :(\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Tuples will need the type specified at declaration, otherwise it could infer an array of the wrong type.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"exhaustive-switches\"\n    }}>{`Exhaustive Switches`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`enum constants = {\n  mrf = \"mrf\"\n}\n\n// doesn't need a default\nconst getValue = (value: constants) => {\n  switch (value) {\n    case constants.mrf:\n      return 'value'\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"intersectional-and-union-types\"\n    }}>{`Intersectional and Union Types`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type A = {\n  a: number;\n};\n\ntype B = {\n  b: number;\n};\n\ntype IntersectionAB = A | B;\n// valid\nconst aObj: IntersectionAB = {\n  a: 32,\n};\n\nconst bObj: IntersectionAB = {\n  b: 32,\n};\n\n// invalid\nconst cObj: IntersectionAB = {\n  a: 32,\n  b: 32,\n};\n\ntype UnionAB = A | B;\n// invalid\nconst aObj: UnionAB = {\n  a: 32,\n};\n\nconst bObj: UnionAB = {\n  b: 32,\n};\n\n// valid\nconst cObj: UnionAB = {\n  a: 32,\n  b: 32,\n};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-systems\"\n    }}>{`Type Systems`}</h2>\n    <p>{`There are two types:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Nominal Type Systems (Java): is x an instance of a class/type named `}<inlineCode parentName=\"li\">{`HTMLInputElement`}</inlineCode>{`?`}</li>\n      <li parentName=\"ol\">{`Structural Type Systems (TS): cares only about shape.`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function validateInputField(input: HTMLInputElement) {\n  /* ... */\n}\n\nvalidateInputField(x);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"specificity\"\n    }}>{`Specificity`}</h2>\n    <p>{`TypeScript uses \"wider vs narrower\" to describle specificity. That means that we go from wide `}<inlineCode parentName=\"p\">{`any`}</inlineCode>{` down to nothing `}<inlineCode parentName=\"p\">{`never`}</inlineCode>{` with everything else in between.`}</p>\n    <h2 {...{\n      \"id\": \"type-aliases--extends\"\n    }}>{`Type Aliases & extends`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Allow us to give a type a name.`}</p>\n    </blockquote>\n    <ul>\n      <li parentName=\"ul\">{`Interfaces extend from interfaces, classes extend from classes.`}</li>\n      <li parentName=\"ul\">{`Interfaces cannot handle primitive types. JavaScript object and subobjects only (things with prototypes).`}</li>\n      <li parentName=\"ul\">{`Main difference is you cannot implement/extend a union type.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"generics\"\n    }}>{`Generics`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Generics parameterize types in the same way functions parameterize valus.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// example of the parameterized function\nfunction wrappedValue(x) {\n  return {\n    value: x,\n  };\n}\n\n// example now as generic\n// the common convention is T\ninterface wrappedValue<X> {\n  value: X;\n}\n\nlet val: WrappedValue<string> = { value: '' };\nval.value; // expects string and shows that on the tooltip\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"type-parameters\"\n    }}>{`Type parameters`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// this sets the fallback to any\ninterface wrappedValue<X = any> {\n  value: X;\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`TypeScript can also infer type ahead in the tooltip. Very handy use.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"constraints-and-scope\"\n    }}>{`Constraints and scope`}</h3>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Extending a generc means setting a minimum constraint that a generic must meet.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// an example of ensure that T has an id\nfunction arrayToDict<T extends { id: string }>(array: T[]): { [k: string]: T } {\n  const out: {\n    [k: string]: T;\n  } = {};\n  array.forEach(val => {\n    out[val.id] = val;\n  });\n  return out;\n}\n`}</code></pre>\n    <p>{`Type parameters are also associated with scope:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function startTuple<T>(a: T) {\n  return function finishTuple<U>(b: U) {\n    return [a, b] as [T, U];\n  };\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"generics-in-use-with-interfaces\"\n    }}>{`Generics in use with interfaces`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Shape {\n  sides: number;\n}\n\ninterface Square extends Shape {\n  width: number;\n}\n\ninterface Circle extends Shape {\n  radius: number;\n}\n\n// what makes it worth while is it means any interface\n// that extends Shape\nfunction drawShape<S extends Shape>(shapes: S[]): S[] {\n  return; // fill in here\n}\n\nconst test1: Shape = //...\nconst test2: Circle = //...\ndrawShape(test1) // valid\ndrawShape(test2) // valid\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"use-cases-for-generics\"\n    }}>{`Use cases for Generics`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Generics are necessary when we want to describe a relationship between two or more types (i.e., a function argument and return type).`}</li>\n      <li parentName=\"ol\">{`Aside from interfaces and type aliases, if a type parameter is used only once, it can probably be eliminated.`}</li>\n    </ol>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Relating this ie `}<inlineCode parentName=\"p\">{`I take T and will give you back a Dictionary of type T`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Shape {\n  draw();\n}\ninterface Circle extends Shape {\n  radius: number;\n}\n\nfunction drawShapes1<S extends Shape>(shapes: S[]) {\n  shapes.forEach(s => s.draw());\n}\n\n// this is simpler. Above type param is not necessary\nfunction drawShapes2(shapes: Shape[]) {\n  shapes.forEach(s => s.draw());\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"interesting-tidbit\"\n    }}>{`Interesting tidbit`}</h3>\n    <p>{`The following is both acceptable as far as TS is concerned:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// using interface\ninterface Shape {\n  sides: number;\n}\n\ninterface Circle extends Shape {\n  radius: number;\n}\n\ninterface Cube extends Shape {\n  threeD: boolean;\n}\n\nfunction createCircle<T extends Shape>(shape: T): T {\n  shape.sides = 1;\n  return shape;\n}\n\n// using types\ntype Shape2 = {\n  sides: number;\n};\n\ntype Circle2 = Shape2 & {\n  radius: number;\n};\n\ntype Cube2 = Shape2 & {\n  threeD: boolean;\n};\n\nfunction createCircle2<T extends Shape2>(shape: T): T {\n  shape.sides = 1;\n  return shape;\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"dictionary-exercise\"\n    }}>{`Dictionary exercise`}</h3>\n    <p>{`An example of creating a dictionary with the same type as the value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export type Dict<T> = {\n  [K: string]: T | undefined;\n};\n\n// transforming from and then to\nexport function mapDict<T, S>(dict: Dict<T>, fn(arg: T, idx: number) => S): Dict<S> {\n  const out: Dict<S> = {}\n  Object.keys(dict).forEach((dKey, idx) => {\n    const thisItem = dict[dKey]\n    if (typeof thisItem !== undefined) {\n      out[dKey] = fn(thisIdem, idx);\n    }\n  })\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"top-and-bottom-types\"\n    }}>{`Top and Bottom Types`}</h2>\n    <p>{`Two top types:`}</p>\n    <ol>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`any`}</inlineCode></li>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`unknown`}</inlineCode>{` - can receive any value`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let myAny: any = 32;\nlet myUnknown: unknown = 'hello, unknown';\n\nmyAny.foo.bar.baz; // works okay\nmyUnknown.foo; // error thrown\n`}</code></pre>\n    <p>{`When to use any?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`When you want to maintan flexibility.`}</li>\n    </ul>\n    <p>{`When to use unknown?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Good for \"private\" values.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`if (typeof myUnknown === 'string') {\n  myUnknown.split(',');\n}\nif (myUnknown instanceof Promise) {\n  myUnknown.then(x => console.log(x));\n}\n\n// note on return type\ntype HasEmail = {\n  name: string;\n  email: string;\n};\nfunction isHasEmail(x: any): x is HasEmail {\n  return typeof x.name === 'string' && x.email === 'string';\n}\n\nif (isHasEmail(myKnown)) {\n  // do things\n}\n\n// most common guard\nfunction isDefined<T>(arg: T | undefined): arg is T {\n  return typeof arg !== 'undefined';\n}\n\nconst list = ['a', 'b', 'c', undefined];\nconst filtered = list.filter(isDefined);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"unknowns-and-branded-types\"\n    }}>{`Unknowns and Branded Types`}</h2>\n    <p>{`Branding and unbranding helps with unsafe issues. We cast to unknown and brand that enables us to cast without type errors.`}</p>\n    <p>{`Withthe differing types, we can still ensure that things do not accidentally get mismatched when branding or unbranding.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This vs `}<inlineCode parentName=\"p\">{`private`}</inlineCode>{`? Private can only be used in classes.`}</p>\n    </blockquote>\n    <p>{`This is useful for library authors who want to keep things away from other users to change up.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface BrandedA {\n  __this_is_branded_with_a: 'a';\n}\n\nfunction brandA(value: string): BrandedA {\n  return (value as unknown) as BrandedA;\n}\n\nfunction unbrandA(value: BrandedA): string {\n  return (value as unknown) as string;\n}\n\ninterface BrandedB {\n  __this_is_branded_with_b: 'b';\n}\n\nfunction brandB(value: { abc: string }): BrandedB {\n  return (value as unknown) as BrandedB;\n}\n\nfunction unbrandB(value: BrandedB): { abc: string } {\n  return (value as unknown) as { abc: string };\n}\n\nlet secretA = brandA('Secret value');\nlet secretB = brandA({ abc: 'Another secret value' });\n\nsecretA = secretB; // error: can't mix up\nunbrandB(secretA); // cannot happen\nunbrandA(secretB); // cannot happen\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bottom-types\"\n    }}>{`Bottom Types`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`never: If you create `}<inlineCode parentName=\"li\">{`never`}</inlineCode>{` type, you shouldn't be here.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let x = 'abc' as string | number;\n\nif (typeof x === 'string') {\n  x.split(', ');\n} else if (typeof x === 'number') {\n  x.toFixed(2);\n} else {\n  // x is a never here\n}\n`}</code></pre>\n    <p>{`Here is an example creating an unreachable error:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class UnreachableError extends Error {\n  constructor(val: never, message: string) {\n    super(\\`TypeScript thought we could never end up here \\${message}\\`);\n  }\n}\n\nlet x = 4 as string | number;\n\nif (typeof x === 'string') {\n  x.split(', ');\n} else if (typeof x === 'number') {\n  x.toFixed(2);\n} else {\n  // if this isn't here, hates JavaScript debugging\n  // x is a never here\n  throw new UnreachableError(x, 'x should be string or number');\n}\n\n// What happens if x changes to string | number | boolean?\n// It will throw a runtime error saying you need to handle the case.\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This error is used for a runtime error!`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"advanced-types\"\n    }}>{`Advanced Types`}</h2>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`keyof`}</inlineCode>{` - gets the key`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`typeof`}</inlineCode>{` - gets the typeof an element`}</li>\n      <li parentName=\"ul\">{`Conditional type that uses a ternary.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Conditional ternany\ntype EventualType<T> = T extends Promise<infer S>\n  ? S //extract the type the promise resolves to\n  : T; // otherwise just let T pass through;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"utility-types\"\n    }}>{`Utility Types`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Partial: makes all optional`}</li>\n      <li parentName=\"ul\">{`Pick: choose specific properties`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"declaration-merging\"\n    }}>{`Declaration Merging`}</h2>\n    <p>{`You can stack class, namespace and interface on top each other and all will be exported under the same value and be interpretable based on use.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}