{"version":3,"sources":["webpack:///../manual/Swift/Swift-3-API-Design-Guidelines.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---manual-swift-swift-3-api-design-guidelines-md-7355cee75da3a3670368.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"api-design-guidelines-in-swift-3\"\n    }}>{`API Design Guidelines in Swift 3`}</h1>\n    {\n      /* TOC */\n    }\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#api-design-guidelines-in-swift-3\"\n        }}>{`API Design Guidelines in Swift 3`}</a><ul parentName=\"li\">\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-1-why-do-we-need-guidelines\"\n            }}>{`SWD-1: Why do we need guidelines?`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-2-guidelines-for-naming-types\"\n            }}>{`SWD-2: Guidelines for Naming Types`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-3-guidelines-for-naming-methods\"\n            }}>{`SWD-3: Guidelines for Naming Methods`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-4-fluent-usage\"\n            }}>{`SWD-4: Fluent Usage`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-5-prepositional-vs-grammatical-phrases\"\n            }}>{`SWD-5: Prepositional vs Grammatical Phrases`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-6-recap-on-naming\"\n            }}>{`SWD-6: Recap on Naming`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-7-side-effects-and-mutation\"\n            }}>{`SWD-7: Side-Effects and Mutation`}</a></li>\n          <li parentName=\"ul\"><a parentName=\"li\" {...{\n              \"href\": \"#swd-8-conventions\"\n            }}>{`SWD-8: Conventions`}</a></li>\n        </ul></li>\n    </ul>\n    {\n      /* /TOC */\n    }\n    <h2 {...{\n      \"id\": \"swd-1-why-do-we-need-guidelines\"\n    }}>{`SWD-1: Why do we need guidelines?`}</h2>\n    <p>{`Initially when Swift was created, there were no real guidelines.`}</p>\n    <p>{`It still largely means working with Objective-C code.`}</p>\n    <p>{`With the open sourcing in 2015, the Swift team worked towards a standard for the guidelines.`}</p>\n    <p>{`The most important rule with Swift is to correctly use the `}<inlineCode parentName=\"p\">{`Point of Use`}</inlineCode>{`. Readability at call site is more important than point of definition.`}</p>\n    <p>{`Methods and properties are written once and called and used many times, so the focus should be on the latter.`}</p>\n    <p>{`Secondly, `}<inlineCode parentName=\"p\">{`Clarity Over Brevity`}</inlineCode>{`. It is a non goal to enable to smallest possible code. With Objective-C, it was important to write with clarity for naming conventions. We want to stay on board with this clarity for naming.`}</p>\n    <h2 {...{\n      \"id\": \"swd-2-guidelines-for-naming-types\"\n    }}>{`SWD-2: Guidelines for Naming Types`}</h2>\n    <p>{`High level goal of naming things according to their role.`}</p>\n    <p>{`Example for a quick variable:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`var someValue = 12  // bad choice\nvar counter = 12    // better choice\n`}</code></pre>\n    <p><em parentName=\"p\">{`Rules for Naming`}</em></p>\n    <p>{`Names of types properties, variables and constants should `}<em parentName=\"p\">{`read as nouns`}</em>{`.`}</p>\n    <p>{`Example `}<inlineCode parentName=\"p\">{`class NetworkResponse`}</inlineCode>{` - we know from the name that it is for a `}<inlineCode parentName=\"p\">{`NetworkReponse`}</inlineCode>{`. Therefore, we would decide that the responsibility for Network Connection is the responsibility for another class.`}</p>\n    <p>{`An example from the `}<em parentName=\"p\">{`Swift Standard Library Names`}</em>{` is `}<inlineCode parentName=\"p\">{`BidirectionalCollection`}</inlineCode>{` - we know from the name that it is a collection that deals with both forward and backward traversal. `}<inlineCode parentName=\"p\">{`Sequence`}</inlineCode>{` protocol describes a type that provides sequential access to its elements.`}</p>\n    <p>{`The exceptions to this rule is for `}<inlineCode parentName=\"p\">{`Boolean`}</inlineCode>{` values - they should read as asserts. Eg. `}<inlineCode parentName=\"p\">{`isEmpty`}</inlineCode>{`.`}</p>\n    <p>{`The second excepetion is the -able, -ible or -ing suffixes - used for protocols that model capabilities. Examples of this are `}<inlineCode parentName=\"p\">{`Equatable`}</inlineCode>{` to distinguish between the same type, with other examples such as `}<inlineCode parentName=\"p\">{`Comparable`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`ExpressibleByStringLiteral`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"swd-3-guidelines-for-naming-methods\"\n    }}>{`SWD-3: Guidelines for Naming Methods`}</h2>\n    <p>{`We consider function names to be the base name plus the function list. Therefore, reading it will mean that it requires the base name and the arguments in order to understand it.`}</p>\n    <p>{`For the function parameters themselves, they have both a external name and a local name.`}</p>\n    <p><inlineCode parentName=\"p\">{`func index(_ i: Self.Index, offsetBy n: Self.IndexDistance) -> Self.Index`}</inlineCode></p>\n    <p>{`In the second parametere, `}<inlineCode parentName=\"p\">{`offsetBy`}</inlineCode>{` is the external name.`}</p>\n    <p>{`If there is just one parameter, then that will be both the external and local name. You can use `}<inlineCode parentName=\"p\">{`_`}</inlineCode>{` to offset the parameter external name.`}</p>\n    <p><em parentName=\"p\">{`Rule 1`}</em>{`\nWe should always check how functions read and use sites when we write them.`}</p>\n    <p>{`Example: `}<inlineCode parentName=\"p\">{`func insert(_ e: Element, atPosition: Int)`}</inlineCode>{` is better than `}<inlineCode parentName=\"p\">{`insert(element: \"a\", position: 1)`}</inlineCode>{`.`}</p>\n    <p><em parentName=\"p\">{`Rule 2`}</em>{`\nAvoid Ambiguity`}</p>\n    <p><inlineCode parentName=\"p\">{`func remove(atIndex: Int).`}</inlineCode>{` over `}<inlineCode parentName=\"p\">{`func remove(_ index: Int)`}</inlineCode></p>\n    <p>{`However, in the case of ambiguous type information, we preceed each weakly typed parameter with a noun describing it's role.`}</p>\n    <p><inlineCode parentName=\"p\">{`func addObserver(_ observer: AnyObject)`}</inlineCode>{` over `}<inlineCode parentName=\"p\">{`func add(observer: AnyObject)`}</inlineCode></p>\n    <p><inlineCode parentName=\"p\">{`func update(value: Any, key: String)`}</inlineCode></p>\n    <p>{`Here, Any and String both have weak type information.`}</p>\n    <p><inlineCode parentName=\"p\">{`func updateValue(_ value: Any, forKey key: String)`}</inlineCode></p>\n    <p><em parentName=\"p\">{`Summary`}</em></p>\n    <ul>\n      <li parentName=\"ul\">{`Omit needless information`}</li>\n      <li parentName=\"ul\">{`Include all words need to avoid ambiguity`}</li>\n      <li parentName=\"ul\">{`Compensate for weak type information`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"swd-4-fluent-usage\"\n    }}>{`SWD-4: Fluent Usage`}</h2>\n    <p>{`The high level guidelines don't give too many details.`}</p>\n    <p><em parentName=\"p\">{`Fluent Usage`}</em></p>\n    <p>{`Methods and functions should be read as grammatical English phrases at the use site.`}</p>\n    <p>{`Example: `}<inlineCode parentName=\"p\">{`func find(character: String, range: Range<String.Index>) -> Int`}</inlineCode></p>\n    <p>{`This function takes as an argument a character which we'll define as a string defined. We also need the range, so we'll give it range.`}</p>\n    <p>{`We could use...`}</p>\n    <p><inlineCode parentName=\"p\">{`func find(character: String, in range: Range<String.Index>) -> Int`}</inlineCode></p>\n    <p>{`But since it is ambiguous for weak type information, would be to omit the external label and the first argument of the name describing it's role:`}</p>\n    <p><inlineCode parentName=\"p\">{`func find(character: Character, in range: Range<String.Index>) -> Int`}</inlineCode></p>\n    <h2 {...{\n      \"id\": \"swd-5-prepositional-vs-grammatical-phrases\"\n    }}>{`SWD-5: Prepositional vs Grammatical Phrases`}</h2>\n    <p>{`This is an exception for the grammatical phrases.`}</p>\n    <p>{`Eg. \"The laptop on the desk\" - `}<inlineCode parentName=\"p\">{`on`}</inlineCode>{` is the preposition.`}</p>\n    <p>{`How does this relate?`}</p>\n    <p>{`Eg.`}</p>\n    <p><inlineCode parentName=\"p\">{`func move(position: Int)`}</inlineCode></p>\n    <p>{`Normally we would say \"move to position\", however if we need to use that preposition `}<inlineCode parentName=\"p\">{`to`}</inlineCode>{` then we give it an argument label that begins at the preposition.`}</p>\n    <p><inlineCode parentName=\"p\">{`func move(toPosition position: Int)`}</inlineCode></p>\n    <p>{`Another example would be `}<inlineCode parentName=\"p\">{`x.removeBoxes(havingLength: 12)`}</inlineCode>{`.`}</p>\n    <p>{`The exception to this would be that only one argument governed the function.`}</p>\n    <p>{`Example, `}<inlineCode parentName=\"p\">{`func move(toX: Int, y: Int)`}</inlineCode></p>\n    <p>{`We begin with the prepositional phrase, however both args are part of the abstraction. In that case, we move the preposition out of the arguments in to the base name.`}</p>\n    <p><inlineCode parentName=\"p\">{`func moveTo(x: Int, y: Int)`}</inlineCode></p>\n    <p>{`Another example for context:`}</p>\n    <p><inlineCode parentName=\"p\">{`func dismiss(animated: Bool)`}</inlineCode></p>\n    <h2 {...{\n      \"id\": \"swd-6-recap-on-naming\"\n    }}>{`SWD-6: Recap on Naming`}</h2>\n    <p><em parentName=\"p\">{`Prepositional Phrase: Exception`}</em></p>\n    <p><inlineCode parentName=\"p\">{`view.fadeTo(red: a, green: b, blue: c)`}</inlineCode></p>\n    <p><em parentName=\"p\">{`Grammatical Phrase`}</em></p>\n    <p><inlineCode parentName=\"p\">{`view.addSubview(y)`}</inlineCode></p>\n    <p><em parentName=\"p\">{`Neither Gammatical Nor Prepositional`}</em></p>\n    <p><inlineCode parentName=\"p\">{`func dismiss(animated: Bool)`}</inlineCode></p>\n    <ul>\n      <li parentName=\"ul\">{`Omit needless words`}</li>\n      <li parentName=\"ul\">{`Avoid ambiguity`}</li>\n      <li parentName=\"ul\">{`Avoid needless words`}</li>\n    </ul>\n    <p><em parentName=\"p\">{`More Examples of Methods from the Swift SDK`}</em></p>\n    <pre><code parentName=\"pre\" {...{}}>{`func activate(_ constraints: [NSLayoutConstraint])\n// activate constraints - grammatical\n// omit needless words - so no need for activateConstraints\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{`func max(_ x: Int, _ y: Int) -> Int\n// no meaningful to write more beyond the base\n// no need for naming arguments\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"swd-7-side-effects-and-mutation\"\n    }}>{`SWD-7: Side-Effects and Mutation`}</h2>\n    <p>{`We want to name methods in accordance with their side effect.`}</p>\n    <p>{`This is one that mutates the current state. If it effects the current state, it should be named using verb phrases.`}</p>\n    <p>{`An example would adding an element to the array. This effects the state of the array as it mutates it.`}</p>\n    <p><inlineCode parentName=\"p\">{`func append(_ newElement: Element)`}</inlineCode></p>\n    <p>{`Nouns are used for when the state is not effected.`}</p>\n    <p><inlineCode parentName=\"p\">{`func distance(to point: Point)`}</inlineCode></p>\n    <p>{`What if the operation is naturally described as a verb?`}</p>\n    <p>{`Then we use the imperitive form for the verb.`}</p>\n    <p><inlineCode parentName=\"p\">{`anArray.filter(isEven)`}</inlineCode>{` - filter being the verb mutating the array state.`}</p>\n    <p><em parentName=\"p\">{`Mutating verse non-mutation of the state`}</em></p>\n    <p>{`Mutating example: `}<inlineCode parentName=\"p\">{`anArray.sort()`}</inlineCode>{`\nNon-mutating example: `}<inlineCode parentName=\"p\">{`let sortedArray = anArray.sorted()`}</inlineCode></p>\n    <p>{`Suffixes that can be used include `}<inlineCode parentName=\"p\">{`-ed`}</inlineCode>{` and when it doesn't sound right `}<inlineCode parentName=\"p\">{`-ing`}</inlineCode>{`.`}</p>\n    <p><em parentName=\"p\">{`Mutation for nouns`}</em></p>\n    <p>{`This is simpler. We use noun for non-mutating and form prefix for mutating counterpart.`}</p>\n    <p>{`Mutating example: `}<inlineCode parentName=\"p\">{`anArray.formUnion(with: anotherArray)`}</inlineCode>{`\nNon-mutating: `}<inlineCode parentName=\"p\">{`let union = anArray.union(with: anotherArray)`}</inlineCode></p>\n    <p>{`The exception arises for pairs of mutating and non-mutating counterparts.`}</p>\n    <p>{`If it best described using a verb, you use that for the mutating method.`}</p>\n    <p>{`For non-mutating, use `}<inlineCode parentName=\"p\">{`-ed`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`-ing`}</inlineCode>{` suffix.`}</p>\n    <p>{`Then noun form for non-mutating version of nouns and form prefix for mutating method.`}</p>\n    <h2 {...{\n      \"id\": \"swd-8-conventions\"\n    }}>{`SWD-8: Conventions`}</h2>\n    <p><em parentName=\"p\">{`Boolean Methods`}</em></p>\n    <p><inlineCode parentName=\"p\">{`func isInRange(of point: Point)`}</inlineCode></p>\n    <p><em parentName=\"p\">{`Parameters`}</em></p>\n    <ul>\n      <li parentName=\"ul\">{`Choose parameter names that serve documentation.`}</li>\n      <li parentName=\"ul\">{`Use default values where possible to simplify function signatures.`}</li>\n      <li parentName=\"ul\">{`In Swift, default args are preferred to method families.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`let order = lastName.compare(royalFamilyName, options: [], range: nil, local: nil)\n`}</code></pre>\n    <p>{`Keep parameters with default parameters to sit at the end of the function.`}</p>\n    <p>{`Same basenames are also fine if they operate within different domains.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}