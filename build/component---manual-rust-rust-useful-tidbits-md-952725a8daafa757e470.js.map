{"version":3,"sources":["webpack:///../manual/Rust/Rust-Useful-Tidbits.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ofAMO,IAAMA,EAAe,Q,oNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,kBADR,kBAGA,iBAAQ,CACN,GAAM,+BADR,+BAGA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,kBADZ,oHAQL,iBAAQ,CACN,GAAM,gBADR,gBAGA,kEAAiD,0BAAYA,WAAW,KAAvB,QAAjD,mFAAqL,0BAAYA,WAAW,KAAvB,aAArL,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,kBADZ,0IAWL,iBAAQ,CACN,GAAM,gBADR,gBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,kBADZ,sXAeL,gCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,+gBA2BL,iBAAQ,CACN,GAAM,WADR,WAGA,qKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,kBADZ,wJAaL,gCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,kBADZ,8M,2MAWTJ,EAAWK,gBAAiB","file":"component---manual-rust-rust-useful-tidbits-md-952725a8daafa757e470.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"useful-tidbits\"\n    }}>{`Useful Tidbits`}</h1>\n    <h2 {...{\n      \"id\": \"importing-crates-vs-std-lib\"\n    }}>{`Importing crates vs std lib`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`// for extenal dependencies\nextern crate clap;\nuse clap::App;\n// for standard Rust libraries\nuse std::fs;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"reading-yaml\"\n    }}>{`Reading YAML`}</h2>\n    <p>{`Note that this is being done by using the `}<inlineCode parentName=\"p\">{`clap`}</inlineCode>{` crate that is used for CLI tools - may need to update for appropraite use with `}<inlineCode parentName=\"p\">{`rust-yaml`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`#[macro_use]\nextern crate clap;\nuse clap::App;\n\nfn main() {\n  let yaml = load_yaml!(\"cli.yml\");\n  println!(\"{:#?}\", yaml);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"reading-json\"\n    }}>{`Reading JSON`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`#[macro_use]\nextern crate serde_json;\n\nuse std::path::Path;\nuse std::fs::File;\n\nfn main() {\n    let json_file_path = Path::new(\"src/test.json\");\n    let json_file = File::open(json_file_path).expect(\"file not found\");\n    let json: serde_json::Value = serde_json::from_reader(json_file).expect(\"JSON was not well-formatted\");\n    println!(\"{:#?}\", json);\n}\n`}</code></pre>\n    <p>{`Output:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`Object(\n    {\n        \"id\": String(\n            \"1234\"\n        ),\n        \"object\": Object(\n            {\n                \"array\": Array(\n                    [\n                        Number(\n                            1\n                        ),\n                        Number(\n                            2\n                        ),\n                        Number(\n                            3\n                        )\n                    ]\n                )\n            }\n        )\n    }\n)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"logging\"\n    }}>{`Logging`}</h2>\n    <p>{`You want to implement the Debug trait on your struct. Using #`}{`[derive(Debug)]`}{` is the easiest solution. Then you can print it with {:?}:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`#[derive(Debug)]\nstruct MyStruct{\n    a: i32,\n    b: i32\n}\n\nfn main() {\n    let x = MyStruct{ a: 10, b: 20 };\n    println!(\"{:?}\", x);\n}\n`}</code></pre>\n    <p>{`In use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`// assuming matches is a struct or array\nprintln!(\"{:?}\", matches); // logging out structs or arrays\nprintln!(\"{:#?}\", matches); // pretty print\nprintln!(\"{}\", matches.occurrences_of(\"verbose\"));\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}