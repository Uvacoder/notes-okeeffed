(window.webpackJsonp=window.webpackJsonp||[]).push([[241],{"QPu/":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return r})),t.d(n,"default",(function(){return i}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var o=t("/FXl"),a=t("TjRS");t("aD51");function s(){return(s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}var r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!r.hasOwnProperty("__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Epic-React/Advanced-React-Hooks.md"}});var u={_frontmatter:r},c=a.a;function i(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,["components"]);return Object(o.b)(c,s({},u,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"advanced-react-hooks"},"Advanced React Hooks"),Object(o.b)("h2",{id:"usereducer"},"useReducer"),Object(o.b)("p",null,"In this first exercise, we replace ",Object(o.b)("inlineCode",{parentName:"p"},"React.useState")," with ",Object(o.b)("inlineCode",{parentName:"p"},"React.useReducer"),' in a way that does not adhere to "switch" conventions to show how a reducer works.'),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),'// useReducer: simple Counter\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from \'react\';\n\n// state is prevVale, action is newValue\nfunction countReducer(state, action) {\n  return action;\n}\n\nfunction Counter({ initialCount = 0, step = 1 }) {\n  // 🐨 replace React.useState with React.useReducer.\n  // 💰 React.useReducer(countReducer, initialCount.\n  const [count, setCount] = React.useReducer(countReducer, initialCount);\n\n  // 💰 you can write the countReducer function so you don\'t have to make any\n  // changes to the next two lines of code! Remember:\n  // The 1st argument is called "state" - the current value of count\n  // The 2nd argument is called "newState" - the value passed to setCount\n  const increment = () => setCount(count + step);\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return <Counter />;\n}\n\nexport default App;\n')),Object(o.b)("h3",{id:"accept-step-as-action"},"Accept Step as action"),Object(o.b)("p",null,"We can update that ",Object(o.b)("inlineCode",{parentName:"p"},"newCount")," value to be updated through the ",Object(o.b)("inlineCode",{parentName:"p"},"countReducer"),":"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),'// useReducer: simple Counter\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from \'react\';\n\nfunction countReducer(prevCount, step) {\n  return prevCount + step;\n}\n\nfunction Counter({ initialCount = 0, step = 1 }) {\n  // 🐨 replace React.useState with React.useReducer.\n  // 💰 React.useReducer(countReducer, initialCount.\n  const [count, changeCount] = React.useReducer(countReducer, initialCount);\n\n  // 💰 you can write the countReducer function so you don\'t have to make any\n  // changes to the next two lines of code! Remember:\n  // The 1st argument is called "state" - the current value of count\n  // The 2nd argument is called "newState" - the value passed to changeCount\n  const increment = () => changeCount(step);\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return <Counter />;\n}\n\nexport default App;\n')),Object(o.b)("h3",{id:"setstate-with-object"},"setState with Object"),Object(o.b)("p",null,"We can update the ",Object(o.b)("inlineCode",{parentName:"p"},"useReducer")," to now demonstate the changes using an object."),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useReducer: simple Counter\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n\nconst countReducer = (state, action) => {\n  return {\n    ...state,\n    ...action,\n  };\n};\nfunction Counter({ initialCount = 0, step = 1 }) {\n  const [state, setState] = React.useReducer(countReducer, {\n    count: initialCount,\n  });\n  const { count } = state;\n\n  const increment = () => setState({ count: state.count + step });\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return <Counter />;\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"object-or-function"},"Object or Function"),Object(o.b)("p",null,"Instead of merging as a function, we can turn ",Object(o.b)("inlineCode",{parentName:"p"},"setState")," into a function that acceps the state:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useReducer: simple Counter\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n\nconst countReducer = (state, action) => {\n  return action(state);\n};\nfunction Counter({ initialCount = 0, step = 1 }) {\n  const [state, setState] = React.useReducer(countReducer, {\n    count: initialCount,\n  });\n  const { count } = state;\n\n  const increment = () =>\n    setState(currentState => ({ count: currentState.count + step }));\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return <Counter />;\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"traditional-dispatch-object"},"Traditional Dispatch Object"),Object(o.b)("p",null,"As an initial conversion to use ",Object(o.b)("inlineCode",{parentName:"p"},"[state, dispatch]"),", I came up with the following adjustment to use actions:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useReducer: simple Counter\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n\nconst actions = {\n  UPDATE_COUNT: 'UPDATE_COUNT',\n};\n\nfunction countReducer(state, action) {\n  switch (action.type) {\n    case actions.UPDATE_COUNT:\n      return {\n        ...state,\n        count: action.payload,\n      };\n    default:\n      return state;\n  }\n}\n\nfunction Counter({ initialCount = 0, step = 1 }) {\n  // 🐨 replace React.useState with React.useReducer.\n  // 💰 React.useReducer(countReducer, initialCount.\n  const [state, dispatch] = React.useReducer(countReducer, {\n    count: initialCount,\n  });\n\n  console.log(state);\n\n  // 💰 you can write the countReducer function so you don't have to make any\n  // changes to the next two lines of code! Remember:\n  // The 1st argument is called \"state\" - the current value of count\n  // The 2nd argument is called \"newState\" - the value passed to setCount\n  const increment = () =>\n    dispatch({\n      type: actions.UPDATE_COUNT,\n      payload: state.count + step,\n    });\n  return <button onClick={increment}>{state.count}</button>;\n}\n\nfunction App() {\n  return <Counter />;\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"lazy-initialization"},"Lazy initialization"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"function init(initialStateFromProps) {\n  return {\n    pokemon: null,\n    loading: false,\n    error: null,\n  };\n}\n\n// ...\n\nconst [state, dispatch] = React.useReducer(reducer, props.initialState, init);\n")),Object(o.b)("p",null,"So, if you pass a third function argument to useReducer, it passes the second argument to that function and uses the return value for the initial state."),Object(o.b)("p",null,"This could be useful if our init function read into ",Object(o.b)("inlineCode",{parentName:"p"},"localStorage")," or something else that we wouldn’t want happening every re-render."),Object(o.b)("h3",{id:"typescript-defs-for-usereducer-api"},"TypeScript defs for useReducer API"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-ts"}),"type Dispatch<A> = (value: A) => void;\ntype Reducer<S, A> = (prevState: S, action: A) => S;\ntype ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any>\n  ? S\n  : never;\ntype ReducerAction<R extends Reducer<any, any>> = R extends Reducer<\n  any,\n  infer A\n>\n  ? A\n  : never;\n\nfunction useReducer<R extends Reducer<any, any>, I>(\n  reducer: R,\n  initializerArg: I & ReducerState<R>,\n  initializer: (arg: I & ReducerState<R>) => ReducerState<R>,\n): [ReducerState<R>, Dispatch<ReducerAction<R>>];\n\nfunction useReducer<R extends Reducer<any, any>, I>(\n  reducer: R,\n  initializerArg: I,\n  initializer: (arg: I) => ReducerState<R>,\n): [ReducerState<R>, Dispatch<ReducerAction<R>>];\n\nfunction useReducer<R extends Reducer<any, any>>(\n  reducer: R,\n  initialState: ReducerState<R>,\n  initializer?: undefined,\n): [ReducerState<R>, Dispatch<ReducerAction<R>>];\n")),Object(o.b)("h2",{id:"usecallback-custom-hooks"},"useCallback: custom hooks"),Object(o.b)("p",null,"The problem ",Object(o.b)("inlineCode",{parentName:"p"},"useCallback")," solves:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"const updateLocalStorage = React.useCallback(\n  () => window.localStorage.setItem('count', count),\n  [count], // <-- yup! That's a dependency list!\n);\nReact.useEffect(() => {\n  updateLocalStorage();\n}, [updateLocalStorage]);\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"useMemo")," helps memoisation for expensive calculations and to prevent re-renders but is at few times needed. See ",Object(o.b)("a",s({parentName:"p"},{href:"https://kentcdodds.com/blog/usememo-and-usecallback"}),"this article")," for more information."),Object(o.b)("h2",{id:"usecallback"},"useCallback"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\"We're going to make a custom hook. Often, you'll find that when you're making custom hooks, you have to use memoization techniques like useCallback.\"")),Object(o.b)("p",null,"The ultimate solution looks like so:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useCallback: custom hooks\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport {\n  fetchPokemon,\n  PokemonForm,\n  PokemonDataView,\n  PokemonInfoFallback,\n  PokemonErrorBoundary,\n} from '../pokemon';\n\nfunction asyncReducer(state, action) {\n  switch (action.type) {\n    case 'pending': {\n      return { status: 'pending', data: null, error: null };\n    }\n    case 'resolved': {\n      return { status: 'resolved', data: action.data, error: null };\n    }\n    case 'rejected': {\n      return { status: 'rejected', data: null, error: action.error };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction useAsync(asyncCallback, initialState) {\n  const [state, dispatch] = React.useReducer(asyncReducer, {\n    status: 'idle',\n    data: null,\n    error: null,\n    ...initialState,\n  });\n\n  React.useEffect(() => {\n    // 💰 this first early-exit bit is a little tricky, so let me give you a hint:\n    const promise = asyncCallback();\n    if (!promise) {\n      return;\n    }\n\n    dispatch({ type: 'pending' });\n    promise.then(\n      data => {\n        dispatch({ type: 'resolved', data });\n      },\n      error => {\n        dispatch({ type: 'rejected', error });\n      },\n    );\n\n    // the react-hooks/exhaustive-deps rule. We'll fix this in an extra credit.\n  }, [asyncCallback]);\n\n  return state;\n}\n\nfunction PokemonInfo({ pokemonName }) {\n  const callback = React.useCallback(() => {\n    if (!pokemonName) {\n      return;\n    }\n    return fetchPokemon(pokemonName);\n  }, [pokemonName]);\n  // 🐨 move both the useReducer and useEffect hooks to a custom hook called useAsync\n  // here's how you use it:\n  const state = useAsync(callback, {\n    status: pokemonName ? 'pending' : 'idle',\n  });\n\n  // 🐨 this will change from \"pokemon\" to \"data\"\n  const { data: pokemon, status, error } = state;\n\n  if (status === 'idle' || !pokemonName) {\n    return 'Submit a pokemon';\n  } else if (status === 'pending') {\n    return <PokemonInfoFallback name={pokemonName} />;\n  } else if (status === 'rejected') {\n    throw error;\n  } else if (status === 'resolved') {\n    return <PokemonDataView pokemon={pokemon} />;\n  }\n\n  throw new Error('This should be impossible');\n}\n\nfunction App() {\n  const [pokemonName, setPokemonName] = React.useState('');\n\n  function handleSubmit(newPokemonName) {\n    setPokemonName(newPokemonName);\n  }\n\n  function handleReset() {\n    setPokemonName('');\n  }\n\n  return (\n    <div className=\"pokemon-info-app\">\n      <PokemonForm pokemonName={pokemonName} onSubmit={handleSubmit} />\n      <hr />\n      <div className=\"pokemon-info\">\n        <PokemonErrorBoundary onReset={handleReset} resetKeys={[pokemonName]}>\n          <PokemonInfo pokemonName={pokemonName} />\n        </PokemonErrorBoundary>\n      </div>\n    </div>\n  );\n}\n\nfunction AppWithUnmountCheckbox() {\n  const [mountApp, setMountApp] = React.useState(true);\n  return (\n    <div>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={mountApp}\n          onChange={e => setMountApp(e.target.checked)}\n        />{' '}\n        Mount Component\n      </label>\n      <hr />\n      {mountApp ? <App /> : null}\n    </div>\n  );\n}\n\nexport default AppWithUnmountCheckbox;\n")),Object(o.b)("h3",{id:"return-memoized-run-function"},"Return memoized run function"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"\"Personally, I'm not a huge fan of APIs that require you to memoize the thing you pass into them because I don't think the pit of success is very wide here. It's really easy to just be like, \"Oh, sweet. I'm going to use this useAsync thing. I'm going to pass this function.\" That's pretty easy and boom, we've just sub-optimized ourselves.\"")),Object(o.b)("p",null,"This meant ensure that use callback was called in the async func and passing the promise to the returned ",Object(o.b)("inlineCode",{parentName:"p"},"run")," function."),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useCallback: custom hooks\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport {\n  fetchPokemon,\n  PokemonForm,\n  PokemonDataView,\n  PokemonInfoFallback,\n  PokemonErrorBoundary,\n} from '../pokemon';\n\n// 🐨 this is going to be our generic asyncReducer\nfunction asyncReducer(state, action) {\n  switch (action.type) {\n    case 'pending': {\n      return { status: 'pending', data: null, error: null };\n    }\n    case 'resolved': {\n      return { status: 'resolved', data: action.data, error: null };\n    }\n    case 'rejected': {\n      return { status: 'rejected', data: null, error: action.error };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction useAsync(initialState) {\n  const [state, dispatch] = React.useReducer(asyncReducer, {\n    status: 'idle',\n    data: null,\n    error: null,\n    ...initialState,\n  });\n\n  const run = React.useCallback(promise => {\n    dispatch({ type: 'pending' });\n    promise.then(\n      data => {\n        dispatch({ type: 'resolved', data });\n      },\n      error => {\n        dispatch({ type: 'rejected', error });\n      },\n    );\n  }, []);\n\n  return { ...state, run };\n}\n\nfunction PokemonInfo({ pokemonName }) {\n  const { data: pokemon, status, error, run } = useAsync({\n    status: pokemonName ? 'pending' : 'idle',\n  });\n\n  React.useEffect(() => {\n    if (!pokemonName) {\n      return;\n    }\n    run(fetchPokemon(pokemonName));\n  }, [pokemonName, run]);\n\n  if (status === 'idle' || !pokemonName) {\n    return 'Submit a pokemon';\n  } else if (status === 'pending') {\n    return <PokemonInfoFallback name={pokemonName} />;\n  } else if (status === 'rejected') {\n    throw error;\n  } else if (status === 'resolved') {\n    return <PokemonDataView pokemon={pokemon} />;\n  }\n\n  throw new Error('This should be impossible');\n}\n\nfunction App() {\n  const [pokemonName, setPokemonName] = React.useState('');\n\n  function handleSubmit(newPokemonName) {\n    setPokemonName(newPokemonName);\n  }\n\n  function handleReset() {\n    setPokemonName('');\n  }\n\n  return (\n    <div className=\"pokemon-info-app\">\n      <PokemonForm pokemonName={pokemonName} onSubmit={handleSubmit} />\n      <hr />\n      <div className=\"pokemon-info\">\n        <PokemonErrorBoundary onReset={handleReset} resetKeys={[pokemonName]}>\n          <PokemonInfo pokemonName={pokemonName} />\n        </PokemonErrorBoundary>\n      </div>\n    </div>\n  );\n}\n\nfunction AppWithUnmountCheckbox() {\n  const [mountApp, setMountApp] = React.useState(true);\n  return (\n    <div>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={mountApp}\n          onChange={e => setMountApp(e.target.checked)}\n        />{' '}\n        Mount Component\n      </label>\n      <hr />\n      {mountApp ? <App /> : null}\n    </div>\n  );\n}\n\nexport default AppWithUnmountCheckbox;\n")),Object(o.b)("h3",{id:"safe-dispatch"},"Safe dispatch"),Object(o.b)("p",null,"We are dealing with ensuring that if we make a promise and the user navigates, we do not attempt to call dispatch."),Object(o.b)("p",null,"We also use ",Object(o.b)("inlineCode",{parentName:"p"},"useLayoutEffect")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"useEffect")," to ensure we call the hook once the component has mounted and not when the screen has been painted."),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useCallback: custom hooks\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport {\n  fetchPokemon,\n  PokemonForm,\n  PokemonDataView,\n  PokemonInfoFallback,\n  PokemonErrorBoundary,\n} from '../pokemon';\n\n// 🐨 this is going to be our generic asyncReducer\nfunction asyncReducer(state, action) {\n  switch (action.type) {\n    case 'pending': {\n      return { status: 'pending', data: null, error: null };\n    }\n    case 'resolved': {\n      return { status: 'resolved', data: action.data, error: null };\n    }\n    case 'rejected': {\n      return { status: 'rejected', data: null, error: action.error };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\n// Here is our new function\nfunction useSafeDispatch(dispatch) {\n  const mountedRef = React.useRef(false);\n  React.useLayoutEffect(() => {\n    mountedRef.current = true;\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n\n  return React.useCallback(\n    (...args) => {\n      if (mountedRef.current) {\n        dispatch(...args);\n      }\n    },\n    [dispatch],\n  );\n}\n\nfunction useAsync(initialState) {\n  const [state, unsafeDispatch] = React.useReducer(asyncReducer, {\n    status: 'idle',\n    data: null,\n    error: null,\n    ...initialState,\n  });\n\n  const dispatch = useSafeDispatch(unsafeDispatch);\n\n  const run = React.useCallback(\n    promise => {\n      dispatch({ type: 'pending' });\n      promise.then(\n        data => {\n          dispatch({ type: 'resolved', data });\n        },\n        error => {\n          dispatch({ type: 'rejected', error });\n        },\n      );\n    },\n    [dispatch],\n  );\n\n  return { ...state, run };\n}\n\nfunction PokemonInfo({ pokemonName }) {\n  const { data: pokemon, status, error, run } = useAsync({\n    status: pokemonName ? 'pending' : 'idle',\n  });\n\n  React.useEffect(() => {\n    if (!pokemonName) {\n      return;\n    }\n    run(fetchPokemon(pokemonName));\n  }, [pokemonName, run]);\n\n  if (status === 'idle' || !pokemonName) {\n    return 'Submit a pokemon';\n  } else if (status === 'pending') {\n    return <PokemonInfoFallback name={pokemonName} />;\n  } else if (status === 'rejected') {\n    throw error;\n  } else if (status === 'resolved') {\n    return <PokemonDataView pokemon={pokemon} />;\n  }\n\n  throw new Error('This should be impossible');\n}\n\nfunction App() {\n  const [pokemonName, setPokemonName] = React.useState('');\n\n  function handleSubmit(newPokemonName) {\n    setPokemonName(newPokemonName);\n  }\n\n  function handleReset() {\n    setPokemonName('');\n  }\n\n  return (\n    <div className=\"pokemon-info-app\">\n      <PokemonForm pokemonName={pokemonName} onSubmit={handleSubmit} />\n      <hr />\n      <div className=\"pokemon-info\">\n        <PokemonErrorBoundary onReset={handleReset} resetKeys={[pokemonName]}>\n          <PokemonInfo pokemonName={pokemonName} />\n        </PokemonErrorBoundary>\n      </div>\n    </div>\n  );\n}\n\nfunction AppWithUnmountCheckbox() {\n  const [mountApp, setMountApp] = React.useState(true);\n  return (\n    <div>\n      <label>\n        <input\n          type=\"checkbox\"\n          checked={mountApp}\n          onChange={e => setMountApp(e.target.checked)}\n        />{' '}\n        Mount Component\n      </label>\n      <hr />\n      {mountApp ? <App /> : null}\n    </div>\n  );\n}\n\nexport default AppWithUnmountCheckbox;\n")),Object(o.b)("h2",{id:"usecontext"},"useContext"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},'"Context is an API that allows you to share state between different components in your React tree.\n" It\'s typically something that is better suited for libraries than for your application code.\n"Typically, it\'s better to reach first for composition as a solution to this problem."')),Object(o.b)("p",null,"In this example, we create context, then create a provider for that context (to abstract the ",Object(o.b)("inlineCode",{parentName:"p"},"[Context].Provider"),") and pass that to the components to render:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useContext: simple Counter\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\n\n// 🐨 create your CountContext here with React.createContext\nconst CountContext = React.createContext();\n// 🐨 create a CountProvider component here that does this:\n//   🐨 get the count state and setCount updater with React.useState\n//   🐨 create a `value` array with count and setCount\n//   🐨 return your context provider with the value assigned to that array and forward all the other props\n//   💰 more specifically, we need the children prop forwarded to the context provider\nfunction CountProvider(props) {\n  const [count, setCount] = React.useState(0);\n  const value = [count, setCount];\n\n  return <CountContext.Provider value={value} {...props} />;\n}\n\nfunction CountDisplay() {\n  // 🐨 get the count from useContext with the CountContext\n  const [count] = React.useContext(CountContext);\n\n  return <div>{`The current count is ${count}`}</div>;\n}\n\nfunction Counter() {\n  // 🐨 get the setCount from useContext with the CountContext\n  const [, setCount] = React.useContext(CountContext);\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>Increment count</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <CountProvider>\n        <CountDisplay />\n        <Counter />\n      </CountProvider>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"enforcing-usecount-with-a-consumer-hook"},"Enforcing useCount with a Consumer Hook"),Object(o.b)("p",null,"For consumer components, what happens if you accidentally do not wrap them within the correct context? Currently, the app will blow up without much useful information."),Object(o.b)("p",null,"What we can do is abstract the context to be within its own function and use it as a hook that throws an error if there is no context."),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useContext: simple Counter\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\n\n// CountContext, CountProvider and useCount can all be abstracted into its own file\n\n// 🐨 create your CountContext here with React.createContext\nconst CountContext = React.createContext();\n// 🐨 create a CountProvider component here that does this:\n//   🐨 get the count state and setCount updater with React.useState\n//   🐨 create a `value` array with count and setCount\n//   🐨 return your context provider with the value assigned to that array and forward all the other props\n//   💰 more specifically, we need the children prop forwarded to the context provider\nfunction CountProvider(props) {\n  const [count, setCount] = React.useState(0);\n  const value = [count, setCount];\n\n  return <CountContext.Provider value={value} {...props} />;\n}\n\nfunction useCount() {\n  const context = React.useContext(CountContext);\n  if (!context) {\n    throw new Error(`useCount must be rendered within the CountProvider`);\n  }\n  return context;\n}\n\nfunction CountDisplay() {\n  // 🐨 get the count from useContext with the CountContext\n  const [count] = useCount();\n\n  return <div>{`The current count is ${count}`}</div>;\n}\n\nfunction Counter() {\n  // 🐨 get the setCount from useContext with the CountContext\n  const [, setCount] = useCount();\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>Increment count</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <CountProvider>\n        <CountDisplay />\n        <Counter />\n      </CountProvider>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"caching-previous-state"},"Caching previous state"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: Kent mentions here that normally what he would do is to have lifted state but using context certainly does have its use cases.")),Object(o.b)("p",null,"Here we are using React Context to create a cache that is abstracted into its own provider and context with a hook."),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"import * as React from 'react';\nimport {\n  fetchPokemon,\n  PokemonForm,\n  PokemonDataView,\n  PokemonInfoFallback,\n  PokemonErrorBoundary,\n} from '../pokemon';\nimport { useAsync } from '../utils';\n\n// 🐨 Create a PokemonCacheContext\nconst PokemonCacheContext = React.createContext();\n\nfunction PokemonCacheProvider(props) {\n  // 💣 remove the useReducer here (or move it up to your PokemonCacheProvider)\n  const [cache, dispatch] = React.useReducer(pokemonCacheReducer, {});\n  const value = [cache, dispatch];\n  return <PokemonCacheContext.Provider value={value} {...props} />;\n}\n\nfunction pokemonCacheReducer(state, action) {\n  switch (action.type) {\n    case 'ADD_POKEMON': {\n      return { ...state, [action.pokemonName]: action.pokemonData };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction usePokemonCache() {\n  const context = React.useContext(PokemonCacheContext);\n  if (!context) {\n    throw new Error('Requires PokemonCacheProvider');\n  }\n\n  return context;\n}\n\nfunction PokemonInfo({ pokemonName }) {\n  // 🐨 get the cache and dispatch from useContext with PokemonCacheContext\n  const [cache, dispatch] = usePokemonCache();\n  const { data: pokemon, status, error, run, setData } = useAsync();\n\n  React.useEffect(() => {\n    if (!pokemonName) {\n      return;\n    } else if (cache[pokemonName]) {\n      setData(cache[pokemonName]);\n    } else {\n      run(\n        fetchPokemon(pokemonName).then(pokemonData => {\n          dispatch({ type: 'ADD_POKEMON', pokemonName, pokemonData });\n          return pokemonData;\n        }),\n      );\n    }\n  }, [cache, dispatch, pokemonName, run, setData]);\n\n  if (status === 'idle') {\n    return 'Submit a pokemon';\n  } else if (status === 'pending') {\n    return <PokemonInfoFallback name={pokemonName} />;\n  } else if (status === 'rejected') {\n    throw error;\n  } else if (status === 'resolved') {\n    return <PokemonDataView pokemon={pokemon} />;\n  }\n}\n\nfunction PreviousPokemon({ onSelect }) {\n  // 🐨 get the cache from useContext with PokemonCacheContext\n  const [cache] = usePokemonCache();\n\n  return (\n    <div>\n      Previous Pokemon\n      <ul style={{ listStyle: 'none', paddingLeft: 0 }}>\n        {Object.keys(cache).map(pokemonName => (\n          <li key={pokemonName} style={{ margin: '4px auto' }}>\n            <button\n              style={{ width: '100%' }}\n              onClick={() => onSelect(pokemonName)}\n            >\n              {pokemonName}\n            </button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nfunction PokemonSection({ onSelect, pokemonName }) {\n  // 🐨 wrap this in the PokemonCacheProvider so the PreviousPokemon\n  // and PokemonInfo components have access to that context.\n  return (\n    <PokemonCacheProvider>\n      <div style={{ display: 'flex' }}>\n        <PreviousPokemon onSelect={onSelect} />\n        <div className=\"pokemon-info\" style={{ marginLeft: 10 }}>\n          <PokemonErrorBoundary\n            onReset={() => onSelect('')}\n            resetKeys={[pokemonName]}\n          >\n            <PokemonInfo pokemonName={pokemonName} />\n          </PokemonErrorBoundary>\n        </div>\n      </div>\n    </PokemonCacheProvider>\n  );\n}\n\nfunction App() {\n  const [pokemonName, setPokemonName] = React.useState(null);\n\n  function handleSubmit(newPokemonName) {\n    setPokemonName(newPokemonName);\n  }\n\n  function handleSelect(newPokemonName) {\n    setPokemonName(newPokemonName);\n  }\n\n  return (\n    <div className=\"pokemon-info-app\">\n      <PokemonForm pokemonName={pokemonName} onSubmit={handleSubmit} />\n      <hr />\n      <PokemonSection onSelect={handleSelect} pokemonName={pokemonName} />\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h2",{id:"uselayouteffect"},"useLayoutEffect"),Object(o.b)("p",null,"There are two ways to tell React to run side-effects after it renders:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"useEffect"),Object(o.b)("li",{parentName:"ol"},"useLayoutEffect")),Object(o.b)("p",null,"The difference about these is subtle (they have the exact same API), but significant. 99% of the time useEffect is what you want, but sometimes useLayoutEffect can improve your user experience."),Object(o.b)("p",null,"There is a ",Object(o.b)("a",s({parentName:"p"},{href:"https://kentcdodds.com/blog/useeffect-vs-uselayouteffect/"}),"blog post")," on this by Kent."),Object(o.b)("p",null,"The summary:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"useLayoutEffect: If you need to mutate the DOM and/or do need to perform measurements"),Object(o.b)("li",{parentName:"ol"},"useEffect: If you don't need to interact with the DOM at all or your DOM changes are unobservable (seriously, most of the time you should use this).")),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"import * as React from 'react';\n\nfunction MessagesDisplay({ messages }) {\n  const containerRef = React.useRef();\n  // this is where the jank happens if using `useEffect`\n  React.useLayoutEffect(() => {\n    containerRef.current.scrollTop = containerRef.current.scrollHeight;\n  });\n\n  return (\n    <div ref={containerRef} role=\"log\">\n      {messages.map((message, index, array) => (\n        <div key={message.id}>\n          <strong>{message.author}</strong>: <span>{message.content}</span>\n          {array.length - 1 === index ? null : <hr />}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// this is to simulate major computation/big rendering tree/etc.\nfunction sleep(time = 0) {\n  const wakeUpTime = Date.now() + time;\n  while (Date.now() < wakeUpTime) {}\n}\n\nfunction SlooooowSibling() {\n  // try this with useLayoutEffect as well to see\n  // how it impacts interactivity of the page before updates.\n  React.useEffect(() => {\n    // increase this number to see a more stark difference\n    sleep(300);\n  });\n  return null;\n}\n\nfunction App() {\n  const [messages, setMessages] = React.useState(allMessages.slice(0, 8));\n  const addMessage = () =>\n    messages.length < allMessages.length\n      ? setMessages(allMessages.slice(0, messages.length + 1))\n      : null;\n  const removeMessage = () =>\n    messages.length > 0\n      ? setMessages(allMessages.slice(0, messages.length - 1))\n      : null;\n\n  return (\n    <div className=\"messaging-app\">\n      <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n        <button onClick={addMessage}>add message</button>\n        <button onClick={removeMessage}>remove message</button>\n      </div>\n      <hr />\n      <MessagesDisplay messages={messages} />\n      <SlooooowSibling />\n    </div>\n  );\n}\n\nexport default App;\n\nconst allMessages = [\n  `Leia: Aren't you a little short to be a stormtrooper?`,\n  `Luke: What? Oh... the uniform. I'm Luke Skywalker. I'm here to rescue you.`,\n  `Leia: You're who?`,\n  `Luke: I'm here to rescue you. I've got your R2 unit. I'm here with Ben Kenobi.`,\n  `Leia: Ben Kenobi is here! Where is he?`,\n  `Luke: Come on!`,\n  `Luke: Will you forget it? I already tried it. It's magnetically sealed!`,\n  `Leia: Put that thing away! You're going to get us all killed.`,\n  `Han: Absolutely, Your Worship. Look, I had everything under control until you led us down here. You know, it's not going to take them long to figure out what happened to us.`,\n  `Leia: It could be worse...`,\n  `Han: It's worse.`,\n  `Luke: There's something alive in here!`,\n  `Han: That's your imagination.`,\n  `Luke: Something just moves past my leg! Look! Did you see that?`,\n  `Han: What?`,\n  `Luke: Help!`,\n  `Han: Luke! Luke! Luke!`,\n  `Leia: Luke!`,\n  `Leia: Luke, Luke, grab a hold of this.`,\n  `Luke: Blast it, will you! My gun's jammed.`,\n  `Han: Where?`,\n  `Luke: Anywhere! Oh!!`,\n  `Han: Luke! Luke!`,\n  `Leia: Grab him!`,\n  `Leia: What happened?`,\n  `Luke: I don't know, it just let go of me and disappeared...`,\n  `Han: I've got a very bad feeling about this.`,\n  `Luke: The walls are moving!`,\n  `Leia: Don't just stand there. Try to brace it with something.`,\n  `Luke: Wait a minute!`,\n  `Luke: Threepio! Come in Threepio! Threepio! Where could he be?`,\n].map((m, i) => ({\n  id: i,\n  author: m.split(': ')[0],\n  content: m.split(': ')[1],\n}));\n")),Object(o.b)("h2",{id:"useimperativehandle"},"useImperativeHandle"),Object(o.b)("p",null,"This is a hook that you will RARELY want to use. The use case given is for forwarding refs in function components and using the hook to call the functions imperatively:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"// useImperativeHandle: scroll to top/bottom\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\n\n// 🐨 wrap this in a React.forwardRef and accept `ref` as the second argument\nconst MessagesDisplay = React.forwardRef(function MessagesDisplay(\n  { messages },\n  ref,\n) {\n  const containerRef = React.useRef();\n  React.useLayoutEffect(() => {\n    scrollToBottom();\n  });\n\n  // 💰 you're gonna want this as part of your imperative methods\n  function scrollToTop() {\n    containerRef.current.scrollTop = 0;\n  }\n  function scrollToBottom() {\n    containerRef.current.scrollTop = containerRef.current.scrollHeight;\n  }\n\n  // 🐨 call useImperativeHandle here with your ref and a callback function\n  // that returns an object with scrollToTop and scrollToBottom\n  React.useImperativeHandle(ref, () => {\n    return {\n      scrollToTop,\n      scrollToBottom,\n    };\n  });\n\n  return (\n    <div ref={containerRef} role=\"log\">\n      {messages.map((message, index, array) => (\n        <div key={message.id}>\n          <strong>{message.author}</strong>: <span>{message.content}</span>\n          {array.length - 1 === index ? null : <hr />}\n        </div>\n      ))}\n    </div>\n  );\n});\n\nfunction App() {\n  const messageDisplayRef = React.useRef();\n  const [messages, setMessages] = React.useState(allMessages.slice(0, 8));\n  const addMessage = () =>\n    messages.length < allMessages.length\n      ? setMessages(allMessages.slice(0, messages.length + 1))\n      : null;\n  const removeMessage = () =>\n    messages.length > 0\n      ? setMessages(allMessages.slice(0, messages.length - 1))\n      : null;\n\n  const scrollToTop = () => messageDisplayRef.current.scrollToTop();\n  const scrollToBottom = () => messageDisplayRef.current.scrollToBottom();\n\n  return (\n    <div className=\"messaging-app\">\n      <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n        <button onClick={addMessage}>add message</button>\n        <button onClick={removeMessage}>remove message</button>\n      </div>\n      <hr />\n      <div>\n        <button onClick={scrollToTop}>scroll to top</button>\n      </div>\n      <MessagesDisplay ref={messageDisplayRef} messages={messages} />\n      <div>\n        <button onClick={scrollToBottom}>scroll to bottom</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\nconst allMessages = [\n  `Leia: Aren't you a little short to be a stormtrooper?`,\n  `Luke: What? Oh... the uniform. I'm Luke Skywalker. I'm here to rescue you.`,\n  `Leia: You're who?`,\n  `Luke: I'm here to rescue you. I've got your R2 unit. I'm here with Ben Kenobi.`,\n  `Leia: Ben Kenobi is here! Where is he?`,\n  `Luke: Come on!`,\n  `Luke: Will you forget it? I already tried it. It's magnetically sealed!`,\n  `Leia: Put that thing away! You're going to get us all killed.`,\n  `Han: Absolutely, Your Worship. Look, I had everything under control until you led us down here. You know, it's not going to take them long to figure out what happened to us.`,\n  `Leia: It could be worse...`,\n  `Han: It's worse.`,\n  `Luke: There's something alive in here!`,\n  `Han: That's your imagination.`,\n  `Luke: Something just moves past my leg! Look! Did you see that?`,\n  `Han: What?`,\n  `Luke: Help!`,\n  `Han: Luke! Luke! Luke!`,\n  `Leia: Luke!`,\n  `Leia: Luke, Luke, grab a hold of this.`,\n  `Luke: Blast it, will you! My gun's jammed.`,\n  `Han: Where?`,\n  `Luke: Anywhere! Oh!!`,\n  `Han: Luke! Luke!`,\n  `Leia: Grab him!`,\n  `Leia: What happened?`,\n  `Luke: I don't know, it just let go of me and disappeared...`,\n  `Han: I've got a very bad feeling about this.`,\n  `Luke: The walls are moving!`,\n  `Leia: Don't just stand there. Try to brace it with something.`,\n  `Luke: Wait a minute!`,\n  `Luke: Threepio! Come in Threepio! Threepio! Where could he be?`,\n].map((m, i) => ({\n  id: i,\n  author: m.split(': ')[0],\n  content: m.split(': ')[1],\n}));\n")),Object(o.b)("h2",{id:"usedebugvalue"},"useDebugValue"),Object(o.b)("p",null,"Only useful for custom hooks in your React DevTools browser extension."),Object(o.b)("p",null,"The use case we are solving here is that we have three ",Object(o.b)("inlineCode",{parentName:"p"},"useMedia")," hooks. Under the ",Object(o.b)("inlineCode",{parentName:"p"},"useDebugValue"),' hook, we don\'t have much more information than the "hooks" and their values for ',Object(o.b)("inlineCode",{parentName:"p"},"State")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Effect"),". We want to get more information like a label:"),Object(o.b)("pre",null,Object(o.b)("code",s({parentName:"pre"},{className:"language-js"}),"import * as React from 'react';\n\n// you don't need this in this example\nconst formatCountDebugValue = ({ query, state }) => `\\`${query}\\` => ${state}`;\n\nfunction useMedia(query, initialState = false) {\n  const [state, setState] = React.useState(initialState);\n  // 🐨 call React.useDebugValue here. Generally you should just put the commented out\n  // on the second line\n  React.useDebugValue({ query, state }, formatCountDebugValue);\n  // React.useDebugValue(`\\`${query}\\` => ${state}`)\n\n  React.useEffect(() => {\n    let mounted = true;\n    const mql = window.matchMedia(query);\n    function onChange() {\n      if (!mounted) {\n        return;\n      }\n      setState(Boolean(mql.matches));\n    }\n\n    mql.addListener(onChange);\n    setState(mql.matches);\n\n    return () => {\n      mounted = false;\n      mql.removeListener(onChange);\n    };\n  }, [query]);\n\n  return state;\n}\n\nfunction Box() {\n  const isBig = useMedia('(min-width: 1000px)');\n  const isMedium = useMedia('(max-width: 999px) and (min-width: 700px)');\n  const isSmall = useMedia('(max-width: 699px)');\n  const color = isBig ? 'green' : isMedium ? 'yellow' : isSmall ? 'red' : null;\n\n  return <div style={{ width: 200, height: 200, backgroundColor: color }} />;\n}\n\nfunction App() {\n  return <Box />;\n}\n\nexport default App;\n")))}i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Epic-React/Advanced-React-Hooks.md"}}),i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-epic-react-advanced-react-hooks-md-c8f1d0e18cc536d2144a.js.map