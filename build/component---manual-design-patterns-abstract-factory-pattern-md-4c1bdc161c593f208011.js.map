{"version":3,"sources":["webpack:///../manual/Design-Patterns/Abstract-Factory-Pattern.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ofAMO,IAAMA,EAAe,Q,oOAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,oBADR,oBAGA,+CAA8B,0BAAYC,WAAW,KAAvB,cAA9B,mBAAwG,0BAAYA,WAAW,KAAvB,oBAAxG,KACA,wDAAuC,0BAAYA,WAAW,KAAvB,WAAvC,2IACA,8BACE,iBAAGA,WAAW,cAAd,yHAEF,0KACA,8BACE,iBAAGA,WAAW,cAAd,8IAEF,8OACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6zGA+IL,iBAAQ,CACN,GAAM,cADR,cAGA,sBACE,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,8HADQ,oDAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,mGADQ,0C,2NAQ1BJ,EAAWK,gBAAiB","file":"component---manual-design-patterns-abstract-factory-pattern-md-4c1bdc161c593f208011.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"abstract-factory\"\n    }}>{`Abstract Factory`}</h1>\n    <p>{`Here we will cover the `}<inlineCode parentName=\"p\">{`creational`}</inlineCode>{` design pattern `}<inlineCode parentName=\"p\">{`Abstract Factory`}</inlineCode>{`.`}</p>\n    <p>{`Another creational pattern, the `}<inlineCode parentName=\"p\">{`Factory`}</inlineCode>{` design pattern, differs from Abstract Factory in that the factory method is a single method, whereas an abstract factory is an object.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`... the Factory Method pattern uses inheritance and relies on a subclass to handle the desired object instantiation.`}</p>\n    </blockquote>\n    <p>{`This quote assumes the object is calling its own factory method, therefore the only thing that could change the return value would be a subclass.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`... with the Abstract Factory pattern, a class delegates the responsibility of object instantiation to another object via composition ...`}</p>\n    </blockquote>\n    <p>{`Here there is an object A who wants to make a Foo object. Instead of making the Foo object itself (like in the factory method), it's going to get a different object (the abstract factory) to create the Foo object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// defining our abstract products\ninterface Processor {\n    performOperation(): void;\n}\n\ninterface HardDisk {\n    storeData(): void;\n}\n\ninterface Monitor {\n    displayPicture(): void;\n}\n\n// defining our concrete products\nclass ExpensiveProcessor implements Processor {\n    performOperation() {\n        console.log('Operation will perform quickly!');\n    }\n}\n\nclass CheapProcessor implements Processor {\n    performOperation() {\n        console.log('Operation will perform slowly!');\n    }\n}\n\nclass ExpensiveHDD implements HardDisk {\n    storeData() {\n        console.log('Data will take less time to store');\n    }\n}\n\nclass CheapHDD implements HardDisk {\n    storeData() {\n        console.log('Data will take more time to store');\n    }\n}\n\nclass HighResMonitor implements Monitor {\n    displayPicture() {\n        console.log('High picture quality');\n    }\n}\n\nclass LowResMonitor implements Monitor {\n    displayPicture() {\n        console.log('Low picture quality');\n    }\n}\n\n// defining the abstract factory\ninterface MachineAbstractFactory {\n    // each factory needs to implement these methods\n    getProcessor(): Processor;\n    getHardDisk(): HardDisk;\n    getMonitor(): Monitor;\n}\n\n// defining our concrete factories\nclass HighBudgetMachineFactory implements MachineAbstractFactory {\n    getProcessor(): Processor {\n        return new ExpensiveProcessor();\n    }\n\n    getHardDisk(): HardDisk {\n        return new ExpensiveHDD();\n    }\n\n    getMonitor(): Monitor {\n        return new HighResMonitor();\n    }\n}\n\nclass LowBudgetMachineFactory implements MachineAbstractFactory {\n    getProcessor(): Processor {\n        return new CheapProcessor();\n    }\n\n    getHardDisk(): HardDisk {\n        return new CheapHDD();\n    }\n\n    getMonitor(): Monitor {\n        return new LowResMonitor();\n    }\n}\n\n// defining our client and final product\ninterface Machine {\n    processor: Processor;\n    hdd: HardDisk;\n    monitor: Monitor;\n}\n\nclass ComputerShop {\n    // change access modifiers as suits\n    public category: MachineAbstractFactory;\n\n    // we'll pass a factory as category during instantiation\n    constructor(category: MachineAbstractFactory) {\n        this.category = category;\n    }\n\n    assembleMachine(): Machine {\n        const processor = this.category.getProcessor();\n        const hdd = this.category.getHardDisk();\n        const monitor = this.category.getMonitor();\n\n        // to be explicit\n        const machine: Machine = {\n            processor,\n            hdd,\n            monitor\n        }\n        return machine;\n    }\n}\n\n// running the code in action!\nconst cheapFactory = new LowBudgetMachineFactory();\nconst expensiveFactory = new HighBudgetMachineFactory();\n\n// ensure to pass the factory in during instantiation\n// using let to show variability, in code these\n// would likely be functions that take a factory\n// arg and constants for shop/machine\nlet shop;\nlet machine;\n\nshop = new ComputerShop(cheapFactory);\nmachine = shop.assembleMachine();\nmachine.hdd.storeData();\nmachine.processor.performOperation();\nmachine.monitor.displayPicture();\n\nshop = new ComputerShop(expensiveFactory);\nmachine = shop.assembleMachine();\nmachine.hdd.storeData();\nmachine.processor.performOperation();\nmachine.monitor.displayPicture();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"references\"\n    }}>{`References`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns\"\n        }}>{`Difference between factory and abstract factory`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.codeproject.com/Articles/716413/Factory-Method-Pattern-vs-Abstract-Factory-Pattern\"\n        }}>{`ASP.NET Abstract Factory vs Factory`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}