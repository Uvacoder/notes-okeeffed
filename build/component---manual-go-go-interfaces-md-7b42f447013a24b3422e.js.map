{"version":3,"sources":["webpack:///../manual/Go/Go-Interfaces.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ofAMO,IAAMA,EAAe,Q,4MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,sBADR,sBAGA,yJACA,2KACA,sHACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,mBADZ,oBAIL,iGACA,4HACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,gbA2CL,iBAAQ,CACN,GAAM,wBADR,wBAGA,qFACA,+KACA,iBAAQ,CACN,GAAM,uBADR,uBAGA,wGACA,oIAEA,yKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,4OAqBL,gCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,iDAML,iBAAQ,CACN,GAAM,mBADR,mBAGA,4GACA,qBAAG,0BAAYA,WAAW,KAAvB,eACH,wEAAuD,0BAAYA,WAAW,KAAvB,KAAvD,4BAAiI,0BAAYA,WAAW,KAAvB,KAAjI,+BAA8M,0BAAYA,WAAW,KAAvB,KAA9M,0BAAsR,0BAAYA,WAAW,KAAvB,KAAtR,KACA,2BAAU,0BAAYA,WAAW,KAAvB,KAAV,oBAA4E,0BAAYA,WAAW,KAAvB,KAA5E,yCACA,iNACA,qBAAG,0BAAYA,WAAW,KAAvB,mBACH,2BAAU,0BAAYA,WAAW,KAAvB,KAAV,YAAoE,0BAAYA,WAAW,KAAvB,KAApE,UAA4H,0BAAYA,WAAW,KAAvB,KAA5H,sDACA,2BAAU,0BAAYA,WAAW,KAAvB,WAAV,sBAAoF,0BAAYA,WAAW,KAAvB,KAApF,mCAAqK,0BAAYA,WAAW,KAAvB,KAArK,0BACA,gGACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,8RAsBL,iBAAQ,CACN,GAAM,iBADR,iBAGA,qGACA,oOACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,gKAWL,mKACA,2UACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,oBADZ,uXAuBL,gCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,+E,mMAUTJ,EAAWK,gBAAiB","file":"component---manual-go-go-interfaces-md-7b42f447013a24b3422e.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"go-tour-interfaces\"\n    }}>{`Go Tour Interfaces`}</h1>\n    <p>{`A type implements an interface by implementing its methods. There is no explicit declaration of intent, no \"implements\" keyword.`}</p>\n    <p>{`Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement`}</p>\n    <p>{`Under the hood, interface values can be thought of as a tuple of a value and a concrete type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`(value, type)\n`}</code></pre>\n    <p>{`An interface value holds a value of a specific underlying concrete type.`}</p>\n    <p>{`Calling a method on an interface value executes the method of the same name on its underlying type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\nfunc (t *T) M() {\n    fmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n    fmt.Println(f)\n}\n\nfunc main() {\n    var i I\n\n    i = &T{\"Hello\"}\n    describe(i)\n    i.M()\n\n    i = F(math.Pi)\n    describe(i)\n    i.M()\n}\n\nfunc describe(i I) {\n    fmt.Printf(\"(%v, %T)\\\\n\", i, i)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"nil-interface-values\"\n    }}>{`Nil interface values`}</h2>\n    <p>{`A nil interface value holds neither value nor concrete type.`}</p>\n    <p>{`Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.`}</p>\n    <h2 {...{\n      \"id\": \"the-empty-interface\"\n    }}>{`The empty interface`}</h2>\n    <p>{`The interface type that specifies zero methods is known as the empty interface:`}</p>\n    <p>{`interface{}\nAn empty interface may hold values of any type. (Every type implements at least zero methods.)`}</p>\n    <p>{`Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{}\n    describe(i)\n\n    i = 42\n    describe(i)\n\n    i = \"hello\"\n    describe(i)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"(%v, %T)\\\\n\", i, i)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`(<nil>, <nil>)\n(42, int)\n(hello, string)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-assertions\"\n    }}>{`Type assertions`}</h2>\n    <p>{`A type assertion provides access to an interface value's underlying concrete value.`}</p>\n    <p><inlineCode parentName=\"p\">{`t := i.(T)`}</inlineCode></p>\n    <p>{`This statement asserts that the interface value `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` holds the concrete type `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` and assigns the underlying `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` value to the variable `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{`.`}</p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` does not hold a `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, the statement will trigger a panic.`}</p>\n    <p>{`To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.`}</p>\n    <p><inlineCode parentName=\"p\">{`t, ok := i.(T)`}</inlineCode></p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` holds a `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, then `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{` will be the underlying value and ok will be true.`}</p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`not, ok`}</inlineCode>{` will be false and `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{` will be the zero value of type `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, and no panic occurs.`}</p>\n    <p>{`Note the similarity between this syntax and that of reading from a map.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = \"hello\"\n\n    s := i.(string)\n    fmt.Println(s)\n\n    s, ok := i.(string)\n    fmt.Println(s, ok)\n\n    f, ok := i.(float64)\n    fmt.Println(f, ok)\n\n    f = i.(float64) // panic\n    fmt.Println(f)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-switches\"\n    }}>{`Type switches`}</h2>\n    <p>{`A type switch is a construct that permits several type assertions in series.`}</p>\n    <p>{`A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`switch v := i.(type) {\ncase T:\n    // here v has type T\ncase S:\n    // here v has type S\ndefault:\n    // no match; here v has the same type as i\n}\n`}</code></pre>\n    <p>{`The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type.`}</p>\n    <p>{`This switch statement tests whether the interface value i holds a value of type T or S. In each of the T and S cases, the variable v will be of type T or S respectively and hold the value held by i. In the default case (where there is no match), the variable v is of the same interface type and value as i.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Twice %v is %v\\\\n\", v, v*2)\n    case string:\n        fmt.Printf(\"%q is %v bytes long\\\\n\", v, len(v))\n    default:\n        fmt.Printf(\"I don't know about type %T!\\\\n\", v)\n    }\n}\n\nfunc main() {\n    do(21)\n    do(\"hello\")\n    do(true)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`Twice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}