{"version":3,"sources":["webpack:///../manual/Programming-Languages/Creating-Your-Own-Language.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---manual-programming-languages-creating-your-own-language-md-c0bdfab4dea9a71378b9.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"creating-your-own-language\"\n    }}>{`Creating Your Own Language`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/stevekinney/dropbear/\"\n        }}>{`Dropbear GitHub language`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"http://static.frontendmasters.com/resources/2019-05-31-build-your-own-programming-language/programming-language.pdf\"\n        }}>{`Slides`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"why-your-own-language\"\n    }}>{`Why your own language?`}</h2>\n    <p>{`There are elements that are super practical for production code.`}</p>\n    <h3 {...{\n      \"id\": \"use-cases\"\n    }}>{`Use Cases`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Domain-Specific Languages: Terraform, Gemfiles`}</li>\n      <li parentName=\"ol\">{`Templating languages: Handlebars, Pug`}</li>\n    </ol>\n    <h3 {...{\n      \"id\": \"usecases-at-sendgrid\"\n    }}>{`Usecases at SendGrid`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Drag + Drop editor takes HTML, parses it into an abstract syntax tree (AST) and manipulates it before serializing it back into HTML.`}</li>\n      <li parentName=\"ul\">{`Using it for own bespoke templating language for dynamic email templates.`}</li>\n      <li parentName=\"ul\">{`Sync position in side-by-side editor by breaking HTML into an AST and rewriting the elements with information about their position in the text editor.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"what-is-a-compiler\"\n    }}>{`What is a compiler?`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Something that turns a higher-level language into a lower-level langauge.`}</p>\n    </blockquote>\n    <p>{`In this particular example, we will follow the course that builds the language `}<inlineCode parentName=\"p\">{`Dropbear`}</inlineCode>{`.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Lisp-like language`}</li>\n      <li parentName=\"ul\">{`Leverage existing JavaScript run-time`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`(add 1 2 (subtract 6 3))\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Source code is meant to be human-readable.`}</p>\n    </blockquote>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The beauty of Scheme is that the full language only needs\n5 keywords and 8 syntactic forms. In comparison, Python\nhas 33 keywords and 110 syntactic forms, and Java has 50\nkeywords and 133 syntactic forms. â€” Peter Norvig.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"inspiration-resources\"\n    }}>{`Inspiration Resources`}</h3>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://norvig.com/lispy.html\"\n        }}>{`https://norvig.com/lispy.html`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://eloquentjavascript.net/12_language.html\"\n        }}>{`https://eloquentjavascript.net/12_language.html`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/jamiebuilds/the-super-tiny-compiler\"\n        }}>{`https://github.com/jamiebuilds/the-super-tiny-compiler`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"stages-of-a-compiler\"\n    }}>{`Stages of a Compiler`}</h2>\n    <ol>\n      <li parentName=\"ol\">{`Parsing: Take source code and turn it into representation of that code.`}</li>\n      <li parentName=\"ol\">{`Transformation: Take source code and transforms it to do whatever the compiler wants it to do.`}</li>\n      <li parentName=\"ol\">{`Generation: Take the transformed representation and turns it into a new string of code.`}</li>\n    </ol>\n    <h2 {...{\n      \"id\": \"parsing\"\n    }}>{`Parsing`}</h2>\n    <p>{`Parsing consists of:`}</p>\n    <ol>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`Lexical analysis`}</inlineCode></li>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`Syntactic analysis`}</inlineCode></li>\n    </ol>\n    <p>{`Note: Lexing = Lexical analysis.`}</p>\n    <p>{`Basically: take big string of code and turn it into `}<inlineCode parentName=\"p\">{`tokens`}</inlineCode>{` where a `}<inlineCode parentName=\"p\">{`token`}</inlineCode>{` is a small unit of the language.`}</p>\n    <p>{`How might a lexer work?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Accept input string of code`}</li>\n      <li parentName=\"ul\">{`Create var for tracking position (like cursor)`}</li>\n      <li parentName=\"ul\">{`Make an array of tokens`}</li>\n      <li parentName=\"ul\">{`Write a while loop that iterates through the source code input`}</li>\n      <li parentName=\"ul\">{`Check each token, see if matches type`}</li>\n      <li parentName=\"ul\">{`Add it to the array of token`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"using-helpers\"\n    }}>{`Using helpers`}</h3>\n    <p>{`This is an example of helpers, but it is worth writing them early and often.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const isWhitespace = character => /\\\\s/.test(character);\nconst isNumber = character => /[0-9]/.test(character);\nconst isOperator = character => /[\\\\+\\\\-\\\\*\\\\/]/.test(character);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"turning-strings-to-tokens\"\n    }}>{`Turning strings to tokens`}</h3>\n    <p>{`Note that based on our syntax, we may need to collect multiple characters into a single token ie `}<inlineCode parentName=\"p\">{`22 + 23`}</inlineCode>{` (which tokenizes as `}<inlineCode parentName=\"p\">{`['2','2','+','2','3']`}</inlineCode>{`)`}</p>\n    <p>{`We write a `}<inlineCode parentName=\"p\">{`tokenize`}</inlineCode>{` function that takes these helpers for us to tokenize the code that we are parsing.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isParenthesis,\n  isQuote,\n} = require('./identify');\n\nconst tokenize = input => {\n  const tokens = [];\n  let cursor = 0;\n\n  while (cursor < input.length) {\n    const character = input[cursor];\n\n    if (isParenthesis(character)) {\n      tokens.push({\n        type: 'Parenthesis',\n        value: character,\n      });\n      cursor++;\n      continue;\n    }\n\n    if (isWhitespace(character)) {\n      cursor++;\n      continue;\n    }\n\n    if (isNumber(character)) {\n      let number = character;\n\n      while (isNumber(input[++cursor])) {\n        number += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Number',\n        value: parseInt(number, 10),\n      });\n\n      continue;\n    }\n\n    if (isLetter(character)) {\n      let symbol = character;\n\n      while (isLetter(input[++cursor])) {\n        symbol += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Name',\n        value: symbol,\n      });\n\n      continue;\n    }\n\n    if (isQuote(character)) {\n      let string = '';\n\n      while (!isQuote(input[++cursor])) {\n        string += input[cursor];\n      }\n\n      tokens.push({\n        type: 'String',\n        value: string,\n      });\n\n      cursor++;\n      continue;\n    }\n\n    throw new Error(\\`\\${character} is not valid\\`);\n  }\n\n  return tokens;\n};\n\nmodule.exports = { tokenize };\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`String traversal and string manipulation in JavaScript is really fast.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"building-an-ast\"\n    }}>{`Building an AST`}</h2>\n    <p>{`How could we build an AST?`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Iterate through the array of tokens.`}</li>\n      <li parentName=\"ol\">{`For each number, string, etc. add that token to same level of the tree.`}</li>\n      <li parentName=\"ol\">{`For each `}<inlineCode parentName=\"li\">{`CallExpression`}</inlineCode>{` (e.g. function) collect the parameters and then recurse down into the function body.`}</li>\n    </ol>\n    <p>{`Babel is kind of the de facto standard for the AST, so it is worth being able to parse our tokens into a format that Babel can handle.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// identify.js\nconst LETTER = /[a-zA-Z]/;\nconst WHITESPACE = /\\\\s+/;\nconst NUMBER = /^[0-9]+$/;\nconst OPERATORS = ['+', '-', '*', '/', '%'];\n\nconst isLetter = character => LETTER.test(character);\n\nconst isWhitespace = character => WHITESPACE.test(character);\n\nconst isNumber = character => NUMBER.test(character);\n\nconst isOpeningParenthesis = character => character === '(';\n\nconst isClosingParenthesis = character => character === ')';\n\nconst isParenthesis = character =>\n  isOpeningParenthesis(character) || isClosingParenthesis(character);\n\nconst isQuote = character => character === '\"';\n\nconst isOperator = character => OPERATORS.includes(character);\n\nmodule.exports = {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isOpeningParenthesis,\n  isClosingParenthesis,\n  isParenthesis,\n  isQuote,\n  isOperator,\n};\n\n// utilities.js\nconst tap = require('lodash/tap');\n\nconst pipe = (...funcs) => value =>\n  funcs.reduce((value, func) => func(value), value);\n\nconst log = value => tap(value, console.log);\n\nconst peek = array => array[0];\nconst pop = array => array.shift();\n\nmodule.exports = {\n  pipe,\n  log,\n  peek,\n  pop,\n  tap,\n};\n\n// parse.js\nconst { isOpeningParenthesis, isClosingParenthesis } = require('./identify');\nconst { specialForms } = require('./special-forms');\nconst { peek, pop } = require('./utilities');\n\nconst parenthesize = tokens => {\n  const token = pop(tokens);\n\n  if (isOpeningParenthesis(token.value)) {\n    const expression = [];\n\n    while (!isClosingParenthesis(peek(tokens).value)) {\n      expression.push(parenthesize(tokens));\n    }\n\n    pop(tokens);\n    return expression;\n  }\n\n  return token;\n};\n\nconst parse = tokens => {\n  if (Array.isArray(tokens)) {\n    const [first, ...rest] = tokens;\n    return {\n      type: 'CallExpression',\n      name: first.value,\n      arguments: rest.map(parse),\n    };\n  }\n\n  const token = tokens;\n\n  if (token.type === 'Number') {\n    return {\n      type: 'NumericLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'String') {\n    return {\n      type: 'StringLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'Name') {\n    return {\n      type: 'Identifier',\n      name: token.value,\n    };\n  }\n};\n\nmodule.exports = { parse: tokens => parse(parenthesize(tokens)) };\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"repl\"\n    }}>{`REPL`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Read-Evaluation-Print-Loop`}</p>\n    </blockquote>\n    <p>{`We are going to build a REPL + CLI tool that you could expand.`}</p>\n    <p>{`Notes for this REPL:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`We're been using functions like add and subtract, but what do\nthose mean?`}</li>\n      <li parentName=\"ol\">{`Above and beyond having a syntax, most languages have some\namount of a standard library of built-in functions, objects, and\nmethods.`}</li>\n      <li parentName=\"ol\">{`Weâ€™re leveraging JavaScriptâ€™s built-in numbers and arrays, but\nweâ€™re going to need some functions too.`}</li>\n    </ol>\n    <p>{`Since JavaScript is our compile target, weâ€™ll implement our\nbuilt-in functions as JavaScript functions.`}</p>\n    <p>{`We will add what we need to our `}<inlineCode parentName=\"p\">{`standard-library.js`}</inlineCode>{` code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const all = fn => (...list) => list.reduce(fn);\n\nconst add = all((a, b) => a + b);\nconst subtract = all((a, b) => a - b);\nconst multiply = all((a, b) => a * b);\nconst divide = all((a, b) => a / b);\nconst modulo = all((a, b) => a % b);\nconst log = console.log;\n\nconst environment = {\n  add,\n  subtract,\n  multiply,\n  divide,\n  modulo,\n  log,\n  pi: Math.PI,\n  max(...args) {\n    return Math.max(...args);\n  },\n};\n\nmodule.exports = { environment };\n`}</code></pre>\n    <p>{`Then for the REPL `}<inlineCode parentName=\"p\">{`evaluate.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const { environment } = require('./standard-library');\nconst last = collection => collection[collection.length - 1];\n\nconst apply = node => {\n  const fn = environment[node.name];\n  const args = node.arguments.map(evaluate);\n  if (typeof fn !== 'function') {\n    throw new TypeError(\\`\\${node.name} is not a function\\`);\n  }\n  return fn(...args);\n};\n\nconst getIdentifier = node => {\n  if (environment[node.name]) return environment[node.name];\n  throw new ReferenceError(\\`\\${node.name} is not defined\\`);\n};\n\nconst define = node => {\n  environment[node.identifier.name] = node.assignment.value;\n};\n\nconst evaluate = node => {\n  if (node.type === 'VariableDeclaration') return define(node);\n  if (node.type === 'CallExpression') return apply(node);\n  if (node.type === 'Identifier') return getIdentifier(node);\n  if (node.value) return node.value;\n};\n\nmodule.exports = { evaluate };\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"building-the-repl\"\n    }}>{`Building the REPL`}</h3>\n    <p>{`We can create a`}<inlineCode parentName=\"p\">{`repl.js`}</inlineCode>{` file to help run a REPL:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const { prompt } = require('inquirer');\nconst chalk = require('chalk');\n\nconst { parseAndEvaluate } = require('./parse-and-evaluate');\n\nconst askQuestions = () => {\n  const questions = [\n    { name: 'COMMAND', type: 'input', message: chalk.blue('>') },\n  ];\n\n  return prompt(questions);\n};\n\nconst repl = async () => {\n  try {\n    const answers = await askQuestions();\n    const { COMMAND } = answers;\n\n    if (COMMAND.trim()) {\n      console.log(chalk.yellow(parseAndEvaluate(COMMAND)));\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  repl();\n};\n\nif (require.main === module) {\n  console.log(\n    chalk.red(\n      \\`Welcome to the \\${chalk.bgYellow('Dropbear')} Programming Language\\`,\n    ),\n  );\n  repl();\n}\n\nmodule.exports = repl;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"generation\"\n    }}>{`Generation`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Parsing, in reverse.`}</p>\n    </blockquote>\n    <p>{`For generation, you have a few options:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Write your own low-level CPU-instruction compiler (probably a bad idea).`}</li>\n      <li parentName=\"ol\">{`Use a compiler framework like LLVM (Rust, Swift, Objective-C).`}</li>\n      <li parentName=\"ol\">{`Target the JVM.`}</li>\n      <li parentName=\"ol\">{`Transpile to another language.`}</li>\n    </ol>\n    <p>{`If you can get yourself to a Babel-compliant AST, then you can use another tool off the shelf like Babel generator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import generate from '@babel/generator';\n\ngenerate(ast, options, code);\n`}</code></pre>\n    <p>{`We need to transform a AST that you currently have to one that Babel can understand.`}</p>\n    <h3 {...{\n      \"id\": \"visitor-pattern\"\n    }}>{`Visitor Pattern`}</h3>\n    <p>{`Basically a depth-first search through the tree. The Visitor Pattern allows us define different types of actions for each node visited as it walks the tree.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import traverse from '@babel/traverse';\n\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type === 'VariableDeclaration' && path.node.kind === 'var') {\n      path.node.kind = 'let';\n    }\n  },\n});\n`}</code></pre>\n    <p>{`The traversal implementation that we put into the app:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const traverseNode = ({ node, parent, visitor }) => {\n  const methods = visitor[node.type];\n\n  if (methods && methods.enter) {\n    methods.enter({ node, parent });\n  }\n\n  if (node.arguments) {\n    traverseArray({ array: node.arguments, parent: node, visitor });\n  }\n\n  if (methods && methods.exit) {\n    methods.exit({ node, parent });\n  }\n};\n\nconst traverseArray = ({ array, parent, visitor }) => {\n  array.forEach(node => {\n    traverseNode({ node, parent, visitor });\n  });\n};\n\nconst traverse = (node, visitor) => {\n  traverseNode({ node, visitor });\n};\n\nmodule.exports = { traverse };\n\n// during visitor implementation\n// const visitor = {\n//   VariableDeclaration: {\n//     enter({ node, parent }) {},\n//     exit() {}\n//   }\n// }\n`}</code></pre>\n    <p>{`This is how we can implement this into JS:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const generate = require('@babel/generator').default;\nconst { traverse } = require('./traverse');\n\nconst babelVisitor = {\n  CallExpression: {\n    enter({ node }) {\n      node.callee = { type: 'Identifier', name: node.name };\n    },\n  },\n  VariableDeclaration: {\n    enter({ node }) {\n      node.kind = 'let';\n      node.declarations = [\n        {\n          type: 'VariableDeclarator',\n          id: node.identifier,\n          init: node.assignment,\n        },\n      ];\n    },\n  },\n};\n\nconst toJavaScript = ast => {\n  traverse(ast, babelVisitor);\n  return generate(ast).code;\n};\n\nmodule.exports = {\n  toJavaScript,\n};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bonus-terms\"\n    }}>{`Bonus Terms`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Homoiconicity: A language that can modify its own underlying data structure.`}</li>\n      <li parentName=\"ul\">{`Self-Hosting: The language is written in the language itself.`}</li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}