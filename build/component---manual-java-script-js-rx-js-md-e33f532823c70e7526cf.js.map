{"version":3,"sources":["webpack:///../manual/JavaScript/JS-RxJS.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---manual-java-script-js-rx-js-md-e33f532823c70e7526cf.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"rxjs\"\n    }}>{`RxJS`}</h1>\n    {\n      /* TOC -->autoauto- [RxJS](#rxjs)auto    - [1.0 A Brief Recap of Programming Paradigms](#10-a-brief-recap-of-programming-paradigms)auto        - [Procedural Program](#procedural-program)auto        - [Object Oriented](#object-oriented)auto        - [Declarative](#declarative)auto    - [1.1: Core Reactive Concepts](#11-core-reactive-concepts)auto    - [1.2: Comparing the Autocomplete function using JS vs RxJS](#12-comparing-the-autocomplete-function-using-js-vs-rxjs)auto    - [3: The Core of Reactive Extensions](#3-the-core-of-reactive-extensions)auto    - [3.1: Obervables, Operators and Subscriptions](#31-obervables-operators-and-subscriptions)auto    - [3.2 Creating Observables](#32-creating-observables)auto    - [3.3: Built in Observables](#33-built-in-observables)auto    - [3.4: Using RxJS with Node, jQuery and Promises](#34-using-rxjs-with-node-jquery-and-promises)auto    - [3.5: Subjects](#35-subjects)auto    - [3.6: RxJS Resources and Documentation](#36-rxjs-resources-and-documentation)auto    - [3.7: Sharing Observable Sequences](#37-sharing-observable-sequences)auto    - [4.0: Operators that everyone should know](#40-operators-that-everyone-should-know)auto    - [4.1: Do / Finally / StartWith / Filter](#41-do--finally--startwith--filter)auto    - [4.2: Merge / Concat](#42-merge--concat)auto    - [4.3: Map / MergeMap / SwitchMap](#43-map--mergemap--switchmap)auto    - [4.4: Reduce / Scan](#44-reduce--scan)auto    - [4.5: Buffer / ToArray](#45-buffer--toarray)auto    - [4.6: First / Last / Single / Skip / Take](#46-first--last--single--skip--take)auto    - [4.7: Zip / WithLatestFrom / CombineLatest](#47-zip--withlatestfrom--combinelatest)auto    - [4.8: Error Handling Catch and Retry](#48-error-handling-catch-and-retry)autoauto<!-- /TOC */\n    }\n    <h2 {...{\n      \"id\": \"10-a-brief-recap-of-programming-paradigms\"\n    }}>{`1.0 A Brief Recap of Programming Paradigms`}</h2>\n    <h3 {...{\n      \"id\": \"procedural-program\"\n    }}>{`Procedural Program`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`The ideas that programs are a sense of functions`}</li>\n      <li parentName=\"ul\">{`Goes from top to bottom`}</li>\n      <li parentName=\"ul\">{`Relies heavily on global state, but any line can change the global state`}</li>\n      <li parentName=\"ul\">{`C being a procedural language`}</li>\n      <li parentName=\"ul\">{`\"Imperative\" execution`}</li>\n      <li parentName=\"ul\">{`Easy to write, difficult to maintain`}</li>\n      <li parentName=\"ul\">{`Prone to difficult bugs`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"object-oriented\"\n    }}>{`Object Oriented`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Based around a Primitive: object`}</li>\n      <li parentName=\"ul\">{`Objects have well defined interfaces`}</li>\n      <li parentName=\"ul\">{`Localised behaviour`}</li>\n      <li parentName=\"ul\">{`Objects control state`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Code is still imperative - pro AND con! - Still telling the computer EXACTLY what to do.`}</li>\n      <li parentName=\"ul\">{`Can be more verbose`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"declarative\"\n    }}>{`Declarative`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Describing what you want to happen, but not telling the computer how to do it`}</li>\n      <li parentName=\"ul\">{`Eg. SQL, Regex, HTML`}</li>\n      <li parentName=\"ul\">{`Data is self-describing`}</li>\n      <li parentName=\"ul\">{`As powerful as the interpreter allows`}</li>\n      <li parentName=\"ul\">{`As limiting as the interpreter allows - You want build a game in SQL etc.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"functional\"\n    }}>{`Functional`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`What we want to happen but not how`}</li>\n      <li parentName=\"ul\">{`Little state`}</li>\n      <li parentName=\"ul\">{`Few side effects`}</li>\n      <li parentName=\"ul\">{`Easy to reason about`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Expressive`}</li>\n      <li parentName=\"ul\">{`Works great with OO`}</li>\n      <li parentName=\"ul\">{`Basis in higher math`}</li>\n      <li parentName=\"ul\">{`Cons to think differently`}</li>\n      <li parentName=\"ul\">{`Not always the best choice`}</li>\n      <li parentName=\"ul\">{`No loops, no control logic - Just telling it what we want to happen`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"reactive\"\n    }}>{`Reactive`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Primitive: Observable`}</li>\n      <li parentName=\"ul\">{`Instead of describing data in terms of other data, we describe it in terms of streams of events - From this, we create a pipeline such that we certain data changes, a lot is processed and changed - Example: spreadsheets!`}</li>\n      <li parentName=\"ul\">{`Composition`}</li>\n      <li parentName=\"ul\">{`Expressive`}</li>\n      <li parentName=\"ul\">{`Data flows unidirectionally`}</li>\n      <li parentName=\"ul\">{`Tough to think differently`}</li>\n      <li parentName=\"ul\">{`Subscriptions help change the data`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const cellC2$ = cellA2$\n  .combineLatest(cellB2$)\n  .map((cells) => cells[0] + cells[1]);\n\ncellC2$.subscribe((value) => {\n  console.log(value);\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"11-core-reactive-concepts\"\n    }}>{`1.1: Core Reactive Concepts`}</h2>\n    <p><strong parentName=\"p\">{`Core Concept 1: Pull model vs Push model`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`any data sitting there that you \"ask\" for at some point - example refresh button - manual button trigger - time interval`}</li>\n      <li parentName=\"ul\">{`observable (stream) which is a reactive data source - produces items over a period of time that will either error, complete, or never complete until a page closes - not telling the stream when to get data, it has inbuilt logic on how to get data - we may transform this data - the display of the data is actually part of the description`}</li>\n    </ul>\n    <p>{`An an example for a `}<inlineCode parentName=\"p\">{`pull`}</inlineCode>{` based code, we can think of a window.setInterval() that fires every 5000 seconds.`}</p>\n    <p>{`An example of a push would be to have a function fire and then the return continutes to filter, flatMap, map and subscribe.`}</p>\n    <p><strong parentName=\"p\">{`Core Concept 2: Everything is a database`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`mouse movements`}</li>\n      <li parentName=\"ul\">{`current user`}</li>\n      <li parentName=\"ul\">{`web requests`}</li>\n      <li parentName=\"ul\">{`input boxes`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"12-comparing-the-autocomplete-function-using-js-vs-rxjs\"\n    }}>{`1.2: Comparing the Autocomplete function using JS vs RxJS`}</h2>\n    <p>{`In the comparison where the `}<inlineCode parentName=\"p\">{`$title.on('keyup', () => {})`}</inlineCode>{` runs with a promise returned. The query can run into race conditions.`}</p>\n    <p>{`Also note that every single result also fires.`}</p>\n    <p>{`The issues:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`// Fix up and down arrow\n// Stop always querying\n// Getting race condition\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Bad ways`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`generally `}<inlineCode parentName=\"li\">{`if last query == currentTitle return`}</inlineCode></li>\n      <li parentName=\"ul\">{`using setTimeout to reduce number of queries`}</li>\n      <li parentName=\"ul\">{`Race condition still happening, but bad attempts may be increasing the timeout - Could also use a current id compared to next query id and then returning before the callback occurs`}</li>\n      <li parentName=\"ul\">{`A lot of state across the module being changed`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`The Rx way`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// npm install rxjs-es for es6\nimport $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nconst keyUps$ = Rx.Observable.fromEvent($title, \"keyup\");\nconst queries$ = keyUps$\n    .map(e => e.target.value)\n    .distinctUntilChanged()\n    .debounceTime(250)\n    .switchMap(getItems);   // similar to merge, but if new query comes in, discard the old data\n    //.mergeMap(getItems);  // alias for flatMap\n\nqueries$.subscribe(query => {\n    // get rid of the promise will stop race condition\n    $results.empty();\n    $results.append(items.map( r => $(\\`<li />\\`).text(r)));\n})\n\n<!-- queries$.subscribe(query => {\n    console.log(e); // prints out event\n    getItems(query)\n        .then(items => {\n            $results.empty();\n            $results.append(items.map( r => $(\\`<li />\\`).text(r)));\n        });\n}) -->\n`}</code></pre>\n    <p>{`An even better way.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import $ from 'jquery';\nimport Rx from 'rxjs/Rx';\n\nconst $title = $('#title');\nconst $results = $('#results');\n\nRx.Observable.fromEvent($title, 'keyup')\n  .map((e) => e.target.value)\n  .distinctUntilChanged()\n  .debounceTime(500)\n  .switchMap(getItems)\n  .subscribe((items) => {\n    $results.empty();\n    $results.append(items.map((r) => $(\\`<li />\\`).text(r)));\n  });\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`All the Rx has no external state, whereas the other code does.`}</li>\n      <li parentName=\"ul\">{`Rx doesn't have to wait for us to tell it when to do it.`}</li>\n    </ul>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"3-the-core-of-reactive-extensions\"\n    }}>{`3: The Core of Reactive Extensions`}</h2>\n    <h2 {...{\n      \"id\": \"31-obervables-operators-and-subscriptions\"\n    }}>{`3.1: Obervables, Operators and Subscriptions`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Observable: Something that can be observed which produces values`}</li>\n      <li parentName=\"ul\">{`Operator: It's an operation that modifies the data being pushed in from the observable - They don't produce values in and of themselves, but move them through the pipeline.`}</li>\n      <li parentName=\"ul\">{`Subscriptions: Piece of code that will do something with the values returned by the operators`}</li>\n    </ul>\n    <p>{`Note, you can model anything in a reactive context by thinking a little bit differently.`}</p>\n    <p><strong parentName=\"p\">{`Web API Request Example`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`Reactive can still complete, or it can error out and retry.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"32-creating-observables\"\n    }}>{`3.2 Creating Observables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Rx from 'rxjs/Rx';\n\n# promise will always execute - not lazy\nconst promise = new Promise((resolve, reject) => {\n    console.log(\"In promise\");\n    resolve(\"hey\");\n});\n\npromise.then(item => console.log(item));\n\n# this doesn't give any output!\n# observables are lazy!\n# won't run without a subscription\nconst simple$ = new Rx.Observable(observer => {\n    console.log(\"Generating observable\");\n    setTimeout(() => {\n        observer.next(\"An items!\");\n        setTimeout(() => {\n            observer.next(\"Another item!\");\n            observer.complete();\n        }, 1000);\n    }, 1000);\n});\n\n# creating a subscription\n# first arg is the next function\n# second arg is error\n# third arg is complete\nsimple$.subscribe(\n    item => console.log(\\`one.next \\${item}\\`),\n    error => console.log(\\`one.error \\${item}\\`),\n    () => console.log(\"one.complete\")\n);\n\n# Generating observable\n# one.next An item!\n# one.next Another item!\n# one.complete\n\nsetTimeout(() => {\n    simple$.subscribe({\n        next: item => console.log(\\`two.next \\${item}\\`),\n        error: error => console.log(\\`two.error \\${item}\\`),\n        complete: () => console.log(\"two.complete\")\n    });\n}, 3000)\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\">{`Re-subscribing to an observable allows you to run that generator again`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`function createInterval(time) {\n    return new Rx.Observable(observer => {\n        let index = 0;\n        let interval = setInterval(() => {\n            observer.next(index++);\n        }, time);\n\n        return () => {\n            // will run when we unsubscribe\n            clearnInterval(interval);\n        };\n    });\n}\n\nfunction createSubscriber(tag) {\n    return {\n        next(item) { console.log(\\`\\${tag}.next \\${item}\\`); },\n        error(error) { console.log(\\`\\${tag}.error \\${error.stack || error }\\`); },\n        complete() { console.log(\\`\\${tag}.complete\\`); }\n    };\n}\n\nfunction take(observable, amount) {\n    return new Rx.Observable(observer => {\n\n    });\n}\n\n// this is the core of subscriptions\nfunction take(sourceObservable, amount) {\n    return new Rx.Observable(observer => {\n        let count = 0;\n        const subscription = sourceObservable.subscribe({\n            next(item) {\n                observer.next(item);\n                if (++count >= amount) {\n                    observer.complete();\n                }\n            },\n            error(error) { observer.error(error); },\n            complete() { observer.complete(); }\n        });\n\n        return () => subscription.unsubscribe();\n    });\n}\n\nconst everySecond_ = createInterval(1000);\nconst firstFiveSeconds = take(everySecond_, 5);\nconst subscription = everySecond_.subscribe(createSubscriber(\"one\"));\nsetTimeout(() => {\n    subscription.unsubscribe();\n}, 3500);\n`}</code></pre>\n    <p>{`This subscription will console.log out forever and ever and ever... - unless, we dispose of a description`}</p>\n    <p>{`How do operators come into play?`}</p>\n    <p>{`We could run something like `}<inlineCode parentName=\"p\">{`const subscription = everySecond_.take(3)subscribe(createSubscriber(\"one\"));`}</inlineCode></p>\n    <p>{`The steps for it are that it listens for a source and emits a transformation!`}</p>\n    <h2 {...{\n      \"id\": \"33-built-in-observables\"\n    }}>{`3.3: Built in Observables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Rx from 'rxjs/Rx';\n\n\nRx.Observable.interval(500)\n    .take(5)\n    .subscribe(createSubscriber(\"interval\"));\n\nRx.Observable.timer(1000, 500)\n    .take(3)\n    .subscribe(createSubscriber(\"timer\");\n\n// note, array doesn't work - use from\nRx.Observable.of(\"Hello world!\", 42, \"whoa\")\n    .subscribe(createSubscriber(\"of\"));\n\nRx.Observable.from([\"Hello world!\", 42, \"whoa\"])\n    .subscribe(createSubscriber(\"of\"));\n\nRx.Observable.from(generate())\n    .subscribe(createSubscriber(\"of\"));\n\n\nRx.Observable.from(\"hello world!\")\n    .subscribe(createSubscriber(\"of\"));\n\n// it can also take in a generator function!\n\nfunction* generate() {\n    yield 1;\n    yield 5;\n    yield \"HEY\";\n}\n\nRx.Observable.throw(new Error(\"Hey\"))\n    .subscribe(createSubscriber(\"error\"));\n\n// empty\nRx.Observable.empty()\n    .subscribe(createSubscriber(\"empty\"));\n\n// defer\nlet sideEffect = 0;\nconst defer = Rx.Observable.defer(() => {\n    sideEffect++;\n    return Rx.Obserable.of(sideEffect);\n});\n\ndefer.subscribe(createSubscriber(\"defer.one\"));\ndefer.subscribe(createSubscriber(\"defer.two\"));\ndefer.subscribe(createSubscriber(\"defer.three\"));\n\nRx.Observable.never()\n    .subscribe(createSubscriber(\"never\"));\n\nRx.Observable.range(10, 30)\n    .subscribe(createSubscriber(\"range\"));\n`}</code></pre>\n    <p>{`Benefits of the iterable `}<inlineCode parentName=\"p\">{`from`}</inlineCode>{`?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`For every iterable, we could map every element.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"34-using-rxjs-with-node-jquery-and-promises\"\n    }}>{`3.4: Using RxJS with Node, jQuery and Promises`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`Rx.Observable.fromEvent($title, 'keyup')\n  .map((e) => e.target.value)\n  .distinctUntilChanged()\n  .debounceTime(500)\n  .switchMap(getItems)\n  .subscribe((items) => {\n    $results.empty();\n    $results.append(items.map((i) => $('<li />').text(i)));\n  });\n`}</code></pre>\n    <p>{`NOTE: Without the subscribe, it will never be subscribed to the dom!`}</p>\n    <p>{`If we have the `}<inlineCode parentName=\"p\">{`.take(10)`}</inlineCode>{` - it would complete after taking 10 and then furthermore unsubscribe and be great for performance!`}</p>\n    <p><inlineCode parentName=\"p\">{`fromEvent`}</inlineCode>{` calls from `}<inlineCode parentName=\"p\">{`addEventListener`}</inlineCode>{`, so it can do powerful things like `}<inlineCode parentName=\"p\">{`keyup`}</inlineCode>{` for those that don't initially support it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import fs from 'fs';\n\nfs.readdir('./src/server', (err, items) => {\n  if (err) console.log(err);\n  else {\n    console.log(items);\n  }\n});\n\n// alternative\nconst readdir = Rx.Observable.bindNodeCallBack(fs.readdir);\n\nreaddir('./src/server')\n  // mergeMap creates iterable converted from array\n  .mergeMap((files) => Rx.Observable.from(files))\n  .map((file) => \\`MANIPULATED \\${file}\\`)\n  .subscribe(createSubscriber('readdir'));\n\n// promises\n\nfunction getItem() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('Hello');\n    }, 1000);\n  });\n}\n\nRx.Observable.fromPromise(getItem()).subscribe(createSubscriber('promise'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"35-subjects\"\n    }}>{`3.5: Subjects`}</h2>\n    <p>{`Subjects are another Rx primitive. They are both an observable and a observer! Used to bridge non-reactive code with reactive code.`}</p>\n    <p>{`Behaviour, replay subjects etc.`}</p>\n    <p><em parentName=\"p\">{`Warning`}</em>{`: you should only really consider them as a last resort when bridging non-reactive and reactive code.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const simple = new Rx.Subject();\n\nsimple.subscribe(createSubscriber('simple'));\n\nsimple.next('Hello');\nsimple.next('World');\nsimple.complete();\n\nconst interval = Rx.Observable.interval(1000).take(5);\nconst intervalSubject = new Rx.Subject();\nintervalSubject.subscribe(interval);\n\nintervalSubject.subscribe(createSubscriber('sub1'));\nintervalSubject.subscribe(createSubscriber('sub2'));\nintervalSubject.subscribe(createSubscriber('sub3'));\n\n// subscribes after three seconds\nsetTimeout(() => {\n  intervalSubject.subscribe(createSubscriber('LOOK AT ME'));\n}, 3000);\n`}</code></pre>\n    <p>{`Before, we had to invoke a function that call `}<inlineCode parentName=\"p\">{`next`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`complete`}</inlineCode>{`.`}</p>\n    <p>{`In the above example, intervalSubject is acting as a proxy to another observable.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// needs init state parameter\nconst currentUser = new Rx.BehaviorSubject({ isLoggedIn: false });\nconst isLoggedIn = currentUser.map((u) => u.isLoggedIn);\n\ncurrentUser.next({ isLoggedIn: false });\nisLoggedIn.subscribe(createSubscriber('isLoggedIn'));\n\nsetTimeout(() => {\n  currentUser.next({ isLoggedIn: true, name: 'nelson' });\n}, 3000);\n\nsetTimeout(() => {\n  isLogged.subscribe(createSubscription('delayed'));\n}, 1500);\n`}</code></pre>\n    <p>{`How do you remember multiple states?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const replay = new Rx.ReplaySubject(3);\nreplay.next(1);\nreplay.next(2);\n\nreplay.subscribe(createSubscriber(\"one\"));\n\nreplay.next(3);\nreplay.next(4);\nreplay.next(5);\n\n// this subscription only gets the previous three items\nreplay.subscribe(createSubscriber(\"two\"));\n\nreplay.next(6);\n\n// what you see\none.next 1\none.next 2\none.next 3\none.next 4\none.next 5\ntwo.next 3\ntwo.next 4\ntwo.next 5\none.next 6\ntwo.next 6\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Async Subjects`}</strong></p>\n    <pre><code parentName=\"pre\" {...{}}>{`const apiCall = new Rx.AsyncSubject();\napiCall.next(1);\n\napiCall.subscribe(createSubscriber(\"one\"));\napiCall.next(2);\n\n// only will emit the final item before it is complete\napiCall.complete();\n\n// if you subscribe to it again, that final value will be emitted\nsetTimeout(() => {\n    apiCall.subscribe(createSubscriber(\"two\"));\n}, 2000);\n\n// output\none.next 2\none.complete\ntwo.next 2\ntwo.complete\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Subject Summary`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`if you can get around it, don't use subjects unless you have to`}</li>\n      <li parentName=\"ul\">{`you should use an observable workflow where possible`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"36-rxjs-resources-and-documentation\"\n    }}>{`3.6: RxJS Resources and Documentation`}</h2>\n    <p>{`Sources:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/ReactiveX/rxjs\"\n        }}>{`RxJS Github`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"http://rxmarbles.com/\"\n        }}>{`RxMarbles`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"http://jaredforsyth.com/rxvision/examples/playground/\"\n        }}>{`RxVision Playground`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"37-sharing-observable-sequences\"\n    }}>{`3.7: Sharing Observable Sequences`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Hot Observable: It will produce events regardless of if you're listening - eg.`}<inlineCode parentName=\"li\">{`fromEvent($title, 'keyup')`}</inlineCode></li>\n      <li parentName=\"ul\">{`Cold Obserable: Starts once you subscribe - Interval Observables are actually cold observables`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// this example shows when both start from the beginning eg cold\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000).take(10);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// HOT\n// connectable observable\nimport Rx from 'rxjs/Rx';\n\nconst interval = Rx.Observable.interval(1000)\n  .take(10)\n  .publish();\n\ninterval.connect();\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('one'));\n}, 1200);\n\nsetTimeout(() => {\n  interval.subscribe(createSubscriber('two'));\n}, 3200);\n\n// if you connect after a set interval, then it begins executing and sharing the underlying observable\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Why would you want a hot variable?`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// here subscribe console.log runs twice\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n  console.log('subscribed');\n  socket.on('chat:message', (message) => observer.next(message));\n});\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// without it\n\nconst socket = { on: () => {} };\nconst chatMessage = new Rx.Observable((observable) => {\n  console.log('subscribed');\n  socket.on('chat:message', (message) => observer.next(message));\n}).publish();\n\nchatMessage.connect();\n\nchatMessage.subscribe(createSubscriber('one'));\nchatMessage.subscribe(createSubscriber('two'));\n\n// using publishLast()\nconst simple = new Rx.Observable((observer) => {\n  observer.next('one');\n  observer.next('two');\n  observer.complete();\n});\n\n// always returns the last value\nconst published = simple.publishLast();\n\n// even if we subscribe before connect, both will get the last value\npublished.subscribe(createSubscriber('one'));\npublished.connect();\npublished.subscribe(creaSubscriber('two'));\n\n// using publishReplay()\nconst simple = new Rx.Observable((observer) => {\n  observer.next('one');\n  observer.next('two');\n  observer.next('three');\n\n  return () => console.log('Disposed');\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2);\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber('one'));\nconst connection = published.connect();\nconst sub2 = published.subscribe(creaSubscriber('two'));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n\nconnection.unsubscribe();\n`}</code></pre>\n    <p>{`Refcount is a way to automatically handle the connection and the unsubscription of a connection observable.`}</p>\n    <p>{`It will connect to the first subscription and then disconnected on the last unsubscribe.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`// using refCount()\nconst simple = new Rx.Observable(observer => {\n    observer.next(\"one\");\n    observer.next(\"two\");\n    observer.next(\"three\");\n\n    return () => console.log(\"Disposed\");\n});\n\n// always returns the last value\nconst published = simple.publishReplay(2).refCount();\n\n// even if we subscribe before connect, both will get the last value\n// to dispose without running complete, we need to disconnect by unsubscribing\nconst sub1 = published.subscribe(createSubscriber(\"one\"));\nconst sub2 = published.subscribe(creaSubscriber(\"two\"));\n\nsub1.unsubscribe();\nsub2.unsubscribe();\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`publish().refCount()`}</inlineCode>{` is done so often, that is has been turned in `}<inlineCode parentName=\"p\">{`share()`}</inlineCode>{`.`}</p>\n    <p>{`Taxing processes that you don't want to repeat but you want multiple things to hook into the result, then turn it into a hot subscription.`}</p>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"40-operators-that-everyone-should-know\"\n    }}>{`4.0: Operators that everyone should know`}</h2>\n    <p>{`Now we will just talk about the different primary operators that you will work with.`}</p>\n    <h2 {...{\n      \"id\": \"41-do--finally--startwith--filter\"\n    }}>{`4.1: Do / Finally / StartWith / Filter`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// do => get the next value and pass it back unchanged\n// finally => only completes after the range has completed, runs right at the end of the final value\n// filter => filters out given statement\n// interval => call timeout\n// startWith => set initial value\n\nRx.Observable.range(1, 10)\n  .do((a) => console.log(\\`From do \\${a}\\`))\n  .map((a) => a * a)\n  .subscribe(createSubscriber('simple'));\n\nRx.Observable.range(1, 10)\n  .finally(() => console.log(\\`From finally\\`))\n  .map((a) => a * 2)\n  .subscribe(createSubscriber('finally'));\n\nRx.Observable.range(1, 10)\n  .filter((a) => a < 5)\n  .map((a) => a * 2)\n  .subscribe(createSubscriber('filter'));\n\nRx.Observable.interval(1000)\n  .startWith(-1)\n  .subscribe(createSubscriber('interval'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"42-merge--concat\"\n    }}>{`4.2: Merge / Concat`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// merge - merge many observables togethers\n// concat - this concatenates observables to the end of another, can also take a list of Observables\n\nRx.Observable.interval(1000)\n    .merge(Rx.Observable.interval(500))\n    .take(5)\n    .subscribe(createSubscriber(\"merge1\"));\n\nRx.Observable.merge(\n    Rx.Observable.interval(1000).map(i => \\`\\${i} seconds),\n    Rx.Observable.interval(500).map(i => \\`\\${i} half seconds))\n    .take(5)\n    .subscribe(createSubscriber('merge2'));\n\n// different events for merged observables\nRx.Observable.merge(\n    socket.on$(\"login\").map(user => processUser(user),\n    socket.on$(\"logout\").map(() => null));\n\nRx.Observable.range(1, 5)\n    .concat(Rx.Observable.range(10,3))\n    .subscribe(createSubscriber(\"concat1\"));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"43-map--mergemap--switchmap\"\n    }}>{`4.3: Map / MergeMap / SwitchMap`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// map - a projection on every item that comes in\n// mergeMap - select many, does projection and then has another thing that we will work on\n// switchMap - similar to mergeMap but replaces with the latest value if another emission comes in\n\nfunction arrayMap(arr, proj) {\n  let returnArray = [];\n  for (let i of arr) {\n    returnArray.push(proj(item));\n  }\n\n  return returnArray;\n}\n\narrayMap([1, 2, 3], (a) => a * a);\n\n// imagine array of dicts\nconst albums = [{}, {}];\n\nfunction arrayMergeMap(arr, proj) {\n  let returnArray = [];\n  for (let i of arr) {\n    let projArray = proj(item);\n    for (let j of projArray) {\n      returnArray.push(proj(item));\n    }\n  }\n\n  return returnArray;\n}\n\nconst tracks = arrayMergeMap(albums, (album) => album.tracks);\n\nRx.Observable.range(1, 3)\n  .mergeMap((i) =>\n    Rx.Observable.timer(i * 1000).map(() => \\`After \\${i} seconds\\`)\n  )\n  .subscribe(createSubscriber('mergeMap'));\n\nRx.Observable.fromPromise(getTracks())\n  .mergeMap((tracks) => Rx.Observable.from(tracks))\n  .subscribe(createSubscriber('tracks'));\n\nfunction getTracks() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(['track 1', 'track 2', 'track 3']);\n    }, 1000);\n  });\n}\n\n// synchronous example\nRx.Observable.of('my query')\n  .do(() => console.log('Querying'))\n  .mergeMap((a) => query(a))\n  .do(() => console.log('After querying'))\n  .subscribe(createSubscriber('query'));\n\nfunction query(value) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('This is the resolved value');\n    }, 1000);\n  });\n}\n\n// switch map\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"44-reduce--scan\"\n    }}>{`4.4: Reduce / Scan`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// reducer (acc, value) and works on value - doesn't emit until the completion\n// scan - processes and emits as it comes in\nRx.Observable.range(1, 10)\n  .reduce((acc, value) => acc + value)\n  .subscribe(createSubscriber('reduce'));\n\nRx.Observable.range(1, 10)\n  .scan((acc, value) => acc + value)\n  .subscribe(createSubscriber('scan'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"45-buffer--toarray\"\n    }}>{`4.5: Buffer / ToArray`}</h2>\n    <p>{`There have been some big changes to how `}<inlineCode parentName=\"p\">{`buffer`}</inlineCode>{` has been used.`}</p>\n    <p>{`Buffer takes in an observable.`}</p>\n    <p>{`toArray will convert results into an array. - still has a clean exit if the never() is implemented!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`Rx.Observable.range(1, 100)\n    .bufferCount(25)\n    .subscribe(createSubscriber(\"items\");\n\n// will take 25 items and pushing them into an array\n\n\nRx.Observable.interval(500)\n    .bufferTime(2000)\n    .subscribe(createSubscriber(\"bufferTime\");\n\n// same behaviour!\n// emitting event causes buffer to flush\nRx.Observable.interval(500)\n    .buffer(Rx.Observable.interval(2000))\n    .subscribe(createSubscriber(\"buffer\");\n\n//\n// toArray\n//\n\nRx.Observable.range(1, 10)\n    .toArray()\n    .subscribe(createSubscriber(\"range\"));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"46-first--last--single--skip--take\"\n    }}>{`4.6: First / Last / Single / Skip / Take`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const simple = new Rx.Observable((observer) => {\n  console.log('Generating sequence');\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.next(4);\n  observer.complete();\n});\n\nsimple.first().subscribe(createSubscriber('first'));\n\nsimple.last().subscribe(createSubscriber('last'));\n\n// displays 1 & 4\n// if nothing is in there, there are EmptyError(s) thrown\n\n// single.error thrown is more than one error thrown\nsimple.single().subscribe(createSubscriber('single'));\n\n// take and skip won't throw errors\n// take does the first however emissions\n// skip will take the emissions after a number\nsimple.take(2).subscribe(createSubscriber('take'));\n\nsimple.skip(2).subscribe(createSubscriber('skip'));\n\n// 3, 4\nsimple\n  .skip(2)\n  .take(2)\n  .subscribe(createSubscriber('skip'));\n\n// skipWhile / takeWhile\nRx.Observable.interval(500)\n  .skipWhile((i) => i < 4)\n  .takeWhile((i) => i < 10)\n  .subscribe(createSubscriber('skipWhile/takeWhile'));\n\n// what's until and take emissions until\nRx.Observable.interval(500)\n  .skipUntil(Rx.Observable.timer(1000))\n  .takeUntil(Rx.Observable.timer(4000))\n  .subscribe(createSubscriber('skipUntil'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"47-zip--withlatestfrom--combinelatest\"\n    }}>{`4.7: Zip / WithLatestFrom / CombineLatest`}</h2>\n    <p>{`How can we combine observables in different ways?`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`function arrayZip(arr1, arr2, selectorFunc) {\n  const count = Math.min(arr1.length, arr2.length);\n  const results = [];\n\n  for (let i = 0; i < count; i++) {\n    const combined = selector(arr1[i], arr2[i]);\n    results.push(combined);\n  }\n\n  return results;\n}\n\nconst arr1 = [32, 2, 52, 43, 54];\nconst arr2 = [1, 0, 10, 4, 1, 4, 6, 2];\nconst results = arrayZip(arr1, arr2, (left, right) => left * right);\n\nconsole.log(results);\n\n// in RxJS\nRx.Observable.range(1.1)\n  .zip(\n    Rx.Observable.interval(500),\n    (left, right) => \\`item: \\${left}, at \\${right * 500}\\`\n  )\n  .subscribe(createSubscriber('zip'));\n\n// emits value when source emits\n// can also pass (left, right) function like zip as second parameter\nRx.Observable.interval(1000)\n  .withLatestFrom(Rx.Observable.interval(500))\n  .subscribe(createSubscriber('withLatestFrom'));\n\n// emit value if either do\nRx.Observable.interval(1000)\n  .combineLatest(Rx.Observable.interval(500))\n  .subscribe(createSubscriber('withLatestFrom'));\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"48-error-handling-catch-and-retry\"\n    }}>{`4.8: Error Handling Catch and Retry`}</h2>\n    <p>{`If an error happens, an observer stops emitting and can prevent values from emitting at all. Error handling is very important!`}</p>\n    <p><inlineCode parentName=\"p\">{`.catch(error => Rx.Observable.of(error))`}</inlineCode>{` can pass this down as an Observable.`}</p>\n    <p><inlineCode parentName=\"p\">{`.retry()`}</inlineCode>{` we can pass in with a numeral to ensure that we either keep retrying or retry a certain number of times.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}