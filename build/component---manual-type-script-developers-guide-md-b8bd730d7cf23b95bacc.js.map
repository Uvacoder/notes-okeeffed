{"version":3,"sources":["webpack:///../manual/TypeScript/Developers-Guide.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"sfAMO,IAAMA,EAAe,Q,uNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,kCADR,mCAGA,iBAAQ,CACN,GAAM,SADR,SAGA,kGACA,6CAA4B,0BAAYC,WAAW,KAAvB,aAA5B,QAA0F,0BAAYA,WAAW,KAAvB,UAA1F,UAAuJ,0BAAYA,WAAW,KAAvB,UAAvJ,wCACA,mKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mGASL,iBAAQ,CACN,GAAM,4BADR,4BAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kSAoBL,gGAA+E,0BAAYA,WAAW,KAAvB,SAA/E,QAAyI,0BAAYA,WAAW,KAAvB,cAAzI,KACA,iBAAQ,CACN,GAAM,gBADR,kBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gMAQL,iBAAQ,CACN,GAAM,mCADR,uCAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wLAQL,iBAAQ,CACN,GAAM,cADR,cAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,sNAgBL,iBAAQ,CACN,GAAM,oBADR,oBAGA,2GACA,0CACA,sBACE,kBAAIA,WAAW,MAAf,kCACA,kBAAIA,WAAW,MAAf,+BACA,kBAAIA,WAAW,MAAf,oDACA,kBAAIA,WAAW,MAAf,8CAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uKASL,iBAAQ,CACN,GAAM,kCADR,kCAGA,sBACE,kBAAIA,WAAW,MAAf,iFACA,kBAAIA,WAAW,MAAf,gJAEF,iBAAQ,CACN,GAAM,SADR,SAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kEAQL,iBAAQ,CACN,GAAM,YADR,YAGA,sBACE,kBAAIA,WAAW,MAAf,mEACA,kBAAIA,WAAW,MAAf,qFACA,kBAAIA,WAAW,MAAf,2CAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,imBA2BL,iBAAQ,CACN,GAAM,6BADR,6BAGA,sBACE,kBAAIA,WAAW,MAAf,wFACA,kBAAIA,WAAW,QAEjB,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mTAyBL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,09B,8MA4CTJ,EAAWK,gBAAiB","file":"component---manual-type-script-developers-guide-md-b8bd730d7cf23b95bacc.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"developers-guide-to-typescript\"\n    }}>{`Developer's Guide to TypeScript`}</h1>\n    <h2 {...{\n      \"id\": \"types\"\n    }}>{`Types`}</h2>\n    <p>{`For types, we have all our basic types and we can also have custom types.`}</p>\n    <p>{`There are two types, `}<inlineCode parentName=\"p\">{`primitive`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`object`}</inlineCode>{` - the `}<inlineCode parentName=\"p\">{`object`}</inlineCode>{` types itself can be what we define.`}</p>\n    <p>{`Why do we care? The compiler uses it to search for errors and it allows other engineers to understand what type of data is flowing around.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`interface Todo {\n  id: number;\n  completed: boolean;\n};\n\nconst todo = obj.data as Todo;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"declaring-types-examples\"\n    }}>{`Declaring types examples`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// array\nlet colors: string[] = ['a', 'b', 'c'];\n\n// class\nclass Car {}\nlet car: Car = new Car();\n\n// object literal\nlet point: { x: number, y: number } = {\n  x: 10,\n  y: 20\n};\n\n// functions\nconst logNumber: (i: number) => void = (i: number) => {\n  console.log(i);\n};\n`}</code></pre>\n    <p>{`The object literal gets a bit nasty, but we have ways around this using `}<inlineCode parentName=\"p\">{`types`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`interfaces`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"the-any-type\"\n    }}>{`The 'any' type`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const json = '{\"x\":10, \"y\": 20}';\nconst coordinates = JSON.parse(json); // by default gets any time\n\n// this is the better\nconst coor: { x: number, y: number } = JSON.parse(json);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"the-void-and-never-return-types\"\n    }}>{`The 'void' and 'never' return types`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// Returns nothing\nconst logger = (message: string): void => console.log(message);\n\n// Never returns\nconst throwError = (message: string): never => throw new Error(message);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"interfaces\"\n    }}>{`Interfaces`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`interface Vehicle {\n  name: string;\n  year: number;\n  broken: boolean;\n}\n\nconst oldCivic = {\n  name: 'civic',\n  year: 2000,\n  broken: true\n};\n\nconst printVehicle = (vehicle: Vehicle): void => {};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"abstract-classes\"\n    }}>{`Abstract Classes`}</h2>\n    <p>{`Good for classes that we only want to use to extend. Think expectation vs reality.`}</p>\n    <p>{`Abstract classes:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Cannot create objects directly`}</li>\n      <li parentName=\"ol\">{`Only used as a parent class`}</li>\n      <li parentName=\"ol\">{`Can contain real implementations of some methods`}</li>\n      <li parentName=\"ol\">{`Can refer to methods that don't exist yet`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`abstract class Examlpe {\n  // promises we will create this func later\n  abstract requireFunc(argA: number): void;\n\n  swap = (a:number) => requireFunc(a);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"abstract-classes-vs-interfaces\"\n    }}>{`Abstract classes vs Interfaces`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Interfaces promot loose coupling, Abstract/Inheritance is for strong coupling`}</li>\n      <li parentName=\"ul\">{`Interfaces for very different objects we want to work together, Abstract/Inheritance for when we want to build up a definition of an object`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"enums\"\n    }}>{`Enums`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`enum Result {\n  Win = 'W',\n  Loss = 'L',\n  Draw = 'D'\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"generics\"\n    }}>{`Generics`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Like function args, but for types in class/function definitions`}</li>\n      <li parentName=\"ul\">{`Allow us to define the type of a property/argument/return value at a future point`}</li>\n      <li parentName=\"ul\">{`Used heavily when writing useable code`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`class HoldAnything<TypeOfData> {\n  data: TypeOfData;\n}\n\nconst holdNumber = new HolderAnything<number>();\nconst holdString = new HolderAnything<string>();\n\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\nconst holdCoordinates = new HolderAnything<Coordinates>();\n\n// TypeOfData can actually be called anything\n// Convention is normally T, but then we go alphabetical order if we need multiple generics\n\nclass holdMultipleAnything<T,U,V> {\n  firstThing: T;\n  secondThing: U;\n  thirdThing: V;\n}\n\nconst holdAllTheThings = new holdMultipleAnything<string, number, Coordinates>();\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"constraints-with-generics\"\n    }}>{`Constraints with Generics`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Cannot call base methods on generics since there is no guarantee without a interface`}</li>\n      <li parentName=\"ul\"></li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`class Car {\n  print() {\n    console.log('Car');\n  }\n}\n\nclass House {\n  print() {\n    console.log('House');\n  }\n}\n\ninterface Printable {\n  print(): void;\n}\n\nfunction printWhatever<T extends Printable>(el: T) {\n  el.print();\n}\n\nprintWhatever(new Car());\nprintWhatever(new House());\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// what you have to do without method overloading\nclass Utility {\n  static function addNumbers(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function addStrings(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.addNumbers(1,2) // return 2\nUtility.addStrings('Hello','World') // return \"Hello World\"\n\n// method overloading in other languages\nclass Utility {\n  static function add(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function add(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"Hello World\"\n\n// method overloading in other typescript\nclass Utility {\n  static function add(a:number, b: number): number;\n  static function add(a:string, b: string): string;\n\n  static function add(a, b) {\n    return a + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"HelloWorld\"\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}