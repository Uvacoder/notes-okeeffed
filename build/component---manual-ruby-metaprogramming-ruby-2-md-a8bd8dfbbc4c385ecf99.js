(window.webpackJsonp=window.webpackJsonp||[]).push([[575],{Exzu:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return l}));n("1c7q"),n("abGl"),n("gZHo"),n("Fdmb"),n("Ir+3"),n("2mQt"),n("mXGw");var a=n("/FXl"),r=n("TjRS");n("aD51");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Ruby/Metaprogramming-Ruby-2.md"}});var c={_frontmatter:i},o=r.a;function l(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(o,s({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"metaprogramming-ruby-2"},"Metaprogramming Ruby 2"),Object(a.b)("h2",{id:"resources"},"Resources"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",s({parentName:"li"},{href:"https://www.rubyguides.com/2018/10/method-visibility/"}),"Access Modifiers in Ruby")),Object(a.b)("li",{parentName:"ol"},Object(a.b)("a",s({parentName:"li"},{href:"https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Classes"}),"Ruby vs Java Access Modifiers"))),Object(a.b)("h2",{id:"the-object-model"},"The Object Model"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Everytime you write the same class in the same namespace, it is more of an extension to an existing class (or new class if called for first time).")),Object(a.b)("h3",{id:"modules--look-ups"},"Modules & Look ups"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-ruby"}),"module M1\n  def my_method\n    # M1#my_method()\n  end\nend\n\nclass C\n  include M1\nend\n\nclass D < C; end\n\nD.ancestors # => [D, C, M1, Object, Kernel, BasicObject]\n")),Object(a.b)("p",null,"In Ruby 2, you can insert a module BELOW the including class rather than above:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-ruby"}),"class C2\n  prepend M2\nend\n\nclass D2 < C2; end\n\nD2.ancestors # => [D, M2, C, Object, Kernel, BasicObject]\n")),Object(a.b)("p",null,"So for multiple inclusions..."),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-ruby"}),"module M1; end\n\nmodule M2\n  include M1\nend\n\nmodule M3\n  prepend M1\n  include M2\nend\n\nM3.ancestors # => [M1, M3, M2]\n")),Object(a.b)("h3",{id:"the-kernel"},"The Kernel"),Object(a.b)("p",null,"Soe methods such as ",Object(a.b)("inlineCode",{parentName:"p"},"print")," can be called from anywhere. Every object has the ",Object(a.b)("inlineCode",{parentName:"p"},"print")," method. These are private instance methods of the module ",Object(a.b)("inlineCode",{parentName:"p"},"Kernel"),":"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-ruby"}),"Kernel.private_instance_methods.grep(/^pr/) # => [:printf, :print, :proc]\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Here is an interesting aside about access modifiers in Ruby:"),Object(a.b)("p",{parentName:"blockquote"},'Now, "protected" deserves more discussion. Those of you coming from Java or C++ have learned that in those languages, if a method is “private”, its visibility is restricted to the declaring class, and if the method is “protected”, it will be accessible to children of the class (classes that inherit from parent) or other classes in that package.'),Object(a.b)("p",{parentName:"blockquote"},'In Ruby, "private" visibility is similar to what "protected" is in Java. Private methods in Ruby are accessible from children. You can’t have truly private methods in Ruby; you can’t completely hide a method.'),Object(a.b)("p",{parentName:"blockquote"},"The difference between protected and private is subtle. If a method is protected, it may be called by any instance of the defining class or its subclasses. If a method is private, it may be called only within the context of the calling object---it is never possible to access another object instance's private methods directly, even if the object is of the same class as the caller. For protected methods, they are accessible from objects of the same class (or children).")),Object(a.b)("h3",{id:"self"},"Self"),Object(a.b)("p",null,"You can return ",Object(a.b)("inlineCode",{parentName:"p"},"self")," for the class instance. I believe this means that you can make classes chainable."),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-ruby"}),"class A\n  def my_method\n    self\n  end\nend\n")))}l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Ruby/Metaprogramming-Ruby-2.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-ruby-metaprogramming-ruby-2-md-a8bd8dfbbc4c385ecf99.js.map