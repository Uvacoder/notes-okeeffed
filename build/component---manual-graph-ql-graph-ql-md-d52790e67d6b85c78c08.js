(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{Ue0D:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return s}));n("1c7q"),n("abGl"),n("gZHo"),n("Fdmb"),n("Ir+3"),n("2mQt"),n("mXGw");var a=n("/FXl"),r=n("TjRS");n("aD51");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/GraphQL/GraphQL.md"}});var l={_frontmatter:i},p=r.a;function s(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(p,o({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"graphql---udemy"},"GraphQL - Udemy"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#graphql---udemy"}),"GraphQL - Udemy"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#restful-router-primer"}),"RESTful Router Primer")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#the-shortcomings-of-restful-routing"}),"The shortcomings of RESTful routing"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#complex-example"}),"Complex example")))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#starting-with-graphql"}),"Starting with GraphQL")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#working-with-graphql"}),"Working with GraphQL")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#registering-graphql-with-express"}),"Registering GraphQL with Express")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#graphql-schemas"}),"GraphQL Schemas")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#the-graphiql-tool"}),"The Graphiql tool")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#a-realistic-data-source"}),"A realistic data source")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#async-resolve-functions"}),"Async Resolve functions")))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#how-do-we-hook-up-relating-a-company-to-a-user"}),"How do we hook up relating a company to a user?"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#updating-the-schema"}),"Updating the Schema")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#multiple-root-query-points"}),"Multiple Root Query Points")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#bidirectional-relations"}),"Bidirectional Relations")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#query-fragments"}),"Query Fragments")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#mutations"}),"Mutations"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#non-null-fields-and-mutations"}),"Non-null fields and Mutations")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#deleting-mutations"}),"Deleting mutations")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#editing-mutations"}),"Editing mutations")))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#graphql-clients---apollo-vs-relay"}),"GraphQL Clients - Apollo vs Relay"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#apollo-server-vs-graphql-server"}),"Apollo Server vs GraphQL Server")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#setting-up-mongolab"}),"Setting up MongoLab")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#running-the-project"}),"Running the project")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#setting-up-apollo-client"}),"Setting up Apollo Client")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#gql-queries-in-react"}),"GQL Queries in React")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#bonding-queries-with-components"}),"Bonding queries with components")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#handling-pending-queries"}),"Handling Pending Queries")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#adding-react-router"}),"Adding React Router")))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#mutations-in-react"}),"Mutations in React"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#query-params"}),"Query Params")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#passing-variables-in-react"}),"Passing variables in React")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#refetching-lists"}),"Refetching Lists")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#deletion-mutations"}),"Deletion mutations")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#fetching-a-particular-item"}),"Fetching a particular item")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#adding-fetchsong-to-the-component"}),"Adding fetchSong to the component")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#watching-for-data"}),"Watching for Data")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#more-action-submitting"}),"More action submitting")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#submitting-the-lyrics"}),"Submitting the lyrics")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#extending-queries"}),"Extending Queries")))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#caching-with-dataidfromobject"}),"Caching with dataIdFromObject")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#more-on-mutations"}),"More on Mutations"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#optimistic-mutations"}),"Optimistic mutations")))))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#authentication-applications---concerned-with-both-the-front-and-back-end"}),"Authentication Applications - concerned with both the front and back end"),"\n- ",Object(a.b)("a",o({parentName:"li"},{href:"#delegating-to-an-authentication-service"}),"Delegating to an Authentication Service"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#handling-errors-gracefully"}),"Handling Errors Gracefully"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",o({parentName:"li"},{href:"#handling-errors-around-signup"}),"Handling Errors Around Signup"))))))),Object(a.b)("h2",{id:"restful-router-primer"},"RESTful Router Primer"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Given a collection of records on a server, there should be a uniform URL and HTTP request method used to utilize that collection of records.")),Object(a.b)("p",null,"Having the ability to use CRUD requests to interact with data on the server."),Object(a.b)("p",null,"There are more than just POST, GET, PUT and DELETE methods, but they are the most common."),Object(a.b)("p",null,"So far, we have just looked at how to manipulate single records."),Object(a.b)("p",null,"Handling users may look like ",Object(a.b)("inlineCode",{parentName:"p"},"/users"),", handling posts from that user may be ",Object(a.b)("inlineCode",{parentName:"p"},"/users/23/posts")," - get may then start deepening even further."),Object(a.b)("h2",{id:"the-shortcomings-of-restful-routing"},"The shortcomings of RESTful routing"),Object(a.b)("p",null,"There are no hardcoded set of rules, just a set of conventions."),Object(a.b)("h3",{id:"complex-example"},"Complex example"),Object(a.b)("p",null,"Think of a Facebook grid where the users are lined up with things like a user image, name, company name and position name. How might we store this data in the table?"),Object(a.b)("p",null,"Maybe create a User model? But also maybe no the ideal way to do it."),Object(a.b)("p",null,"It would not be obvious to get all the company names back."),Object(a.b)("p",null,"Maybe as an alternative schema, we would start build out a relational schema."),Object(a.b)("p",null,"Given that, how do we now build out a URL RESTful route in order to get all of this data."),Object(a.b)("p",null,"So far for ",Object(a.b)("inlineCode",{parentName:"p"},"Current User > Friend > Company || Position"),", we might be able to start with ",Object(a.b)("inlineCode",{parentName:"p"},"/users/23/friends")," - but then how do we get the company or the position for the deeper nested URL?"),Object(a.b)("p",null,"Maybe we could do ",Object(a.b)("inlineCode",{parentName:"p"},"users/1/companies")," which could get back the ID for the company, a similiar thing for the position etc. Alternatively, maybe ",Object(a.b)("inlineCode",{parentName:"p"},"/users/23/friends/[companies|positions]"),". The problem with these endpoints is that they are all very particular."),Object(a.b)("p",null,"How about if we broke all conventions and went with ",Object(a.b)("inlineCode",{parentName:"p"},"/users/23/friends_with_companies_and_positions"),"? We are definitely breaking conventions here."),Object(a.b)("p",null,"Once we even do make the particular request, we might get a bunch of data from the tables that we don't even care about. This could be dramatically overserving or we may need to continually add or edit the RESTful end points."),Object(a.b)("h2",{id:"starting-with-graphql"},"Starting with GraphQL"),Object(a.b)("p",null,"Now that we've seen the shortfalls of RESTful routing, let's see how GraphQL can help us out."),Object(a.b)("p",null,"Let's now imagine we know all the data in this theoretical database. When we think about the ",Object(a.b)("inlineCode",{parentName:"p"},"graph")," that all the relations between all this data makes and the relations between them (nodes and edges), understanding how the data fits into the structure is key to understanding how GraphQL works. NOTE we can still use any database we want - use this as an understanding."),Object(a.b)("p",null,"Now, if we take this graph and assign an ID to each of our users and organised the data, we can query it using GraphQL."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'// start with user 23 - find all their friends\n// and all the companies that those friends work at\n\n1. Tell GraphQL find user 23\n2. Find all friends of user 23\n3. Tell GraphQL to find the company associated\n\n// the query that could do this\n// crawl along the query\nquery {\n    user(id: "23") {\n        friends {\n            company {\n                name\n            }\n        }\n    }\n}\n')),Object(a.b)("h2",{id:"working-with-graphql"},"Working with GraphQL"),Object(a.b)("p",null,"How can we get this to come together?"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Make an Express server and hook it up to a datastore"),Object(a.b)("li",{parentName:"ol"},"Hook it up to a prebuilt app called GraphiQL to make a couple of test queries")),Object(a.b)("p",null,"For installation on the test ",Object(a.b)("inlineCode",{parentName:"p"},"users")," project, let's ",Object(a.b)("inlineCode",{parentName:"p"},"yarn add express express-graphql graphql lodash")),Object(a.b)("h2",{id:"registering-graphql-with-express"},"Registering GraphQL with Express"),Object(a.b)("p",null,"Once you have set up a basic Express server, we can look at how to make GraphQL work with Express."),Object(a.b)("p",null,"Process of the app"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"1. Web page makes a request to the Server\n2. Server decides whether it asks for Graphql\n    - if yes, GraphQL before 3\n    - if no, go to 3\n3. Respond\n")),Object(a.b)("p",null,"GraphQL is just one little part of the Express app."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"// hooking up GraphQL\nconst express = require('express');\nconst expressGraphQL = require('express-graphql');\n\nconst app = express();\n\napp.use('/graphql', expressGraphQL({\n    graphiql: true\n}));\n\napp.listen(4000, () => {\n    console.log('listening on 4000');\n});\n")),Object(a.b)("h2",{id:"graphql-schemas"},"GraphQL Schemas"),Object(a.b)("p",null,'Using this middleware (using the "use" Express instance method), we passed in an options object. We need to also pass a schema along with these options.'),Object(a.b)("p",null,"We can do all this inside of a schema js file."),Object(a.b)("p",null,"If we decide the ",Object(a.b)("inlineCode",{parentName:"p"},"user")," schema as such that is has an ",Object(a.b)("inlineCode",{parentName:"p"},"id, firstName company_id, position_id and users [id]"),", we can the picture our relational shema."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Writing the schema")),Object(a.b)("p",null,"Not the easiest the write, but as we continual to work with GraphQL, it'll start to become more and more of the same."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"// schema.js\n\nconst graphql = require('graphql');\n\nconst {\n    GraphQLObjectType,\n    GraphQLString,\n    GraphQLInt\n} = graphql;\n\nconst UserType = new GraphQLObjectType({\n    name: 'User',\n    fields: {\n        id: { type: GraphQLString },\n        firstName: { type: GraphQLString },\n        age: { type: GraphQLInt }\n    }\n});\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Root Query")),Object(a.b)("p",null,'We need to pass something into the root query eg. "Hey, give me the user with id 23". We can think of it like an "entry point" into our data.'),Object(a.b)("p",null,"We can tell the 'root query' what we can ask about."),Object(a.b)("p",null,"Below with the ",Object(a.b)("inlineCode",{parentName:"p"},"resolve()")," function, the parentValue is not used often, and the args are the args that we provide."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"// in GraphQL\nconst RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        user: {\n            type: UserType,\n            args: { id: { type: GraphQLString } },\n            resolve(parentValue, args) {\n\n            }\n        }\n    }\n});\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Querying for data")),Object(a.b)("p",null,"Instead of using a database, we're just going to hard code some users for now."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"// top of the schema.js file\n\nconst users = [\n    { id: '23', firstName: 'Bill', age: 20 },\n    { id: '47', firstName: 'Sam', age: 21 }\n];\n\n// in the query\nconst RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        user: {\n            type: UserType,\n            args: { id: { type: GraphQLString } },\n            resolve(parentValue, args) {\n                // use lodash to find\n                return _.find(users, { id: args.id });\n            }\n        }\n    }\n});\n")),Object(a.b)("p",null,"To pass this schema back to express, we destructure import ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLSchema")," and at the bottom of the file we pass the root query."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"new GraphQLSchema({\n    query: RootQuery\n});\n")),Object(a.b)("h2",{id:"the-graphiql-tool"},"The Graphiql tool"),Object(a.b)("p",null,"This tool has been given to us by the GraphQL team. On the left hand side, we can write a query and run it to see what happens."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"docs")," auto generates docs for us to see the type of queries we can make."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'// making the query\n// note: this is not JS\n{\n  user(id: "23") {\n    id,\n    firstName,\n    age\n  }\n}\n\n// what is returns\n{\n  "data": {\n    "user": {\n      "id": "23",\n      "firstName": "Bill",\n      "age": 20\n    }\n  }\n}\n')),Object(a.b)("p",null,"So with the query, it heads to the ",Object(a.b)("inlineCode",{parentName:"p"},"RootQueryType")," and enter into the graph of data. Since we declared ",Object(a.b)("inlineCode",{parentName:"p"},"user")," on the query, it checks the ",Object(a.b)("inlineCode",{parentName:"p"},"user")," field in the RootQuery below."),Object(a.b)("p",null,"With the args, we say that it expects an ",Object(a.b)("inlineCode",{parentName:"p"},"id")," of type string of what we did, so what it then does with the lodash find method we added is that it looks within users for the id that matches the argument ID."),Object(a.b)("p",null,"Lodash returns a raw JSON object directly since the return handles objects for us."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        user: {\n            type: UserType,\n            args: { id: { type: GraphQLString } },\n            resolve(parentValue, args) {\n                // use lodash to find\n                return _.find(users, { id: args.id });\n            }\n        }\n    }\n});\n")),Object(a.b)("p",null,"With the query, we can also now reduce and only call for the data that we want."),Object(a.b)("p",null,"If we do not find an valid ",Object(a.b)("inlineCode",{parentName:"p"},"id"),", we will get null back. If there is no arg to the query, we get an error where it expects the ",Object(a.b)("inlineCode",{parentName:"p"},"name of an argument"),"."),Object(a.b)("h2",{id:"a-realistic-data-source"},"A realistic data source"),Object(a.b)("p",null,"So we don't really want to use a static list of users - because that's not realistic. So let's use some different architectures that we can use to use GraphQL with."),Object(a.b)("p",null,"We could the server which hosts GraphQL and then any database."),Object(a.b)("p",null,"If it's any small sized project, we could use Express etc. With larger companies, you won't use a single monolithic store, but the same Express/GraphQL Server will touch bases with a variety of databases and can act as a proxy of sorts to go and collect this data from those different datasources."),Object(a.b)("p",null,"What we can do is have an outside server to give us some data in our current approach."),Object(a.b)("p",null,"That way, we will need to spin up a second server. We can use JSON server to act as another source of data."),Object(a.b)("p",null,"For the outside API, we can use ",Object(a.b)("inlineCode",{parentName:"p"},"json-server"),". Spin up a server create a ",Object(a.b)("inlineCode",{parentName:"p"},"db.json")," file in order to do so."),Object(a.b)("h2",{id:"async-resolve-functions"},"Async Resolve functions"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        user: {\n            type: UserType,\n            args: { id: { type: GraphQLString } },\n            resolve(parentValue, args) {\n                return axios.get(`http://localhost:3000/users/${args.id}`)\n                    .then(res => res.data);\n            }\n        }\n    }\n});\n")),Object(a.b)("h1",{id:"how-do-we-hook-up-relating-a-company-to-a-user"},"How do we hook up relating a company to a user?"),Object(a.b)("p",null,"Given a schema of ",Object(a.b)("inlineCode",{parentName:"p"},"id, name and description"),", how can we relate a user and their company?"),Object(a.b)("p",null,"First with db.json, update the file to have companies."),Object(a.b)("p",null,"Once we have..."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-json"}),'{\n    "users": [\n        { "id": "23", "firstName": "Bill", "age": 20, "companyId": "1" },\n        { "id": "47", "firstName": "Sam", "age": 21, "companyId": "2" },\n        { "id": "41", "firstName": "Milly", "age": 41, "companyId": "2" }\n    ],\n    "companies": [\n        { "id": "1", "name": "Apple", "description": "iPhone" },\n        { "id": "2", "name": "Google", "description": "Search" }\n    ]\n}\n')),Object(a.b)("p",null,"We can now see the ",Object(a.b)("inlineCode",{parentName:"p"},"/companies")," url can give us a company. To get JSON server to show us who works where, ",Object(a.b)("inlineCode",{parentName:"p"},"json-server")," works the relationship out at ",Object(a.b)("inlineCode",{parentName:"p"},"companies/1/users"),"."),Object(a.b)("h2",{id:"updating-the-schema"},"Updating the Schema"),Object(a.b)("p",null,"Now in the schema we can update to have the following."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const CompanyType = new GraphQLObjectType({\n    name: 'Company',\n    fields: {\n        id: { type: GraphQLString },\n        name: { type: GraphQLString },\n        description: { type: GraphQLString }\n    }\n});\n\nconst UserType = new GraphQLObjectType({\n    name: 'User',\n    fields: {\n        id: { type: GraphQLString },\n        firstName: { type: GraphQLString },\n        age: { type: GraphQLInt },\n        // note: this is from the previously declared type\n        company: { type: CompanyType }\n    }\n});\n")),Object(a.b)("p",null,"Why can we get away with saying a related ",Object(a.b)("inlineCode",{parentName:"p"},"company")," and not ",Object(a.b)("inlineCode",{parentName:"p"},"companyId"),". Where the difference is, the ",Object(a.b)("inlineCode",{parentName:"p"},"resolve")," function will help with the resolution."),Object(a.b)("h2",{id:"multiple-root-query-points"},"Multiple Root Query Points"),Object(a.b)("p",null,"Currently, we cannot just find a company by itself. Only the user using the id."),Object(a.b)("p",null,"We can adjust this with adding to the Root Query."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const RootQuery = new GraphQLObjectType({\n    name: 'RootQueryType',\n    fields: {\n        user: {\n            type: UserType,\n            args: { id: { type: GraphQLString } },\n            resolve(parentValue, args) {\n                return axios\n                    .get(`http://localhost:3000/users/${args.id}`)\n                    .then((res) => res.data);\n            }\n        },\n        company: {\n            type: CompanyType,\n            args: { id: { type: GraphQLString } },\n            resolve(parentValue, args) {\n                return axios\n                    .get(`http://localhost:3000/companies/${args.id}`)\n                    .then((res) => res.data);\n            }\n        }\n    }\n});\n")),Object(a.b)("h2",{id:"bidirectional-relations"},"Bidirectional Relations"),Object(a.b)("p",null,"Given the one-to-many relationship we can find between companies and users, how can find the users that work for a company?"),Object(a.b)("p",null,"We can use a ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLList")," to return a list of different entities."),Object(a.b)("p",null,"The circular reference order of operations issue requires a little work around. We can use a lexical arrow function to give lexical scope. Using this, it will ensure the entire file is executed beforehand."),Object(a.b)("p",null,"The issue itself is more of closures and closure scopes."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const CompanyType = new GraphQLObjectType({\n    name: 'Company',\n    fields: () => ({\n        id: { type: GraphQLString },\n        name: { type: GraphQLString },\n        description: { type: GraphQLString },\n        users: {\n            // UserType may not yet be defined error may occur\n            // because of a circular reference\n            type: new GraphQLList(UserType),\n            resolve(parentValue, args) {\n                return axios\n                    .get(\n                        `http://localhost:3000/companies/${\n                            parentValue.id\n                        }/users`\n                    )\n                    .then((res) => res.data);\n            }\n        }\n    })\n});\n")),Object(a.b)("p",null,"Now that we have circular relations, we can build back nested circular relations as we go."),Object(a.b)("h2",{id:"query-fragments"},"Query Fragments"),Object(a.b)("p",null,"How does the syntax work and how can we expand upon it?"),Object(a.b)("p",null,"You could also add the ",Object(a.b)("inlineCode",{parentName:"p"},"query")," to a query to acknowledge"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'query findCompany {\n    company(id: "2") {\n    name\n    users {\n      id,\n      firstName\n        company {\n          name\n        }\n\n    }\n  }\n}\n')),Object(a.b)("p",null,"With the Root Query, each field is like an optional query to make."),Object(a.b)("p",null,"We can also ask for as many companies as we like, however we need to name the response so there are no JSON duplicate keys on the return:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'{\n  apple: company(id: "1") {\n    name\n    users {\n      id,\n      firstName\n        company {\n          name\n        }\n\n    }\n  },\n  google: company(id: "2") {\n    name\n    users {\n      id,\n      firstName\n        company {\n          name\n        }\n\n    }\n  }\n}\n')),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Query Fragments")),Object(a.b)("p",null,"In the above, we list out the name, users etc twice."),Object(a.b)("p",null,"A query fragment is a list of different properties we want to get back. These are seen a lot on the front end."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'{\n    google: company(id: "2") {\n    ...companyDetails\n  },\n  apple: company(id: "1") {\n    ...companyDetails\n  }\n}\n\nfragment companyDetails on Company {\n    name\n    users {\n      id,\n      firstName\n        company {\n          name\n        }\n\n    }\n}\n')),Object(a.b)("h2",{id:"mutations"},"Mutations"),Object(a.b)("p",null,"Now that we've set up the ability to read data, we haven't spent anything on modifying the datastore."),Object(a.b)("p",null,"They're notorious for being a bit more challenging to work with."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"json-server")," has support for updating records."),Object(a.b)("p",null,"In order for updating, we create completely separate objects that we can manipulate in ",Object(a.b)("inlineCode",{parentName:"p"},"schema.js"),"."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const mutation = new GraphQLObjectType({\n    name: 'Mutation',\n    fields: {}\n});\n")),Object(a.b)("h3",{id:"non-null-fields-and-mutations"},"Non-null fields and Mutations"),Object(a.b)("p",null,"Given our application at the moment, it probably makes sense that all of these users we add with this mutation have a ",Object(a.b)("inlineCode",{parentName:"p"},"firstName")," and ",Object(a.b)("inlineCode",{parentName:"p"},"age"),". We can use ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQLNonNull")," as a wrapper object to ensure the value is non-null."),Object(a.b)("p",null,"Make sure you import it."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const mutation = new GraphQLObjectType({\n    name: 'Mutation',\n    fields: {\n        addUser: {\n            // not always returning the same type\n            // that we work on\n            type: UserType,\n            args: {\n                firstName: { type: new GraphQLNonNull(GraphQLString) },\n                age: { type: new GraphQLNonNull(GraphQLInt) },\n                companyId: { type: GraphQLString }\n            },\n            resolve(parentValue, { firstName, age }) {\n                return axios.post(`http://localhost:3000/users`, {\n                    firstName,\n                    age\n                }).then(res => res.data);\n            }\n        }\n    }\n});\n")),Object(a.b)("p",null,"As for using the mutation:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'// in graphiql\nmutation {\n    addUser(firstName: "Stan", age: "26") {\n        // we must ask for some property coming back\n        id,\n        firstName,\n        age\n    }\n}\n')),Object(a.b)("h3",{id:"deleting-mutations"},"Deleting mutations"),Object(a.b)("p",null,"This will be different since you should take a shot."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const mutation = new GraphQLObjectType({\n    name: 'Mutation',\n    fields: {\n        addUser: {\n            // not always returning the same type\n            // that we work on\n            type: UserType,\n            args: {\n                firstName: { type: new GraphQLNonNull(GraphQLString) },\n                age: { type: new GraphQLNonNull(GraphQLInt) },\n                companyId: { type: GraphQLString }\n            },\n            resolve(parentValue, { firstName, age }) {\n                return axios.post(`http://localhost:3000/users`, {\n                    firstName,\n                    age\n                }).then(res => res.data);\n            }\n        },\n        deleteUser: {\n            type: UserType,\n            args: {\n                id: { type: new GraphQLNonNull(GraphQLString) }\n            },\n            resolve(parentValue, { id }) {\n                return axios.delete(`http://localhost:3000/users/${id}`, { id })\n                    .then(res => res.data);\n            }\n        }\n    }\n});\n")),Object(a.b)("h3",{id:"editing-mutations"},"Editing mutations"),Object(a.b)("p",null,"Reminder: difference between a ",Object(a.b)("inlineCode",{parentName:"p"},"put")," and ",Object(a.b)("inlineCode",{parentName:"p"},"patch")," request."),Object(a.b)("p",null,"A ",Object(a.b)("inlineCode",{parentName:"p"},"put")," request is used when we want to ",Object(a.b)("strong",{parentName:"p"},"completely")," replace a record, whereas a ",Object(a.b)("inlineCode",{parentName:"p"},"patch")," request does not replace it completely, but forms the updates."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const mutation = new GraphQLObjectType({\n    name: 'Mutation',\n    fields: {\n        addUser: {\n            // not always returning the same type\n            // that we work on\n            type: UserType,\n            args: {\n                firstName: { type: new GraphQLNonNull(GraphQLString) },\n                age: { type: new GraphQLNonNull(GraphQLInt) },\n                companyId: { type: GraphQLString }\n            },\n            resolve(parentValue, { firstName, age }) {\n                return axios.post(`http://localhost:3000/users`, {\n                    firstName,\n                    age\n                }).then(res => res.data);\n            }\n        },\n        deleteUser: {\n            type: UserType,\n            args: {\n                id: { type: new GraphQLNonNull(GraphQLString) }\n            },\n            resolve(parentValue, { id }) {\n                return axios.delete(`http://localhost:3000/users/${id}`, { id })\n                    .then(res => res.data);\n            }\n        },\n        editUser: {\n            type: UserType,\n            args: {\n                id: { type: new GraphQLNonNull(GraphQLString) } ,\n                firstName: { type: GraphQLString },\n                age: { type: GraphQLInt },\n                companyId: { type: GraphQLString }\n            },\n            resolve(parentValue, args) {\n                return axios.patch(`http://localhost:3000/users/${args.id}`, args)\n                    .then(res => res.data);\n            }\n        }\n    }\n});\n")),Object(a.b)("p",null,"As for the mutation itself for editing:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'mutation {\n    editUser(id: "23", age: 10) {\n        id,\n        firstName,\n        age\n    }\n}\n')),Object(a.b)("h2",{id:"graphql-clients---apollo-vs-relay"},"GraphQL Clients - Apollo vs Relay"),Object(a.b)("p",null,"So far we've limited everything to a client, but we haven't been able to put this data to the end user."),Object(a.b)("p",null,"Let's take what we know and integrate it with a frontend framework."),Object(a.b)("p",null,"In Graphiql, we can actually watch the ",Object(a.b)("inlineCode",{parentName:"p"},"xhr")," requests in the ",Object(a.b)("inlineCode",{parentName:"p"},"Network")," tab and can see everything that we get back etc. That way the data we get back it just the plain, raw data."),Object(a.b)("p",null,"If we go down to request payload on the ",Object(a.b)("inlineCode",{parentName:"p"},"Headers")," tab, we can see the payload that we make. We can notice that even the query itself is the same as what we write in Graphiql."),Object(a.b)("p",null,"The idea of having a front end app with a client is to do basically the same exact thing as we are currently seeing in the Graphiql client. The client itself should be that bonding layer."),Object(a.b)("p",null,"With clients, there are basically three main ones we will discuss. ",Object(a.b)("inlineCode",{parentName:"p"},"Lokka")," being the simplest, ",Object(a.b)("inlineCode",{parentName:"p"},"Apollo")," built by the guys at Meteor JS - good balance between features and complexity. The downside of this is that they have huge experience with GraphQL clients. ",Object(a.b)("inlineCode",{parentName:"p"},"Relay")," is by far the most complex. ",Object(a.b)("inlineCode",{parentName:"p"},"Relay")," is officially used by the Facebook team. Things like mutations etc are 10x more difficult for mutations than what we've previously discussed. It makes sense for larger teams, although maybe not so much for smaller teams."),Object(a.b)("p",null,"As of the current writing, it is at version one - they are in progress with version two."),Object(a.b)("p",null,"In this course, the focus will be on ",Object(a.b)("inlineCode",{parentName:"p"},"Apollo"),"."),Object(a.b)("h3",{id:"apollo-server-vs-graphql-server"},"Apollo Server vs GraphQL Server"),Object(a.b)("p",null,"We are using GraphQL tech on both the frontend and the backend. There is an Apollo server you can make use of, but instead we will used ",Object(a.b)("inlineCode",{parentName:"p"},"express-graphql"),"."),Object(a.b)("p",null,'When is comes to the Apollo server "schema" set up, they split what we do in ',Object(a.b)("inlineCode",{parentName:"p"},"GraphQL Express")," into a ",Object(a.b)("inlineCode",{parentName:"p"},"Types")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Resolves")," file (for the server side)."),Object(a.b)("p",null,"The FOLLOWING section is about how to set up GraphQL on the client side before getting them to communicate."),Object(a.b)("p",null,"This app will use the Mongo Lab custom URL."),Object(a.b)("h3",{id:"setting-up-mongolab"},"Setting up MongoLab"),Object(a.b)("p",null,"Head onto MongoLab and then create a new free sandbox, then go find the address URI that we need from the info."),Object(a.b)("p",null,"Ensure that you also add a ",Object(a.b)("inlineCode",{parentName:"p"},"User")," for the database."),Object(a.b)("h3",{id:"running-the-project"},"Running the project"),Object(a.b)("p",null,"Start by adding a song using a ",Object(a.b)("inlineCode",{parentName:"p"},"mutation"),"."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'mutation {\n    addSong(title:"I want to know what love is") {\n    id\n  }\n}\n\n// once we have the songId, add a lyric in\nmutation {\n    addLyricToSong(content:"I want to know what loves is, I want you to show me!", songId:"5933a3ebcac9e6b57aad7f76") {\n    id\n    title\n    lyrics {\n      id\n    }\n  }\n}\n\n// now we can query something!\nquery {\n    songs {\n    id,\n    title,\n    lyrics {\n      content\n    }\n  }\n}\n')),Object(a.b)("h3",{id:"setting-up-apollo-client"},"Setting up Apollo Client"),Object(a.b)("p",null,"In the front end, how do we wrap our ",Object(a.b)("inlineCode",{parentName:"p"},"React")," application with helpers from the Apollo library?"),Object(a.b)("p",null,"The React app will have an Apollo Provider that talks back and forth with the Apollo Store. That in turn will talk to the GraphQL Server. The store will also ",Object(a.b)("inlineCode",{parentName:"p"},"store")," the data that comes back from the GraphQL Server."),Object(a.b)("p",null,"The Apollo Store also doesn't care about the fact that we are using React. The Apollo Provider is what helps provide the data to the React application. Think of it as the ",Object(a.b)("inlineCode",{parentName:"p"},"glue")," layer."),Object(a.b)("p",null,"For future projects, you will need to install ",Object(a.b)("inlineCode",{parentName:"p"},"apollo-client"),", ",Object(a.b)("inlineCode",{parentName:"p"},"react-apollo"),", ",Object(a.b)("inlineCode",{parentName:"p"},"graphql-tag")," and maybe ",Object(a.b)("inlineCode",{parentName:"p"},"connect-mongo")," if you are using a third party store. The following imports are required for the app."),Object(a.b)("p",null,"In the code below, we have even passed an empty object to the ApolloClient - it can make assumptions. The store assumes that you are using ",Object(a.b)("inlineCode",{parentName:"p"},"/graphql")," route if you are passing in the object. If you deviate, you will need to start updating the config of this object."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"import ApolloClient from 'apollo-client';\nimport { ApolloProvider } from 'react-apollo';\n\nconst client = new ApolloClient({});\n\nconst Root = () => {\n    return (\n        <ApolloProvider client={client}>\n            <div>Lyrical</div>\n        </ApolloProvider>\n    );\n};\n")),Object(a.b)("p",null,"In opposition, ",Object(a.b)("inlineCode",{parentName:"p"},"Relay")," requires a bunch of configuration to start up and have a working provider."),Object(a.b)("p",null,"We can create a basic ",Object(a.b)("inlineCode",{parentName:"p"},"SongList")," component."),Object(a.b)("h3",{id:"gql-queries-in-react"},"GQL Queries in React"),Object(a.b)("p",null,'So the benefit of GraphQL again, you don\'t have to "overfetch".'),Object(a.b)("p",null,"GraphQL + Apollo take care of everything for us - we just need to bond the query and the component!"),Object(a.b)("p",null,"Once we have the query that we want, we can add the query into the component. That being said, queries are not valid JS. So what we will do is use ",Object(a.b)("inlineCode",{parentName:"p"},"graphql-tag"),"."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"gql")," is a helper to help us write files."),Object(a.b)("p",null,"Making a query will look like so..."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const query = gql`\n    {\n        songs {\n            title\n        }\n    }\n`;\n")),Object(a.b)("h3",{id:"bonding-queries-with-components"},"Bonding queries with components"),Object(a.b)("p",null,"In the component, ",Object(a.b)("inlineCode",{parentName:"p"},"import { graphql } from 'react-apollo';"),". After wrapping the export, we should have a component that may look like this:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"import React, { Component } from 'react';\nimport gql from 'graphql-tag';\nimport { graphql } from 'react-apollo';\n\nclass SongList extends Component {\n    render() {\n        return (\n            <div>\n                SongList\n            </div>\n        );\n    }\n}\n\nconst query = gql`\n    {\n        songs {\n            title\n        }\n    }\n`;\n\n// first parenthesis returns a function\n// that is immediately invocated again\nexport default graphql(query)(SongList);\n")),Object(a.b)("p",null,"Now when the component is rendered, it will show up with no data until the query completes and then the data is resolved."),Object(a.b)("p",null,"The data return is then kept within the component ",Object(a.b)("inlineCode",{parentName:"p"},"props")," field."),Object(a.b)("h3",{id:"handling-pending-queries"},"Handling Pending Queries"),Object(a.b)("p",null,"The props handed in is ",Object(a.b)("inlineCode",{parentName:"p"},"data")," from ",Object(a.b)("inlineCode",{parentName:"p"},"react-apollo")," and ",Object(a.b)("inlineCode",{parentName:"p"},"graphql")," and we can access the return values from ",Object(a.b)("inlineCode",{parentName:"p"},"this.props.data.[name]"),"."),Object(a.b)("p",null,"We need to set some initial props value before we gets our GraphQL results back."),Object(a.b)("h3",{id:"adding-react-router"},"Adding React Router"),Object(a.b)("p",null,"Note: ApolloProvider wraps the Router itself."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Router, Route, hashHistory, IndexRoute } from 'react-router';\nimport ApolloClient from 'apollo-client';\nimport { ApolloProvider } from 'react-apollo';\nimport SongList from './components/SongList';\nimport App from './components/App';\n\nconst client = new ApolloClient({});\n\nconst Root = () => {\n    return (\n        <ApolloProvider client={client}>\n            <Router history={hashHistory}>\n                <Route path=\"/\" component={App}>\n                    <IndexRoute component={SongList} />\n                </Route>\n            </Router>\n        </ApolloProvider>\n    );\n};\n\nReactDOM.render(\n  <Root />,\n  document.querySelector('#root')\n);\n")),Object(a.b)("h2",{id:"mutations-in-react"},"Mutations in React"),Object(a.b)("p",null,"When adding a track using a component, we want to use a form a submit action to post that data."),Object(a.b)("p",null,"That being said, how can we create the mutation on the ",Object(a.b)("inlineCode",{parentName:"p"},"onSubmit")," event?"),Object(a.b)("h3",{id:"query-params"},"Query Params"),Object(a.b)("p",null,"In order to complete our ",Object(a.b)("inlineCode",{parentName:"p"},"gql")," mutation constant, we can make use of query variables."),Object(a.b)("p",null,"A mutation that takes params can be like so:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'mutation AddSong($title: String) {\n    addSong(title: $title) {\n        id\n        title\n    }\n}\n\n// in Graphql under query varibles, we can pass an object\n{\n    "title": "Desperado"\n}\n')),Object(a.b)("h3",{id:"passing-variables-in-react"},"Passing variables in React"),Object(a.b)("p",null,"First, set the mutation."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"const mutation = gql`\n    mutation addSong($title: String) {\n        addSong(title: $title) {\n            id,\n            title\n        }\n    }\n`;\n")),Object(a.b)("p",null,"Second, we can use a GraphQL helper like ",Object(a.b)("inlineCode",{parentName:"p"},"export default graphql(mutation)(SongCreate);")," - however, when we wrap a mutation, it forms a mutate function as part of this.props under ",Object(a.b)("inlineCode",{parentName:"p"},"mutate"),". Now, for the ",Object(a.b)("inlineCode",{parentName:"p"},"onSubmit")," function we have:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"onSubmit(e) {\n    e.preventDefault();\n    console.log(this.props);\n    // point of time when we\n    // want to add a new song\n    this.props.mutate({\n        variables: {\n            title: this.state.title\n        }\n    });\n}\n")),Object(a.b)("h3",{id:"refetching-lists"},"Refetching Lists"),Object(a.b)("p",null,"How do we get Apollo to refetch the query?"),Object(a.b)("p",null,"We can actually do it after the mutation. Using ",Object(a.b)("inlineCode",{parentName:"p"},"this.props.mutate")," takes variables but can also take ",Object(a.b)("inlineCode",{parentName:"p"},"refetchQueries"),"."),Object(a.b)("p",null,"In practice, we do not refetch queries. What we will do is pull out queries from the component files and import it from another queries file."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"onSubmit(e) {\n        e.preventDefault();\n        console.log(this.props);\n        // point of time when we\n        // want to add a new song\n        this.props.mutate({\n            variables: {\n                title: this.state.title\n            },\n            // need to pass in the exact query\n            // can also pass variables: {} if we need them\n            refetchQueries: [{ query: fetchSongsQuery }]\n        }).then(() => hashHistory.push('/'));\n    }\n")),Object(a.b)("p",null,"The GraphQL helper also knows not to rerun the same query twice too."),Object(a.b)("h3",{id:"deletion-mutations"},"Deletion mutations"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"mutation DeleteSong($id: ID) {\n    deleteSong(id: $id) {\n        id\n    }\n}\n")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"export default grahpql")," can only take query at a time. So we need to create multiple instances of the ",Object(a.b)("inlineCode",{parentName:"p"},"graphql")," helper."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"export default compose(\n    graphql(deleteSongQuery),\n    graphql(fetchSongsQuery)\n)(SongList);\n")),Object(a.b)("p",null,"Setting this as our class allows for deletion:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),'class SongList extends Component {\n    onSongDelete(id) {\n        // refetch will fetch any queries\n        // with this component\n        this.props\n            .mutate({ variables: { id } })\n            .then(() => this.props.data.refetch());\n    }\n\n    renderSongs() {\n        return this.props.data.songs.map(({ title, id }) => {\n            return (\n                <li key={id} className="collection-item">\n                    {title}\n                    <i\n                        className="material-icons"\n                        onClick={() => this.onSongDelete(id)}\n                    >\n                        delete\n                    </i>\n                </li>\n            );\n        });\n    }\n\n    render() {\n        console.log(this.props);\n        if (this.props.data.loading) {\n            return <div>Loading...</div>;\n        }\n        return <ul className="collection">{this.renderSongs()}</ul>;\n    }\n}\n')),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Why ",Object(a.b)("inlineCode",{parentName:"strong"},"refetch")," vs ",Object(a.b)("inlineCode",{parentName:"strong"},"refetchQueries"),"?")),Object(a.b)("p",null,"Depends on how you're trying to update your query. If you refetch something not associated with the component, you would use refecthQueries. The ",Object(a.b)("inlineCode",{parentName:"p"},"refetch")," function would not have been available."),Object(a.b)("h3",{id:"fetching-a-particular-item"},"Fetching a particular item"),Object(a.b)("p",null,"After creating a new song component, just in React Router and throw in the new route ",Object(a.b)("inlineCode",{parentName:"p"},"songs/:id")," - id being the wildcard."),Object(a.b)("p",null,"Now in GraphiQL, just like mutations, we can make queries with query variables."),Object(a.b)("p",null,"In a similar pattern:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),'query SongQuery($id: ID!) {\n    song(id: $id) {\n        id\n        title\n  }\n}\n\n// query var\n{\n  "id": "5933a3ebcac9e6b57aad7f76"\n}\n\n// query js file\nimport gql from \'graphql-tag\';\n\nexport default gql`\nquery FetchSong($id: ID!) {\n    song(id: $id) {\n    id\n    title\n  }\n}\n`;\n')),Object(a.b)("p",null,"To get the access to React Router parameters, we can see how ",Object(a.b)("inlineCode",{parentName:"p"},"React Router")," wraps the entire app. If we ",Object(a.b)("inlineCode",{parentName:"p"},"console.log(this.props)")," and check ",Object(a.b)("inlineCode",{parentName:"p"},"params"),", we will see that the params are in fact stored there."),Object(a.b)("h3",{id:"adding-fetchsong-to-the-component"},"Adding fetchSong to the component"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import React, { Component } from 'react';\nimport { graphql } from 'react-apollo';\nimport FetchSong from '../queries/fetchSong';\n\nclass SongDetail extends Component {\n    render() {\n        console.log(this.props);\n        return (\n            <div>\n                <h3>SongDetail!</h3>\n            </div>\n        );\n    }\n}\n\nexport default graphql(FetchSong)(SongDetail);\n")),Object(a.b)("p",null,"So one gotcha we run into with the ",Object(a.b)("inlineCode",{parentName:"p"},"graphql()()")," wrapper is that we need an ",Object(a.b)("inlineCode",{parentName:"p"},"id"),"."),Object(a.b)("p",null,"The problem is that GraphQL makes fetch queries automatically, as opposed to mutations."),Object(a.b)("p",null,"With GraphQL React-Apollo, we can do the following:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"export default graphql(FetchSong, {\n    options: (props) => { return { variables: { id: props.params.id } } }\n})(SongDetail);\n")),Object(a.b)("p",null,"This will allow us to map ",Object(a.b)("inlineCode",{parentName:"p"},"react-router")," to ",Object(a.b)("inlineCode",{parentName:"p"},"react-apollo"),"."),Object(a.b)("h3",{id:"watching-for-data"},"Watching for Data"),Object(a.b)("p",null,"First, handle if no song yet exists."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import React, { Component } from 'react';\nimport { graphql } from 'react-apollo';\nimport { Link } from 'react-router';\nimport FetchSong from '../queries/fetchSong';\n\nclass SongDetail extends Component {\n    render() {\n        console.log(this.props);\n        const { song } = this.props.data;\n        if (!song) {\n            return <div />;\n        }\n\n        return (\n            <div>\n                <Link to=\"/\">Back</Link>\n                <h3>{song.title}</h3>\n            </div>\n        );\n    }\n}\n\nexport default graphql(FetchSong, {\n    options: (props) => {\n        return { variables: { id: props.params.id } };\n    }\n})(SongDetail);\n")),Object(a.b)("h3",{id:"more-action-submitting"},"More action submitting"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import React, { Component } from 'react';\n\nclass LyricCreate extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = { content: '' };\n    }\n\n    onSubmit(event) {\n        event.preventDefault();\n    }\n\n    render() {\n        return (\n            <form action=\"\">\n                <label>Add a lyric</label>\n                <input\n                    value={this.state.content}\n                    onChange={(event) =>\n                        this.setState({ content: event.target.value })\n                    }\n                    // onSubmit={ (event) => this.onSubmit(event) }\n                />\n            </form>\n        );\n    }\n}\n\nexport default LyricCreate;\n")),Object(a.b)("h3",{id:"submitting-the-lyrics"},"Submitting the lyrics"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"import gql from 'graphql-tag';\n\nexport default gql`\n    mutation AddLyricToSong($content: String!, $songId: ID!) {\n        addLyricToSong(content: $content, songId: $songId) {\n            id\n            title\n            lyrics {\n                content\n            }\n        }\n    }\n`;\n")),Object(a.b)("p",null,"Using the mutations, we cannot just do this:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"onSubmit(event) {\n    event.preventDefault();\n    this.props.mutate({\n        variables: {\n            content: this.state.content,\n            // contrary to what you may expect\n            songId: this.props.params.id\n        }\n    });\n}\n")),Object(a.b)("p",null,"We in fact need to pass the ID down as a prop from the other component."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"onSubmit(event) {\n    event.preventDefault();\n    this.props.mutate({\n        variables: {\n            content: this.state.content,\n            songId: this.props.songId\n        }\n    });\n}\n")),Object(a.b)("h3",{id:"extending-queries"},"Extending Queries"),Object(a.b)("p",null,"How do we extend queries for something like a Lyric List? What we can do is enhance the ",Object(a.b)("inlineCode",{parentName:"p"},"SongDetail")," query to grab all the lyrics associated with it."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{}),"query FetchSong($id: ID!) {\n    song(id: $id) {\n        id\n        title\n        lyrics {\n            id\n            content\n        }\n    }\n}\n")),Object(a.b)("p",null,"Now we can simply pass down the lyric value."),Object(a.b)("p",null,"Given that the refresh also again won't automatically happen, we can do something similar to what we did with ",Object(a.b)("inlineCode",{parentName:"p"},"refetchQueries"),", but this time let's try something different."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"How it all works")),Object(a.b)("p",null,"Each time you make a response using the ",Object(a.b)("inlineCode",{parentName:"p"},"apollo")," client, ",Object(a.b)("inlineCode",{parentName:"p"},"apollo")," returns a ",Object(a.b)("inlineCode",{parentName:"p"},"typeName")," in the response."),Object(a.b)("p",null,"However, Apollo does not no what data is set within each of these data stores. It doesn't know the data and what attributes that it has. That's where the root of the current problem is."),Object(a.b)("p",null,'To fix this issue, we can use a piece of Apollo Client config. What we can do is "associate" an ',Object(a.b)("inlineCode",{parentName:"p"},"id")," with each data state. That way, it can ",Object(a.b)("inlineCode",{parentName:"p"},"bond")," with React just that little bit better."),Object(a.b)("p",null,"Now that ",Object(a.b)("inlineCode",{parentName:"p"},"Apollo")," can see that the song with an ",Object(a.b)("inlineCode",{parentName:"p"},"id")," has been updated, Apollo can then itself tell React to update its components."),Object(a.b)("h2",{id:"caching-with-dataidfromobject"},"Caching with dataIdFromObject"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),'const client = new ApolloClient({\n    dataIdFromObject: (obj) => obj.id\n});\n\nconst Root = () => {\n    return (\n        <ApolloProvider client={client}>\n            <Router history={hashHistory}>\n                <Route path="/" component={App}>\n                    <IndexRoute component={SongList} />\n                    <Route path="songs/new" component={SongCreate} />\n                    <Route path="songs/:id" component={SongDetail} />\n                </Route>\n            </Router>\n        </ApolloProvider>\n    );\n};\nReactDOM.render(<Root />, document.querySelector(\'#root\'));\n')),Object(a.b)("h2",{id:"more-on-mutations"},"More on Mutations"),Object(a.b)("p",null,"Liking a lyric"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"const mutation = gql`\n    mutation LikeLyric($id: ID) {\n        likeLyric(id: $id) {\n            id\n            likes\n        }\n    }\n`;\n")),Object(a.b)("h3",{id:"optimistic-mutations"},"Optimistic mutations"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"onLike(id, likes) {\n    this.props.mutate({\n        variables: { id },\n        optimisticResponse: {\n            _typename: 'Mutation',\n            likeLyric: {\n                id: id,\n                _typename: 'LyricType',\n                likes: likes + 1\n            }\n        }\n    });\n}\n")),Object(a.b)("h1",{id:"authentication-applications---concerned-with-both-the-front-and-back-end"},"Authentication Applications - concerned with both the front and back end"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Challenges")),Object(a.b)("table",null,Object(a.b)("thead",{parentName:"table"},Object(a.b)("tr",{parentName:"thead"},Object(a.b)("th",o({parentName:"tr"},{align:null}),"Challenge"),Object(a.b)("th",o({parentName:"tr"},{align:null}),"Solution"))),Object(a.b)("tbody",{parentName:"table"},Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",o({parentName:"tr"},{align:null}),"Multiple pages"),Object(a.b)("td",o({parentName:"tr"},{align:null}),"React Router")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",o({parentName:"tr"},{align:null}),"Data store"),Object(a.b)("td",o({parentName:"tr"},{align:null}),"MongoDB")),Object(a.b)("tr",{parentName:"tbody"},Object(a.b)("td",o({parentName:"tr"},{align:null}),"Authentication"),Object(a.b)("td",o({parentName:"tr"},{align:null}),"PassportJS")))),Object(a.b)("p",null,"But Passport isn't designed with GraphQL in mind."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Auth with GraphQL")),Object(a.b)("p",null,"There are two approaches that we can take to auth with GraphQL and Passport."),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Decoupled approach"),Object(a.b)("li",{parentName:"ol"},"Coupled approach")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Coupled vs Decoupled")),Object(a.b)("p",null,"If we do not use a changed ",Object(a.b)("inlineCode",{parentName:"p"},"mutation"),", we are using the ",Object(a.b)("inlineCode",{parentName:"p"},"decoupled approach"),". In the ",Object(a.b)("inlineCode",{parentName:"p"},"coupled")," approach, we have GraphQL work as the ",Object(a.b)("inlineCode",{parentName:"p"},"middleman")," between the application and ",Object(a.b)("inlineCode",{parentName:"p"},"passport"),". It's about whether or not use GraphQL to process the request or not."),Object(a.b)("p",null,"So, which one? Why would we ever have ",Object(a.b)("inlineCode",{parentName:"p"},"Passport")," involved with ",Object(a.b)("inlineCode",{parentName:"p"},"GraphQL"),"? You could make a strong case for either approach."),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Coupled")),Object(a.b)("p",null,"Pros:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"using Graphql in the way it was intended")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Decoupled")),Object(a.b)("p",null,"Pros:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Once authenticated, you do not need to continue the authentication process.")),Object(a.b)("p",null,"Cons:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"part of the React app would not use GraphQL at all")),Object(a.b)("p",null,"In the example given, they are used together - however, usually the argument is that maybe they should remain decoupled."),Object(a.b)("h3",{id:"delegating-to-an-authentication-service"},"Delegating to an Authentication Service"),Object(a.b)("h2",{id:"handling-errors-gracefully"},"Handling Errors Gracefully"),Object(a.b)("h3",{id:"handling-errors-around-signup"},"Handling Errors Around Signup"),Object(a.b)("p",null,"With the ",Object(a.b)("inlineCode",{parentName:"p"},"apollo")," client, you can also ",Object(a.b)("inlineCode",{parentName:"p"},"catch")," after a mutation."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-javascript"}),"this.props.mutate({\n    variables: { email, password }\n}).catch(res => {\n    const errors = res.graphQLErrors.map(err => err.message);\n    this.setState({ errors });\n});\n\n### The Needs for a HOC\n")))}s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/GraphQL/GraphQL.md"}}),s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-graph-ql-graph-ql-md-d52790e67d6b85c78c08.js.map