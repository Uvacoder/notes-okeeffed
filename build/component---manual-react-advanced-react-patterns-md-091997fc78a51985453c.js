(window.webpackJsonp=window.webpackJsonp||[]).push([[452],{O7je:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return r})),t.d(n,"default",(function(){return c}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var o=t("/FXl"),s=t("TjRS");t("aD51");function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}var r={};void 0!==r&&r&&r===Object(r)&&Object.isExtensible(r)&&!r.hasOwnProperty("__filemeta")&&Object.defineProperty(r,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/React/Advanced-React-Patterns.md"}});var i={_frontmatter:r},l=s.a;function c(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,o,s={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,["components"]);return Object(o.b)(l,a({},i,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"advanced-react-patterns"},"Advanced React Patterns"),Object(o.b)("h2",{id:"resources"},"Resources"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",a({parentName:"li"},{href:"https://frontendmasters.com/courses/advanced-react-patterns/"}),"FE Masters Course")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",a({parentName:"li"},{href:"https://github.com/kentcdodds/advanced-react-patterns-v2/blob/frontend-masters/README.md"}),"Course Material on GitHub")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",a({parentName:"li"},{href:"https://codesandbox.io/s/github/kentcdodds/advanced-react-patterns-v2/tree/frontend-masters"}),"Code Sandbox for course")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",a({parentName:"li"},{href:"https://github.com/downshift-js/downshift"}),"Downshift Library")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("a",a({parentName:"li"},{href:"https://kentcdodds.com/blog/reacts-new-context-api/"}),"React's New Context API - Kent Dodds"))),Object(o.b)("h2",{id:"tldr"},"tl;dr"),Object(o.b)("p",null,"Patterns to know from course:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Compound Components"),Object(o.b)("li",{parentName:"ol"},"Component Injection"),Object(o.b)("li",{parentName:"ol"},"Render Prop"),Object(o.b)("li",{parentName:"ol"},"Render Getters"),Object(o.b)("li",{parentName:"ol"},"State Initializers"),Object(o.b)("li",{parentName:"ol"},"State Reducers"),Object(o.b)("li",{parentName:"ol"},"Control Props"),Object(o.b)("li",{parentName:"ol"},"Provider Pattern")),Object(o.b)("h2",{id:"building-the-basic-toggle"},"Building the Basic Toggle"),Object(o.b)("p",null,"This is used to just set things up for the advanced stuff, but it was worth noting the code that we are using the ",Object(o.b)("inlineCode",{parentName:"p"},"setState")," function passer to ensure we get the latest state guarantee (which is not guaranteed the other way):"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"import React from 'react';\n// üê® uncomment this import to get the switch component.\n// It takes an `onClick` and an `on` prop\nimport { Switch } from '../switch';\n\nclass Toggle extends React.Component {\n  state = { on: false };\n  toggle = () => {\n    // IMPORTANT: This is the example of passing a function for set state then\n    // using a callback to ensure the re-render is fired straight away\n    // @see https://reactjs.org/docs/react-component.html#setstate\n    this.setState(\n      currentState => {\n        return { on: !currentState.on };\n      },\n      () => {\n        this.props.onToggle(this.state.on);\n      },\n    );\n  };\n  // üê® this toggle component is going to need to have state for `on`\n  //\n  // You'll also want a method to handle when the switch is clicked\n  // which will update the `on` state and call the `onToggle` prop\n  // üí∞ this.props.onToggle(this.state.on)\n  render() {\n    // üê® here you'll want to return the switch with the `on` and `onClick` props\n    return <Switch onClick={this.toggle} on={this.state.on} />;\n  }\n}\n\n// Don't make changes to the Usage component. It's here to show you how your\n// component is intended to be used and is used in the tests.\n// You can make all the tests pass by updating the Toggle component.\nfunction Usage({ onToggle = (...args) => console.log('onToggle', ...args) }) {\n  return <Toggle onToggle={onToggle} />;\n}\nUsage.title = 'Build Toggle';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("p",null,"One question that came up - why are we using ",Object(o.b)("inlineCode",{parentName:"p"},"this.props.onToggle"),". Kent's answer:"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"A common pattern in React is that each component manages its own state but lets the parent know what is happening when it changes.")),Object(o.b)("h2",{id:"basic-compound-components"},"Basic Compound Components"),Object(o.b)("p",null,"In the second exercise, we have ",Object(o.b)("inlineCode",{parentName:"p"},"Toggle")," as a compound component:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// Don't make changes to the Usage component. It's here to show you how your\n// component is intended to be used and is used in the tests.\n// You can make all the tests pass by updating the Toggle component.\nfunction Usage({\n  onToggle = (...args) => console.log('onToggle', ...args),\n}) {\n  return (\n    {/* Compound component here! */}\n    <Toggle onToggle={onToggle}>\n      <Toggle.On>The button is on</Toggle.On>\n      <Toggle.Off>The button is off</Toggle.Off>\n      <Toggle.Button />\n    </Toggle>\n  )\n}\nUsage.title = 'Compound Components'\n\nexport {Toggle, Usage as default}\n")),Object(o.b)("p",null,"Why compound components? It helps ease of API - the example shown was a potential message etc. Instead, what we can do is have children like ",Object(o.b)("inlineCode",{parentName:"p"},"<Toggle.On>")," that share implicit state with the parent."),Object(o.b)("p",null,"A real life example in HTML of a compound component:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-html"}),"<select>\n  <option></option>\n</select>\n")),Object(o.b)("p",null,"The example implementation for the ",Object(o.b)("inlineCode",{parentName:"p"},"Toggle")," example is the following:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"class Toggle extends React.Component {\n  // these are the important tidbits to get <Toggle.On>, <Toggle.Off> etc\n  // these could also be declared as functions outside the class, but\n  // here it is mentioned to be a preference to show their linkage\n  static On = ({ on, children }) => (on ? children : null);\n  static Off = ({ on, children }) => (on ? null : children);\n  static Button = ({ on, toggle, ...props }) => (\n    <Switch on={on} onClick={toggle} {...props} />\n  );\n\n  state = { on: false };\n\n  toggle = () =>\n    this.setState(\n      ({ on }) => ({ on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n\n  render() {\n    // Note: This MUST be React.Children.map because this.props.children.map\n    // will not work in React if only using one child\n    return React.Children.map(this.props.children, child =>\n      React.cloneElement(child, {\n        on: this.state.on,\n        toggle: this.toggle,\n      }),\n    );\n  }\n}\n")),Object(o.b)("p",null,"Kent also has an equivalent example of this for Hooks on his ",Object(o.b)("a",a({parentName:"p"},{href:"https://kentcdodds.com/blog/compound-components-with-react-hooks"}),"blog post"),":"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"import React from 'react';\n// this switch implements a checkbox input and is not relevant for this example\nimport { Switch } from '../switch';\nconst ToggleContext = React.createContext();\nfunction useEffectAfterMount(cb, dependencies) {\n  const justMounted = React.useRef(true);\n  React.useEffect(() => {\n    if (!justMounted.current) {\n      return cb();\n    }\n    justMounted.current = false;\n  }, dependencies);\n}\nfunction Toggle(props) {\n  const [on, setOn] = React.useState(false);\n  const toggle = React.useCallback(() => setOn(oldOn => !oldOn), []);\n  useEffectAfterMount(() => {\n    props.onToggle(on);\n  }, [on]);\n  const value = React.useMemo(() => ({ on, toggle }), [on]);\n  return (\n    <ToggleContext.Provider value={value}>\n      {props.children}\n    </ToggleContext.Provider>\n  );\n}\nfunction useToggleContext() {\n  const context = React.useContext(ToggleContext);\n  if (!context) {\n    throw new Error(\n      `Toggle compound components cannot be rendered outside the Toggle component`,\n    );\n  }\n  return context;\n}\nfunction On({ children }) {\n  const { on } = useToggleContext();\n  return on ? children : null;\n}\nfunction Off({ children }) {\n  const { on } = useToggleContext();\n  return on ? null : children;\n}\nfunction Button(props) {\n  const { on, toggle } = useToggleContext();\n  return <Switch on={on} onClick={toggle} {...props} />;\n}\n// for convenience, but totally not required...\nToggle.On = On;\nToggle.Off = Off;\nToggle.Button = Button;\n")),Object(o.b)("h2",{id:"flexible-compound-components"},"Flexible Compound Components"),Object(o.b)("p",null,"To enable us to accept children that are not static properties of the class, we need to make some adjustments to the code from the section above (reminder: there are also some notes in the code above):"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"const ToggleContext = React.createContext({\n  on: false,\n  toggle: () => {},\n});\n\nclass Toggle extends React.Component {\n  static On = ({ children }) => (\n    <ToggleContext.Consumer>\n      {({ on }) => (on ? children : null)}\n    </ToggleContext.Consumer>\n  );\n  static Off = ({ children }) => (\n    <ToggleContext.Consumer>\n      {({ on }) => (on ? null : children)}\n    </ToggleContext.Consumer>\n  );\n  static Button = props => (\n    <ToggleContext.Consumer>\n      {({ on, toggle }) => <Switch on={on} onClick={toggle} {...props} />}\n    </ToggleContext.Consumer>\n  );\n  // üí∞ The reason we had to move `toggle` above `state` is because\n  // in our `state` initialization we're _using_ `this.toggle`. So\n  // if `this.toggle` is not defined before state is initialized, then\n  // `state.toggle` will be undefined.\n  toggle = () =>\n    this.setState(\n      ({ on }) => ({ on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n  state = { on: false, toggle: this.toggle };\n  render() {\n    return (\n      <ToggleContext.Provider value={this.state}>\n        {this.props.children}\n      </ToggleContext.Provider>\n    );\n  }\n}\n")),Object(o.b)("p",null,"This code makes use of the ",Object(o.b)("inlineCode",{parentName:"p"},"consumer")," API. There is also a blog by Kent talking about issues that deals with issues of multiple ",Object(o.b)("inlineCode",{parentName:"p"},"<React.Consumer>")," parents adding up. There is also a few composer libraries to help with this. You can see more ",Object(o.b)("a",a({parentName:"p"},{href:"https://kentcdodds.com/blog/reacts-new-context-api/"}),"on his blog"),"."),Object(o.b)("h2",{id:"render-props-pattern"},"Render Props Pattern"),Object(o.b)("p",null,"When a method does use ",Object(o.b)("inlineCode",{parentName:"p"},"this"),", then it is an indicator that it doesn't need to be on the class."),Object(o.b)("p",null,"This enables us to edge closer to being a ",Object(o.b)("inlineCode",{parentName:"p"},"pure")," function."),Object(o.b)("p",null,'This makes the rendering ownership on the "user" and not the component implementation.'),Object(o.b)("p",null,'The idea is to have a component say "hey, I\'ll be in charge of state and you be in charge of rendering".'),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// only in charge of its own state\n// the \"parent user\" is in charge of\n// rendering\nclass Toggle extends React.Component {\n  state = { on: false };\n  toggle = () =>\n    this.setState(\n      ({ on }) => ({ on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n  getStateAndHelpers() {\n    return {\n      on: this.state.on,\n      toggle: this.toggle,\n    };\n  }\n  render() {\n    return this.props.children(this.getStateAndHelpers());\n  }\n}\n\nfunction Usage({ onToggle = (...args) => console.log('onToggle', ...args) }) {\n  return (\n    <Toggle onToggle={onToggle}>\n      {/* Rendering here is done inline */}\n      {({ on, toggle }) => (\n        <div>\n          {on ? 'The button is on' : 'The button is off'}\n          <Switch on={on} onClick={toggle} />\n          <hr />\n          <button aria-label=\"custom-button\" onClick={toggle}>\n            {on ? 'on' : 'off'}\n          </button>\n        </div>\n      )}\n    </Toggle>\n  );\n}\n")),Object(o.b)("p",null,"If you don't like the verbosity of the render prop, you can always abstract is to another component."),Object(o.b)("p",null,"The render prop method allows total flexibility of the UI but still keep the child in charge of the logic."),Object(o.b)("p",null,"There is also a side topic brought up here called ",Object(o.b)("inlineCode",{parentName:"p"},"Component Injection")," that will use ",Object(o.b)("inlineCode",{parentName:"p"},"React.createElement")," with the children and and pass the props that will enable access to lifecycle methods."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Kent says he prefers ",Object(o.b)("inlineCode",{parentName:"p"},"Render Prop")," pattern over ",Object(o.b)("inlineCode",{parentName:"p"},"Component Injection")," because it is more powerful and the ",Object(o.b)("inlineCode",{parentName:"p"},"createElement")," creates another layer in the React tree. What really seals the deal as well the fact that going ",Object(o.b)("inlineCode",{parentName:"p"},"props => <ToggleChild {...props}>")," gives the same benefits of component injection.")),Object(o.b)("p",null,"So when to use ",Object(o.b)("inlineCode",{parentName:"p"},"Render Prop")," vs ",Object(o.b)("inlineCode",{parentName:"p"},"Compound Components"),"? With compound components, you don't see the state that is passed between ",Object(o.b)("inlineCode",{parentName:"p"},"Toggle")," and all of its children. All the state and handlers are implicit. If people don't care what those values are ie an accordion, there will be some state shared with the parent for which index is open and the implicit state of the child known if it is open."),Object(o.b)("p",null,'The user of that "component" doesn\'t need to know which accordion is open per se. Adding that initial layer of complexity is unnecessary and is why ',Object(o.b)("inlineCode",{parentName:"p"},"Compound Components")," is preferred there."),Object(o.b)("p",null,"The last question - is there a difference between passing children as a prop vs within the tags? They are functionally equivalent. Kent uses ",Object(o.b)("inlineCode",{parentName:"p"},"children")," over render because the context API uses that."),Object(o.b)("h2",{id:"prop-getters"},"Prop Getters"),Object(o.b)("p",null,"What does ",Object(o.b)("inlineCode",{parentName:"p"},"Prop Getters")," solve? Imagine the following where we want to add an ",Object(o.b)("inlineCode",{parentName:"p"},"onClick")," function:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// un-oh, we could be overriding the togglerProps onClick func!\n<button\n  aria-label=\"custom-button\"\n  {...togglerProps}\n  onClick={() => console.log('Doing something')}\n>\n  {on ? 'on' : 'off'}\n</button>\n")),Object(o.b)("p",null,"We now have the issue of accidentally overriding the ",Object(o.b)("inlineCode",{parentName:"p"},"toggleProps onClick")," (or vice versa if we switch the order!)"),Object(o.b)("p",null,"With prop getters, we can solve this problem:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// prop getters\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\n// this is important for the prop getter\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  state = { on: false };\n  toggle = () =>\n    this.setState(\n      ({ on }) => ({ on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    'aria-expanded': this.state.on,\n    onClick: callAll(onClick, this.toggle),\n    ...props,\n  });\n  getStateAndHelpers() {\n    return {\n      on: this.state.on,\n      toggle: this.toggle,\n      getTogglerProps: this.getTogglerProps,\n    };\n  }\n  render() {\n    return this.props.children(this.getStateAndHelpers());\n  }\n}\n\nfunction Usage({\n  onToggle = (...args) => console.log('onToggle', ...args),\n  onButtonClick = () => console.log('onButtonClick'),\n}) {\n  return (\n    <Toggle onToggle={onToggle}>\n      {({ on, getTogglerProps }) => (\n        <div>\n          <Switch {...getTogglerProps({ on })} />\n          <hr />\n          <button\n            {/* Note here we are spreading an object */}\n            {...getTogglerProps({\n              'aria-label': 'custom-button',\n              onClick: onButtonClick,\n              id: 'custom-button-id',\n            })}\n          >\n            {on ? 'on' : 'off'}\n          </button>\n        </div>\n      )}\n    </Toggle>\n  );\n}\nUsage.title = 'Prop Getters';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("h2",{id:"state-initializers"},"State Initializers"),Object(o.b)("p",null,"In general we want to be able to reset back to an initial state and start things up in an initial state. The idea is straight forward."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// State Initializers\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  // The setting of initial state\n  static defaultProps = {\n    initialOn: false,\n    onReset: () => {},\n  };\n  // This helps to communicate what we're trying to accomplish\n  initialState = { on: this.props.initialOn };\n  state = this.initialState;\n  // The important part for reset: this reset uses the initialState object\n  reset = () =>\n    this.setState(this.initialState, () => this.props.onReset(this.state.on));\n  toggle = () =>\n    this.setState(\n      ({ on }) => ({ on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    onClick: callAll(onClick, this.toggle),\n    'aria-expanded': this.state.on,\n    ...props,\n  });\n  getStateAndHelpers() {\n    return {\n      on: this.state.on,\n      toggle: this.toggle,\n      reset: this.reset,\n      getTogglerProps: this.getTogglerProps,\n    };\n  }\n  render() {\n    return this.props.children(this.getStateAndHelpers());\n  }\n}\n\nfunction Usage({\n  initialOn = false,\n  onToggle = (...args) => console.log('onToggle', ...args),\n  onReset = (...args) => console.log('onReset', ...args),\n}) {\n  return (\n    <Toggle initialOn={initialOn} onToggle={onToggle} onReset={onReset}>\n      {({ getTogglerProps, on, reset }) => (\n        <div>\n          <Switch {...getTogglerProps({ on })} />\n          <hr />\n          <button onClick={() => reset()}>Reset</button>\n        </div>\n      )}\n    </Toggle>\n  );\n}\nUsage.title = 'State Initializers';\n")),Object(o.b)("h2",{id:"state-reducer"},"State Reducer"),Object(o.b)("p",null,"This is a common pattern in Reason React. This helps people to control how the state is managed."),Object(o.b)("p",null,"You have to think more critically about how you component manages state as this now becomes an important part of the API. It breaks encapsulation, but allows a huge amount of user flexibility."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// state reducer\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  static defaultProps = {\n    initialOn: false,\n    onReset: () => {},\n    stateReducer: (state, changes) => changes,\n  };\n  initialState = { on: this.props.initialOn };\n  state = this.initialState;\n  // this is a helper to pass state up to parents\n  internalSetState(changes, callback) {\n    this.setState(state => {\n      // handle function setState call\n      const changesObject =\n        typeof changes === 'function' ? changes(state) : changes;\n\n      // apply state reducer\n      const reducedChanges =\n        this.props.stateReducer(state, changesObject) || {};\n\n      // return null if there are no changes to be made\n      // (to avoid an unecessary rerender)\n      return Object.keys(reducedChanges).length ? reducedChanges : null;\n    }, callback);\n  }\n  reset = () =>\n    this.internalSetState(this.initialState, () =>\n      this.props.onReset(this.state.on),\n    );\n  toggle = () =>\n    // now uses internalSetState updater\n    this.internalSetState(\n      ({ on }) => ({ on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    onClick: callAll(onClick, this.toggle),\n    'aria-expanded': this.state.on,\n    ...props,\n  });\n  getStateAndHelpers() {\n    return {\n      on: this.state.on,\n      toggle: this.toggle,\n      reset: this.reset,\n      getTogglerProps: this.getTogglerProps,\n    };\n  }\n  render() {\n    return this.props.children(this.getStateAndHelpers());\n  }\n}\n\nclass Usage extends React.Component {\n  static defaultProps = {\n    onToggle: (...args) => console.log('onToggle', ...args),\n    onReset: (...args) => console.log('onReset', ...args),\n  };\n  initialState = { timesClicked: 0 };\n  state = this.initialState;\n  handleToggle = (...args) => {\n    this.setState(({ timesClicked }) => ({\n      timesClicked: timesClicked + 1,\n    }));\n    this.props.onToggle(...args);\n  };\n  handleReset = (...args) => {\n    this.setState(this.initialState);\n    this.props.onReset(...args);\n  };\n  // This enables us to control the child state.\n  // Note that this breaks encapsulation.\n  toggleStateReducer = (state, changes) => {\n    if (this.state.timesClicked >= 4) {\n      return { ...changes, on: false };\n    }\n    return changes;\n  };\n  render() {\n    const { timesClicked } = this.state;\n    return (\n      <Toggle\n        stateReducer={this.toggleStateReducer}\n        onToggle={this.handleToggle}\n        onReset={this.handleReset}\n      >\n        {toggle => (\n          <div>\n            <Switch\n              {...toggle.getTogglerProps({\n                on: toggle.on,\n              })}\n            />\n            {timesClicked > 4 ? (\n              <div data-testid=\"notice\">\n                Whoa, you clicked too much!\n                <br />\n              </div>\n            ) : timesClicked > 0 ? (\n              <div data-testid=\"click-count\">Click count: {timesClicked}</div>\n            ) : null}\n            <button onClick={toggle.reset}>Reset</button>\n          </div>\n        )}\n      </Toggle>\n    );\n  }\n}\nUsage.title = 'State Reducers';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("p",null,"An alternative suggested in the questions was to just rename ",Object(o.b)("inlineCode",{parentName:"p"},"setInternalState")," to still be ",Object(o.b)("inlineCode",{parentName:"p"},"setState")," and just call the ",Object(o.b)("inlineCode",{parentName:"p"},"super.setState"),":"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// Reset omitted for brevity, but this is a replacement\n// in the above code for `setInternalState`\n\n// this is a helper to pass state up to parents\nsetState(changes, callback) {\n super.setState(state => {\n   // handle function setState call\n   const changesObject =\n     typeof changes === 'function' ? changes(state) : changes;\n\n   // apply state reducer\n   const reducedChanges =\n     this.props.stateReducer(state, changesObject) || {};\n\n   // return null if there are no changes to be made\n   // (to avoid an unecessary rerender)\n   return Object.keys(reducedChanges).length ? reducedChanges : null;\n }, callback);\n}\n")),Object(o.b)("p",null,"Kent does suggest that is could be confusing to see ",Object(o.b)("inlineCode",{parentName:"p"},"setState")," and have it not operate as expected."),Object(o.b)("p",null,"Another alternative Kent suggest is to enable it to become a map:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// this is a helper to pass state up to parents\ninternalSetState(changes, callback) {\n this.setState(state => {\n   return [changes]\n   // handle function setState call\n   .map(c => typeof c === 'function' ? c(state) : c)\n   // apply state reducer\n   .map(c => this.props.stateReducer(state, c) || {})\n   // return null if there are no changes to be made\n   // (to avoid an unecessary rerender)\n  .map(c => Object.keys(c).length ? c : null)[0];\n }, callback);\n}\n")),Object(o.b)("p",null,"We can then also empower the parent to force toggles:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// This will enable the parent to control an\n// ability to force changes\ntoggleStateReducer = (state, changes) => {\n  if (changes.type === 'forced') {\n    return changes;\n  }\n  if (this.state.timesClicked >= 4) {\n    return { ...changes, on: false };\n  }\n  return changes;\n};\n")),Object(o.b)("p",null,"This is the full example of a state reducer with types that can brute force from the parent:"),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// state reducer with types\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  static defaultProps = {\n    initialOn: false,\n    onReset: () => {},\n    stateReducer: (state, changes) => changes,\n  };\n  // üí∞ any time I use a string as an identifier for a type,\n  // I prefer to give it a variable name. That way folks who\n  // want to reference the type can do so using variable which\n  // will help mitigate the problems of indirection.\n  static stateChangeTypes = {\n    reset: '__toggle_reset__',\n    toggle: '__toggle_toggle__',\n  };\n  initialState = { on: this.props.initialOn };\n  state = this.initialState;\n  internalSetState(changes, callback) {\n    this.setState(state => {\n      // handle function setState call\n      const changesObject =\n        typeof changes === 'function' ? changes(state) : changes;\n\n      // apply state reducer\n      const reducedChanges =\n        this.props.stateReducer(state, changesObject) || {};\n\n      // remove the type so it's not set into state\n      const { type: ignoredType, ...onlyChanges } = reducedChanges;\n\n      // return null if there are no changes to be made\n      return Object.keys(onlyChanges).length ? onlyChanges : null;\n    }, callback);\n  }\n\n  reset = () =>\n    this.internalSetState(\n      { ...this.initialState, type: Toggle.stateChangeTypes.reset },\n      () => this.props.onReset(this.state.on),\n    );\n  toggle = ({ type = Toggle.stateChangeTypes.toggle } = {}) =>\n    this.internalSetState(\n      ({ on }) => ({ type, on: !on }),\n      () => this.props.onToggle(this.state.on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    onClick: callAll(onClick, () => this.toggle()),\n    'aria-expanded': this.state.on,\n    ...props,\n  });\n  getStateAndHelpers() {\n    return {\n      on: this.state.on,\n      toggle: this.toggle,\n      reset: this.reset,\n      getTogglerProps: this.getTogglerProps,\n    };\n  }\n  render() {\n    return this.props.children(this.getStateAndHelpers());\n  }\n}\n\nclass Usage extends React.Component {\n  static defaultProps = {\n    onToggle: (...args) => console.log('onToggle', ...args),\n    onReset: (...args) => console.log('onReset', ...args),\n  };\n  initialState = { timesClicked: 0 };\n  state = this.initialState;\n  handleToggle = (...args) => {\n    this.setState(({ timesClicked }) => ({\n      timesClicked: timesClicked + 1,\n    }));\n    this.props.onToggle(...args);\n  };\n  handleReset = (...args) => {\n    this.setState(this.initialState);\n    this.props.onReset(...args);\n  };\n  toggleStateReducer = (state, changes) => {\n    if (changes.type === 'forced') {\n      return changes;\n    }\n    if (this.state.timesClicked >= 4) {\n      return { ...changes, on: false };\n    }\n    return changes;\n  };\n  render() {\n    const { timesClicked } = this.state;\n    return (\n      <Toggle\n        stateReducer={this.toggleStateReducer}\n        onToggle={this.handleToggle}\n        onReset={this.handleReset}\n        ref={this.props.toggleRef}\n      >\n        {({ on, toggle, reset, getTogglerProps }) => (\n          <div>\n            <Switch\n              {...getTogglerProps({\n                on: on,\n              })}\n            />\n            {timesClicked > 4 ? (\n              <div data-testid=\"notice\">\n                Whoa, you clicked too much!\n                <br />\n                <button onClick={() => toggle({ type: 'forced' })}>\n                  Force Toggle\n                </button>\n                <br />\n              </div>\n            ) : timesClicked > 0 ? (\n              <div data-testid=\"click-count\">Click count: {timesClicked}</div>\n            ) : null}\n            <button onClick={reset}>Reset</button>\n          </div>\n        )}\n      </Toggle>\n    );\n  }\n}\nUsage.title = 'State Reducers (with change types)';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("h2",{id:"control-props-primer"},"Control Props Primer"),Object(o.b)("p",null,"Here we are trying to get two completely different components to synchronous their state."),Object(o.b)("p",null,"The general idea is that the parent can control when to set things on for the children (here the children being two Switches)."),Object(o.b)("p",null,"This pattern is the same that is used for controlled form components. Think of the parent form controlling what shows in a child input."),Object(o.b)("p",null,"The idea is that a child will pass the local state change up, then child components will be rerendered by the change in the parent."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// control props primer\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\nclass Toggle extends React.Component {\n  state = { on: false };\n  // this is important to determine if the component is controlled\n  isOnControlled() {\n    return this.props.on !== undefined;\n  }\n  getState() {\n    return {\n      on: this.isOnControlled() ? this.props.on : this.state.on,\n    };\n  }\n  toggle = () => {\n    if (this.isOnControlled()) {\n      this.props.onToggle(!this.getState().on);\n    } else {\n      this.setState(\n        ({ on }) => ({ on: !on }),\n        () => {\n          this.props.onToggle(this.getState().on);\n        },\n      );\n    }\n  };\n  render() {\n    const { on } = this.getState();\n    return <Switch on={on} onClick={this.toggle} />;\n  }\n}\n\nclass Usage extends React.Component {\n  state = { bothOn: false };\n  handleToggle = on => {\n    this.setState({ bothOn: on });\n  };\n  render() {\n    const { bothOn } = this.state;\n    const { toggle1Ref, toggle2Ref } = this.props;\n    return (\n      <div>\n        <Toggle on={bothOn} onToggle={this.handleToggle} ref={toggle1Ref} />\n        <Toggle on={bothOn} onToggle={this.handleToggle} ref={toggle2Ref} />\n      </div>\n    );\n  }\n}\nUsage.title = 'Control Props (primer)';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("p",null,'A question about "why not use ',Object(o.b)("inlineCode",{parentName:"p"},"componentWillReceiveProps"),' or an non-deprecated equivalent?" - the main reason is to prevent having two sources of truth.'),Object(o.b)("h2",{id:"control-props"},"Control Props"),Object(o.b)("p",null,"Using this now with a state reducer. You can use this without one, but a state reducer is an easier way to help with control props. Having them together gives users more choice on how they want to use their component."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// Control Props + with a state reducer\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  // Now that a user can use this component effectively without\n  // an `onToggle` prop (they can use `onStateChange` instead)\n  // üê® let's provide a default for `onToggle` and `onStateChange`\n  static defaultProps = {\n    initialOn: false,\n    onReset: () => {},\n    onToggle: () => {},\n    onStateChange: () => {},\n    stateReducer: (state, changes) => changes,\n  };\n  static stateChangeTypes = {\n    reset: '__toggle_reset__',\n    toggle: '__toggle_toggle__',\n  };\n  initialState = { on: this.props.initialOn };\n  state = this.initialState;\n\n  // üê® let's add an `isControlled` method that accepts a state key\n  // (string) and returns true if the prop is controlled\n  // üí∞ this.props[prop] !== undefined\n  isControlled(prop) {\n    return this.props[prop] !== undefined;\n  }\n\n  // üê® We'll also need a `getState` method here that returns a\n  // state object that has state from both internal state (`this.state`)\n  // as well as external state (`this.props`).\n  getState(state = this.state) {\n    return Object.entries(state).reduce((combinedState, [key, value]) => {\n      if (this.isControlled(key)) {\n        combinedState[key] = this.props[key];\n      } else {\n        combinedState[key] = value;\n      }\n      return combinedState;\n    }, {});\n  }\n\n  // üí∞ You might consider accepting state as an argument that defaults\n  // to `this.state`... You'll use that later on...\n  internalSetState(changes, callback = () => {}) {\n    let allChanges;\n    this.setState(\n      state => {\n        // Now that our state can actually come from two sources,\n        // the `state` we receive from this function is actually only one\n        // side of the story.\n        // üê® Call your `this.getState` function with `state` so we can\n        // get a `combinedState` object which we'll use to perform our\n        // operations on here.\n        const combinedState = this.getState(state);\n        // handle function setState call\n        const changesObject =\n          typeof changes === 'function' ? changes(combinedState) : changes;\n\n        // apply state reducer\n        allChanges =\n          this.props.stateReducer(combinedState, changesObject) || {};\n\n        // remove the type so it's not set into state\n        const { type: ignoredType, ...onlyChanges } = allChanges;\n\n        const nonControlledChanges = Object.keys(combinedState).reduce(\n          (newChanges, stateKey) => {\n            if (!this.isControlled(stateKey)) {\n              newChanges[stateKey] = onlyChanges.hasOwnProperty(stateKey)\n                ? onlyChanges[stateKey]\n                : combinedState[stateKey];\n            }\n            return newChanges;\n          },\n          {},\n        );\n\n        // return null if there are no changes to be made\n        return Object.keys(nonControlledChanges || {}).length\n          ? nonControlledChanges\n          : null;\n      },\n      () => {\n        // call onStateChange with all the changes (including the type)\n        this.props.onStateChange(allChanges, this.getStateAndHelpers());\n        callback();\n      },\n    );\n  }\n  reset = () =>\n    this.internalSetState(\n      { ...this.initialState, type: Toggle.stateChangeTypes.reset },\n      () => this.props.onReset(this.getState().on),\n    );\n  toggle = ({ type = Toggle.stateChangeTypes.toggle } = {}) =>\n    this.internalSetState(\n      ({ on }) => ({ type, on: !on }),\n      () => this.props.onToggle(this.getState().on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    onClick: callAll(onClick, () => this.toggle()),\n    'aria-expanded': this.getState().on,\n    ...props,\n  });\n  getStateAndHelpers() {\n    return {\n      ...this.getState(),\n      toggle: this.toggle,\n      reset: this.reset,\n      getTogglerProps: this.getTogglerProps,\n    };\n  }\n  render() {\n    return this.props.children(this.getStateAndHelpers());\n  }\n}\n\nclass Usage extends React.Component {\n  static defaultProps = {\n    onToggle: (...args) => console.log('onToggle', ...args),\n    onReset: (...args) => console.log('onReset', ...args),\n  };\n  initialState = { timesClicked: 0, toggleOn: false };\n  state = this.initialState;\n  handleStateChange = changes => {\n    if (changes.type === 'forced') {\n      this.setState({ toggleOn: changes.on }, () =>\n        this.props.onToggle(this.state.toggleOn),\n      );\n    } else if (changes.type === Toggle.stateChangeTypes.reset) {\n      this.setState(this.initialState, () => {\n        this.props.onReset(this.state.toggleOn);\n      });\n    } else if (changes.type === Toggle.stateChangeTypes.toggle) {\n      this.setState(\n        ({ timesClicked }) => ({\n          timesClicked: timesClicked + 1,\n          toggleOn: timesClicked >= 4 ? false : changes.on,\n        }),\n        () => {\n          this.props.onToggle(this.state.toggleOn);\n        },\n      );\n    }\n  };\n  render() {\n    const { timesClicked, toggleOn } = this.state;\n    return (\n      <Toggle\n        on={toggleOn}\n        onStateChange={this.handleStateChange}\n        ref={this.props.toggleRef}\n      >\n        {({ on, toggle, reset, getTogglerProps }) => (\n          <div>\n            <Switch\n              {...getTogglerProps({\n                on: on,\n              })}\n            />\n            {timesClicked > 4 ? (\n              <div data-testid=\"notice\">\n                Whoa, you clicked too much!\n                <br />\n                <button onClick={() => toggle({ type: 'forced' })}>\n                  Force Toggle\n                </button>\n                <br />\n              </div>\n            ) : timesClicked > 0 ? (\n              <div data-testid=\"click-count\">Click count: {timesClicked}</div>\n            ) : null}\n            <button onClick={reset}>Reset</button>\n          </div>\n        )}\n      </Toggle>\n    );\n  }\n}\nUsage.title = 'Control Props with State Reducers';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("h2",{id:"provider-pattern"},"Provider Pattern"),Object(o.b)("p",null,"This pattern enables us to provide state without prop drilling."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// Provider Pattern\n\nimport React from 'react';\nimport { Switch } from '../switch';\n\nconst ToggleContext = React.createContext({\n  on: false,\n  toggle: () => {},\n  reset: () => {},\n  getTogglerProps: () => ({}),\n});\n\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  static defaultProps = {\n    initialOn: false,\n    onReset: () => {},\n    onToggle: () => {},\n    onStateChange: () => {},\n    stateReducer: (state, changes) => changes,\n  };\n  static stateChangeTypes = {\n    reset: '__toggle_reset__',\n    toggle: '__toggle_toggle__',\n  };\n  static Consumer = ToggleContext.Consumer;\n\n  reset = () =>\n    this.internalSetState(\n      { ...this.initialState, type: Toggle.stateChangeTypes.reset },\n      () => this.props.onReset(this.getState().on),\n    );\n  toggle = ({ type = Toggle.stateChangeTypes.toggle } = {}) =>\n    this.internalSetState(\n      ({ on }) => ({ type, on: !on }),\n      () => this.props.onToggle(this.getState().on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    onClick: callAll(onClick, () => this.toggle()),\n    'aria-expanded': this.getState().on,\n    ...props,\n  });\n  initialState = {\n    on: this.props.initialOn,\n    toggle: this.toggle,\n    reset: this.reset,\n    getTogglerProps: this.getTogglerProps,\n  };\n  state = this.initialState;\n  isControlled(prop) {\n    return this.props[prop] !== undefined;\n  }\n  getState(state = this.state) {\n    return Object.entries(state).reduce((combinedState, [key, value]) => {\n      if (this.isControlled(key)) {\n        combinedState[key] = this.props[key];\n      } else {\n        combinedState[key] = value;\n      }\n      return combinedState;\n    }, {});\n  }\n  internalSetState(changes, callback = () => {}) {\n    let allChanges;\n    this.setState(\n      state => {\n        const combinedState = this.getState(state);\n        // handle function setState call\n        const changesObject =\n          typeof changes === 'function' ? changes(combinedState) : changes;\n\n        // apply state reducer\n        allChanges =\n          this.props.stateReducer(combinedState, changesObject) || {};\n\n        // remove the type so it's not set into state\n        const { type: ignoredType, ...onlyChanges } = allChanges;\n\n        const nonControlledChanges = Object.keys(combinedState).reduce(\n          (newChanges, stateKey) => {\n            if (!this.isControlled(stateKey)) {\n              newChanges[stateKey] = onlyChanges.hasOwnProperty(stateKey)\n                ? onlyChanges[stateKey]\n                : combinedState[stateKey];\n            }\n            return newChanges;\n          },\n          {},\n        );\n\n        // return null if there are no changes to be made\n        return Object.keys(nonControlledChanges || {}).length\n          ? nonControlledChanges\n          : null;\n      },\n      () => {\n        // call onStateChange with all the changes (including the type)\n        this.props.onStateChange(allChanges, this.state);\n        callback();\n      },\n    );\n  }\n  render() {\n    // here's all you need to do for your solution\n    // return (\n    //   <ToggleContext.Provider value={this.state}>\n    //     {this.props.children}\n    //   </ToggleContext.Provider>\n    // )\n    // here's the bonus material solution that preserves the old API:\n    const { children } = this.props;\n    const ui = typeof children === 'function' ? children(this.state) : children;\n    return (\n      <ToggleContext.Provider value={this.state}>{ui}</ToggleContext.Provider>\n    );\n  }\n}\n\nfunction Nav() {\n  return (\n    <Toggle.Consumer>\n      {toggle => (\n        <nav>\n          <ul>\n            <li>\n              <a href=\"index.html\">{toggle.on ? 'üè°' : 'Home'}</a>\n            </li>\n            <li>\n              <a href=\"/about/\">{toggle.on ? '‚ùì' : 'About'}</a>\n            </li>\n            <li>\n              <a href=\"/blog/\">{toggle.on ? 'üìñ' : 'Blog'}</a>\n            </li>\n          </ul>\n        </nav>\n      )}\n    </Toggle.Consumer>\n  );\n}\n\nfunction NavSwitch() {\n  return (\n    <div className=\"nav-switch\">\n      <div>\n        <Toggle.Consumer>\n          {toggle => (toggle.on ? 'ü¶Ñ' : 'Enable Emoji')}\n        </Toggle.Consumer>\n      </div>\n      <Toggle.Consumer>\n        {toggle => (\n          <Switch\n            {...toggle.getTogglerProps({\n              on: toggle.on,\n            })}\n          />\n        )}\n      </Toggle.Consumer>\n    </div>\n  );\n}\n\nfunction Header() {\n  return (\n    <div className=\"header\">\n      <Nav />\n      <NavSwitch />\n    </div>\n  );\n}\n\nfunction Subtitle() {\n  return (\n    <Toggle.Consumer>\n      {toggle => (toggle.on ? 'üë©‚Äçüè´ üëâ üï∂' : 'Teachers are awesome')}\n    </Toggle.Consumer>\n  );\n}\n\nfunction Title() {\n  return (\n    <div>\n      <h1>\n        <Toggle.Consumer>\n          {toggle => `Who is ${toggle.on ? 'üï∂‚ùì' : 'awesome?'}`}\n        </Toggle.Consumer>\n      </h1>\n      <Subtitle />\n    </div>\n  );\n}\n\nfunction Article() {\n  return (\n    <div>\n      <Toggle.Consumer>\n        {toggle =>\n          [\n            'Once, I was in',\n            toggle.on ? 'üè´‚Äç' : 'school',\n            'when I',\n            toggle.on ? 'ü§î' : 'realized',\n            'something...',\n          ].join(' ')\n        }\n      </Toggle.Consumer>\n      <hr />\n      <Toggle.Consumer>\n        {toggle =>\n          [\n            'Without',\n            toggle.on ? 'üë©‚Äçüè´' : 'teachers',\n            `I wouldn't know anything so`,\n            toggle.on ? 'üôè' : 'thanks',\n            toggle.on ? 'üë©‚Äçüè´‚ùóÔ∏è' : 'teachers!',\n          ].join(' ')\n        }\n      </Toggle.Consumer>\n    </div>\n  );\n}\n\nfunction Post() {\n  return (\n    <div>\n      <Title />\n      <Article />\n    </div>\n  );\n}\n\nfunction Usage() {\n  return (\n    <Toggle>\n      <div className=\"friends\">\n        <Header />\n        <Post />\n      </div>\n    </Toggle>\n  );\n}\nUsage.title = 'Provider Pattern';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("h2",{id:"higher-order-components"},"Higher Order Components"),Object(o.b)("p",null,"Getting sick of ",Object(o.b)("inlineCode",{parentName:"p"},"<Toggle.Consumer>")," is an example where HOCs can come in handy."),Object(o.b)("p",null,"HOCs give you back a component, while ",Object(o.b)("inlineCode",{parentName:"p"},"Render Props")," gives you more flexibility. This example uses a HOC over a Render Prop component. Kent says he cannot think of an example of using a HOC without Render Prop."),Object(o.b)("p",null,"This example uses the ",Object(o.b)("inlineCode",{parentName:"p"},"hoist-non-react-statics")," library that you can see ",Object(o.b)("a",a({parentName:"p"},{href:"https://github.com/mridgway/hoist-non-react-statics"}),"here"),"."),Object(o.b)("p",null,"We also want to make sure that we are forwarding on the refs so the HOC is unobservable to users."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// Higher Order Components\n\nimport React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { Switch } from '../switch';\n\nconst ToggleContext = React.createContext({\n  on: false,\n  toggle: () => {},\n  reset: () => {},\n  getTogglerProps: () => ({}),\n});\n\nconst callAll = (...fns) => (...args) => fns.forEach(fn => fn && fn(...args));\n\nclass Toggle extends React.Component {\n  static defaultProps = {\n    initialOn: false,\n    onReset: () => {},\n    onToggle: () => {},\n    onStateChange: () => {},\n    stateReducer: (state, changes) => changes,\n  };\n  static stateChangeTypes = {\n    reset: '__toggle_reset__',\n    toggle: '__toggle_toggle__',\n  };\n  static Consumer = ToggleContext.Consumer;\n\n  reset = () =>\n    this.internalSetState(\n      { ...this.initialState, type: Toggle.stateChangeTypes.reset },\n      () => this.props.onReset(this.getState().on),\n    );\n  toggle = ({ type = Toggle.stateChangeTypes.toggle } = {}) =>\n    this.internalSetState(\n      ({ on }) => ({ type, on: !on }),\n      () => this.props.onToggle(this.getState().on),\n    );\n  getTogglerProps = ({ onClick, ...props } = {}) => ({\n    onClick: callAll(onClick, () => this.toggle()),\n    'aria-expanded': this.getState().on,\n    ...props,\n  });\n  initialState = {\n    on: this.props.initialOn,\n    toggle: this.toggle,\n    reset: this.reset,\n    getTogglerProps: this.getTogglerProps,\n  };\n  state = this.initialState;\n  isControlled(prop) {\n    return this.props[prop] !== undefined;\n  }\n  getState(state = this.state) {\n    return Object.entries(state).reduce((combinedState, [key, value]) => {\n      if (this.isControlled(key)) {\n        combinedState[key] = this.props[key];\n      } else {\n        combinedState[key] = value;\n      }\n      return combinedState;\n    }, {});\n  }\n  internalSetState(changes, callback = () => {}) {\n    let allChanges;\n    this.setState(\n      state => {\n        const combinedState = this.getState(state);\n        // handle function setState call\n        const changesObject =\n          typeof changes === 'function' ? changes(combinedState) : changes;\n\n        // apply state reducer\n        allChanges =\n          this.props.stateReducer(combinedState, changesObject) || {};\n\n        // remove the type so it's not set into state\n        const { type: ignoredType, ...onlyChanges } = allChanges;\n\n        const nonControlledChanges = Object.keys(combinedState).reduce(\n          (newChanges, stateKey) => {\n            if (!this.isControlled(stateKey)) {\n              newChanges[stateKey] = onlyChanges.hasOwnProperty(stateKey)\n                ? onlyChanges[stateKey]\n                : combinedState[stateKey];\n            }\n            return newChanges;\n          },\n          {},\n        );\n\n        // return null if there are no changes to be made\n        return Object.keys(nonControlledChanges || {}).length\n          ? nonControlledChanges\n          : null;\n      },\n      () => {\n        // call onStateChange with all the changes (including the type)\n        this.props.onStateChange(allChanges, this.state);\n        callback();\n      },\n    );\n  }\n  render() {\n    const { children } = this.props;\n    const ui = typeof children === 'function' ? children(this.state) : children;\n    return (\n      <ToggleContext.Provider value={this.state}>{ui}</ToggleContext.Provider>\n    );\n  }\n}\n\nfunction withToggle(Component) {\n  function Wrapper(props, ref) {\n    return (\n      <Toggle.Consumer>\n        {toggleContext => (\n          <Component {...props} toggle={toggleContext} ref={ref} />\n        )}\n      </Toggle.Consumer>\n    );\n  }\n  Wrapper.displayName = `withToggle(${Component.displayName ||\n    Component.name})`;\n  return hoistNonReactStatics(React.forwardRef(Wrapper), Component);\n}\n\n// this Subtitle component could be as simple as:\n// const Subtitle = withToggle(({toggle: {on}}) => (\n//   <span>{on ? 'üë©‚Äçüè´ üëâ üï∂' : 'Teachers are awesome'}</span>\n// ))\n// But for the purposes of this workshop, we've made it a little more complex\n// just to ensure you're HOC handles common issues with HOCs\nconst Subtitle = withToggle(\n  class extends React.Component {\n    static displayName = 'Subtitle';\n    static emoji = 'üë©‚Äçüè´ üëâ üï∂';\n    static text = 'Teachers are awesome';\n    instanceProperty = true;\n    render() {\n      return (\n        <span>{this.props.toggle.on ? Subtitle.emoji : Subtitle.text}</span>\n      );\n    }\n  },\n);\n\nfunction Nav() {\n  return (\n    <Toggle.Consumer>\n      {toggle => (\n        <nav>\n          <ul>\n            <li>\n              <a href=\"index.html\">{toggle.on ? 'üè°' : 'Home'}</a>\n            </li>\n            <li>\n              <a href=\"/about/\">{toggle.on ? '‚ùì' : 'About'}</a>\n            </li>\n            <li>\n              <a href=\"/blog/\">{toggle.on ? 'üìñ' : 'Blog'}</a>\n            </li>\n          </ul>\n        </nav>\n      )}\n    </Toggle.Consumer>\n  );\n}\n\nfunction NavSwitch() {\n  return (\n    <div className=\"nav-switch\">\n      <div>\n        <Toggle.Consumer>\n          {toggle => (toggle.on ? 'ü¶Ñ' : 'Enable Emoji')}\n        </Toggle.Consumer>\n      </div>\n      <Toggle.Consumer>\n        {toggle => (\n          <Switch\n            {...toggle.getTogglerProps({\n              on: toggle.on,\n            })}\n          />\n        )}\n      </Toggle.Consumer>\n    </div>\n  );\n}\n\nfunction Header() {\n  return (\n    <div className=\"header\">\n      <Nav />\n      <NavSwitch />\n    </div>\n  );\n}\n\n// This is part of our contrived example so we can test things properly\n// to make sure your HOC handles common issues\nexport class Debug extends React.Component {\n  childInstance = React.createRef();\n  render() {\n    return React.cloneElement(this.props.children, {\n      ref: this.childInstance,\n    });\n  }\n}\n\nfunction Title() {\n  return (\n    <div>\n      <h1>\n        <Toggle.Consumer>\n          {toggle => `Who is ${toggle.on ? 'üï∂‚ùì' : 'awesome?'}`}\n        </Toggle.Consumer>\n      </h1>\n      <Debug child=\"subtitle\">\n        <Subtitle />\n      </Debug>\n    </div>\n  );\n}\n\nfunction Article() {\n  return (\n    <div>\n      <Toggle.Consumer>\n        {toggle =>\n          [\n            'Once, I was in',\n            toggle.on ? 'üè´‚Äç' : 'school',\n            'when I',\n            toggle.on ? 'ü§î' : 'realized',\n            'something...',\n          ].join(' ')\n        }\n      </Toggle.Consumer>\n      <hr />\n      <Toggle.Consumer>\n        {toggle =>\n          [\n            'Without',\n            toggle.on ? 'üë©‚Äçüè´' : 'teachers',\n            `I wouldn't know anything so`,\n            toggle.on ? 'üôè' : 'thanks',\n            toggle.on ? 'üë©‚Äçüè´‚ùóÔ∏è' : 'teachers!',\n          ].join(' ')\n        }\n      </Toggle.Consumer>\n    </div>\n  );\n}\n\nfunction Post() {\n  return (\n    <div>\n      <Title />\n      <Article />\n    </div>\n  );\n}\n\nfunction Usage() {\n  return (\n    <Toggle>\n      <div className=\"friends\">\n        <Header />\n        <Post />\n      </div>\n    </Toggle>\n  );\n}\nUsage.title = 'Higher Order Components';\n\nexport { Toggle, Usage as default };\n")),Object(o.b)("h2",{id:"rendex"},"Rendex"),Object(o.b)("p",null,"Rendex is a bonus where we use both React's context API and Redux together."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-javascript"}),"// Rendux\n\nimport React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport * as redux from 'redux';\nimport { Switch } from '../switch';\n\nconst RenduxContext = React.createContext({});\n\nclass Rendux extends React.Component {\n  static Consumer = RenduxContext.Consumer;\n  static defaultProps = {\n    initialState: {},\n    reducer: state => state,\n  };\n  initialReduxState = this.props.initialState;\n  rootReducer = (state, action) => {\n    if (action.type === '__RENDUX_RESET__') {\n      return this.initialReduxState;\n    }\n    return this.props.reducer(state, action);\n  };\n  store = redux.createStore(this.rootReducer, this.initialReduxState);\n  reset = () => {\n    this.store.dispatch({\n      type: '__RENDUX_RESET__',\n    });\n  };\n  componentDidMount() {\n    this.unsubscribe = this.store.subscribe(() =>\n      this.setState({\n        state: this.store.getState(),\n      }),\n    );\n  }\n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n  initialState = {\n    state: this.props.initialState,\n    dispatch: this.store.dispatch,\n    reset: this.reset,\n  };\n  state = this.initialState;\n  render() {\n    const { children } = this.props;\n    const ui = typeof children === 'function' ? children(this.state) : children;\n    return (\n      <RenduxContext.Provider value={this.state}>{ui}</RenduxContext.Provider>\n    );\n  }\n}\n\nfunction withRendux(Component) {\n  class Wrapper extends React.Component {\n    render() {\n      const { forwardedRef, ...rest } = this.props;\n      return (\n        <Rendux.Consumer>\n          {rendux => <Component {...rest} rendux={rendux} ref={forwardedRef} />}\n        </Rendux.Consumer>\n      );\n    }\n  }\n  Wrapper.displayName = `withRendux(${Component.displayName ||\n    Component.name})`;\n  const forwardRef = React.forwardRef((props, ref) => (\n    <Wrapper {...props} forwardedRef={ref} />\n  ));\n  return hoistNonReactStatics(forwardRef, Component);\n}\n\nfunction MyInput() {\n  return (\n    <Rendux.Consumer>\n      {rendux => (\n        <input\n          value={rendux.state.inputValue || (rendux.state.on ? 'on' : 'off')}\n          placeholder=\"Type 'off' or 'on'\"\n          onChange={event => {\n            if (event.target.value === 'on') {\n              rendux.dispatch({\n                type: 'toggle',\n                value: true,\n              });\n            } else if (event.target.value === 'off') {\n              rendux.dispatch({\n                type: 'toggle',\n                value: false,\n              });\n            }\n            rendux.dispatch({\n              type: 'input_change',\n              value: event.target.value,\n            });\n          }}\n          onBlur={event => {\n            const { value } = event.target;\n            if (value !== 'on' && value !== 'off') {\n              rendux.dispatch({\n                type: 'input_change',\n                value: rendux.state.on ? 'on' : 'off',\n              });\n            }\n          }}\n        />\n      )}\n    </Rendux.Consumer>\n  );\n}\n\nfunction MySwitch() {\n  return (\n    <Rendux.Consumer>\n      {rendux => (\n        <div\n          style={{\n            marginTop: 20,\n            marginBottom: 20,\n          }}\n        >\n          <Switch\n            on={rendux.state.on}\n            onClick={() => {\n              rendux.dispatch({\n                type: 'toggle',\n                value: !rendux.state.on,\n              });\n\n              if (rendux.state.inputValue) {\n                rendux.dispatch({\n                  type: 'input_change',\n                  value: !rendux.state.on ? 'on' : 'off',\n                });\n              }\n            }}\n          />\n        </div>\n      )}\n    </Rendux.Consumer>\n  );\n}\n\nconst StatePrinter = withRendux(function StatePrinter({ rendux }) {\n  return (\n    <div style={{ textAlign: 'left' }}>\n      state:\n      <pre data-testid=\"printed-state\">\n        {JSON.stringify(rendux.state, null, 2)}\n      </pre>\n    </div>\n  );\n});\n\nfunction Usage() {\n  return (\n    <Rendux\n      initialState={{ on: true }}\n      reducer={(state, action) => {\n        switch (action.type) {\n          case 'toggle':\n            return {\n              ...state,\n              on: action.value,\n            };\n          case 'input_change':\n            return {\n              ...state,\n              inputValue: action.value,\n            };\n          default:\n            return state;\n        }\n      }}\n    >\n      {({ reset }) => (\n        <React.Fragment>\n          <MyInput />\n          <MySwitch />\n          <button onClick={reset}>reset</button>\n          <StatePrinter />\n        </React.Fragment>\n      )}\n    </Rendux>\n  );\n}\nUsage.title = 'Bonus: Rendux';\n\nexport { Rendux, Usage, Usage as default };\n")))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/React/Advanced-React-Patterns.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-react-advanced-react-patterns-md-091997fc78a51985453c.js.map