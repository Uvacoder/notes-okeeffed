{"version":3,"sources":["webpack:///../manual/Haskell/HackerRank-Notes.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"sfAMO,IAAMA,EAAe,Q,oNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,oBADR,oBAGA,iBAAQ,CACN,GAAM,eADR,iBAGA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,qBADZ,mQAWL,iBAAQ,CACN,GAAM,sBADR,wBAGA,2DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,2iBA6BL,iBAAQ,CACN,GAAM,0BADR,0BAGA,wCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,iBAOL,uCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,mBADZ,gCAYL,gCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,2TAYL,iBAAQ,CACN,GAAM,yBADR,yBAGA,sEAAqD,0BAAYA,WAAW,KAAvB,KAArD,oCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,+V,2MAmBTJ,EAAWK,gBAAiB","file":"component---manual-haskell-hacker-rank-notes-md-3be42744b44517571362.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"hackerrank-notes\"\n    }}>{`HackerRank Notes`}</h1>\n    <h2 {...{\n      \"id\": \"hello-world\"\n    }}>{`Hello, World!`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- Enter your code here. Read input from STDIN. Print output to STDOUT\nhello_world :: IO()\nhello_world = putStrLn \"Hello World\"\n\n\n-- This part relates to Input/Output and can be used as it is. Do not modify this section\nmain = do\n    hello_world\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"looped-hello-world\"\n    }}>{`Looped Hello, World!`}</h2>\n    <p>{`Haskell uses recursion, not loops:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`{-# LANGUAGE FlexibleInstances, UndecidableInstances, DuplicateRecordFields #-}\n\nmodule Main where\n\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport Data.List\nimport Data.List.Split\nimport Data.Set\nimport Debug.Trace\nimport System.Environment\nimport System.IO\nimport System.IO.Unsafe\n\nprintNTimes n\n    | n == 1        = putStrLn \"Hello World\"\n    | otherwise     =\n        do\n            putStrLn \"Hello World\"\n            printNTimes (n-1)\n\nmain :: IO()\nmain = do\n    n <- readLn :: IO Int\n    printNTimes n\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"print-a-number-n-times\"\n    }}>{`Print a number n times`}</h2>\n    <p>{`Based on input:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`3\n1\n2\n3\n`}</code></pre>\n    <p>{`Expect to get:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`1\n1\n1\n2\n2\n2\n3\n3\n3\n`}</code></pre>\n    <p>{`Answer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`f :: Int -> [Int] -> [Int]\nf n arr = -- Complete this function\n    do\n        [num | num <- arr, _ <- [1..n]]\n\n-- This part handles the Input and Output and can be used as it is. Do not modify this part.\nmain :: IO ()\nmain = getContents >>=\n       mapM_ print. (\\\\(n:arr) -> f n arr). map read. words\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"write-your-own-filter\"\n    }}>{`Write your own filter`}</h2>\n    <p>{`Write a filter function where given delimiter `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` you return all numbers smaller.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`f :: Int -> [Int] -> [Int]\nf n arr =\n    do\n        [num | num <- arr, num < n]\n\n-- The Input/Output section. You do not need to change or modify this part\nmain = do\n    n <- readLn :: IO Int\n    inputdata <- getContents\n    let\n        numbers = map read (lines inputdata) :: [Int]\n    putStrLn . unlines $ (map show . f n) numbers\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}