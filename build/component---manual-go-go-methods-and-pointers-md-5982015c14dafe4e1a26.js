(window.webpackJsonp=window.webpackJsonp||[]).push([[236],{EhxW:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return p}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var a=t("/FXl"),r=t("TjRS");t("aD51");function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Go/Go-Methods-And-Pointers.md"}});var l={_frontmatter:i},c=r.a;function p(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(a.b)(c,o({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"go-tour-methods--pointer-indirection"},"Go Tour Methods & Pointer Indirection"),Object(a.b)("p",null,"Take the following code:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-golang"}),'package main\n\nimport "fmt"\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n    v.X = v.X * f\n    v.Y = v.Y * f\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    v.Scale(2)\n    ScaleFunc(&v, 10)\n\n    p := &Vertex{4, 3}\n    p.Scale(3)\n    ScaleFunc(p, 8)\n\n    fmt.Println(v, p)\n}\n')),Object(a.b)("p",null,"Comparing the previous two programs, you might notice that functions with a pointer argument must take a pointer:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nScaleFunc(v, 5)  // Compile error!\nScaleFunc(&v, 5) // OK\n")),Object(a.b)("p",null,"While methods with pointer receivers take either a value or a pointer as the receiver when they are called:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n")),Object(a.b)("p",null,"For the statement ",Object(a.b)("inlineCode",{parentName:"p"},"v.Scale(5)"),", even though v is a value and not a pointer, the method with the pointer receiver is called automatically. That is, as a convenience, Go interprets the statement ",Object(a.b)("inlineCode",{parentName:"p"},"v.Scale(5)")," as ",Object(a.b)("inlineCode",{parentName:"p"},"(&v).Scale(5)")," since the Scale method has a pointer receiver."),Object(a.b)("h2",{id:"reverse-direction"},"Reverse direction"),Object(a.b)("p",null,"The equivalent thing happens in the reverse direction."),Object(a.b)("p",null,"Take the following code:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-golang"}),'package main\n\nimport (\n    "fmt"\n    "math"\n)\n\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n    v := Vertex{3, 4}\n    fmt.Println(v.Abs())\n    fmt.Println(AbsFunc(v))\n\n    p := &Vertex{4, 3}\n    fmt.Println(p.Abs())\n    fmt.Println(AbsFunc(*p))\n}\n')),Object(a.b)("p",null,"Functions that take a value argument must take a value of that specific type:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // Compile error!\n")),Object(a.b)("p",null,"While methods with value receivers take either a value or a pointer as the receiver when they are called:"),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-golang"}),"var v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n")),Object(a.b)("p",null,"In this case, the method call ",Object(a.b)("inlineCode",{parentName:"p"},"p.Abs()")," is interpreted as ",Object(a.b)("inlineCode",{parentName:"p"},"(\\*p).Abs()"),"."),Object(a.b)("h1",{id:"choosing-a-value-or-pointer-receiver"},"Choosing a value or pointer receiver"),Object(a.b)("p",null,"There are two reasons to use a pointer receiver."),Object(a.b)("p",null,"The first is so that ",Object(a.b)("strong",{parentName:"p"},"the method can modify the value that its receiver points to"),"."),Object(a.b)("p",null,"The second is ",Object(a.b)("strong",{parentName:"p"},"to avoid copying the value on each method call"),". This can be more efficient if the receiver is a large struct, for example."),Object(a.b)("p",null,"In this example, both ",Object(a.b)("inlineCode",{parentName:"p"},"Scale")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Abs")," are with receiver type ",Object(a.b)("inlineCode",{parentName:"p"},"*Vertex"),", even though the Abs method needn't modify its receiver."),Object(a.b)("p",null,"In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both. (We'll see why over the next few pages.)"))}p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Go/Go-Methods-And-Pointers.md"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-go-go-methods-and-pointers-md-5982015c14dafe4e1a26.js.map