{"version":3,"sources":["webpack:///../manual/Epic-React/force-rerender-without-memoization.png","webpack:///../manual/Epic-React/React-Performance.md","webpack:///../manual/Epic-React/force-rerender-with-memoization.png"],"names":["module","exports","_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","alt","src","require","isMDXComponent"],"mappings":"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","file":"component---manual-epic-react-react-performance-md-3e1102fef604cd39d864.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/force-rerender-without-memoization-80ee0f7831f420c5cf03b9736292b59e.png\";","import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"react-performance\"\n    }}>{`React Performance`}</h1>\n    <p>{`React in general is fast. That being said, there are tools to help aid us when we need those tools to help optimize particular scenarios.`}</p>\n    <p>{`What is important is to know what tool to grab at the appropriate time.`}</p>\n    <h2 {...{\n      \"id\": \"code-splitting\"\n    }}>{`Code Splitting`}</h2>\n    <p>{`The single, biggest impact you can have on your performance. It will help lazily load code when required.`}</p>\n    <p>{`In this first example, we simple used `}<inlineCode parentName=\"p\">{`React.lazy`}</inlineCode>{` to lazy import a file and then used the `}<inlineCode parentName=\"p\">{`Suspense`}</inlineCode>{` library to handle the fallback.`}</p>\n    <p>{`What is important to do to test and see the visual changes:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Check the network tab`}</li>\n      <li parentName=\"ol\">{`Check the coverage tab`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// üí£ remove this import\n\n// üê® use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(() => import('../globe'));\n\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // üê® wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // üí∞ try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// ü¶â Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"eager-loading\"\n    }}>{`Eager Loading`}</h3>\n    <p>{`Given a certain \"indication\" that a user may click, we can load earlier.`}</p>\n    <p>{`We can enter a `}<inlineCode parentName=\"p\">{`onMouseEnter`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`onFocus`}</inlineCode>{` to fire an eager import:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// üí£ remove this import\n\nconst loadGlobe = () => import('../globe');\n// üê® use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(loadGlobe);\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // üê® wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // üí∞ try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n          onMouseEnter={loadGlobe}\n          onFocus={loadGlobe}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// ü¶â Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"webpack-magic-comments\"\n    }}>{`Webpack Magic Comments`}</h3>\n    <p>{`A comment like the following will allow you to start pre-fetching some other resources. Webpack has an API for you to hook into.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import(/* webpackPrefetch: true */ './some-module.js');\n`}</code></pre>\n    <p>{`You can confirm this prefetch work based on what shows in the elements tab under the `}<inlineCode parentName=\"p\">{`head`}</inlineCode>{` tag to see the prefetch links have been added.`}</p>\n    <h3 {...{\n      \"id\": \"suspense-position\"\n    }}>{`Suspense Position`}</h3>\n    <p>{`In future React, there will be some implications for React Suspense for when it is mounted as opposed to updated.`}</p>\n    <p>{`It is also very important for the position of your Suspense tool to be correct.`}</p>\n    <p>{`There is also the capability to click a button to \"suspend\" the component and see what is looks like from the React DevTools.`}</p>\n    <h3 {...{\n      \"id\": \"understanding-the-coverage-report\"\n    }}>{`Understanding the coverage report`}</h3>\n    <p>{`When you check the coverage of the before and after, you see there are less files in the after and a significant amount of savings.`}</p>\n    <p>{`Clicking on the individual files also shows you chunks with lines that have and have not been used.`}</p>\n    <h2 {...{\n      \"id\": \"usememo\"\n    }}>{`useMemo`}</h2>\n    <p><inlineCode parentName=\"p\">{`useMemo`}</inlineCode>{` is the hero you need for expensive calculations and how the API works.`}</p>\n    <p>{`The example shows a massive list that should not recalculate with the same input value:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// useMemo for expensive calculations\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../filter-cities';\nimport { useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  // üê® wrap getItems in a call to \\`React.useMemo\\`\n  const allItems = React.useMemo(() => getItems(inputValue), [inputValue]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"using-a-web-worker\"\n    }}>{`Using a Web Worker`}</h3>\n    <p>{`There is information about this more `}<a parentName=\"p\" {...{\n        \"href\": \"https://kentcdodds.com/blog/speed-up-your-app-with-web-workers\"\n      }}>{`on Kent's blog`}</a>{`.`}</p>\n    <p>{`There is a `}<inlineCode parentName=\"p\">{`workerize`}</inlineCode>{` Webpack loader that can be used with Webpack that helps this process.`}</p>\n    <h2 {...{\n      \"id\": \"reactmemo\"\n    }}>{`React.memo`}</h2>\n    <p>{`The lifecycle of a React app goes `}<inlineCode parentName=\"p\">{`render -> reconciliation -> commit -> state change -> repeat`}</inlineCode>{`.`}</p>\n    <p>{`React is fast at doing this, but sometimes it needs help for Performance.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: you should fix slow renders before you fix re-renders.`}</p>\n    </blockquote>\n    <p>{`In the React DevTools profile, you can shift through each \"commit\" on the top \"bar chart\". We can rectify some of these issues using `}<inlineCode parentName=\"p\">{`pureComponent`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`memo`}</inlineCode>{`.`}</p>\n    <p>{`We seriously improved the experience with this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// üê® Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// üê® Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"custom-comparator\"\n    }}>{`Custom Comparator`}</h3>\n    <p>{`We can create a custom comparator to define when we should re-render.`}</p>\n    <p>{`In the above, you may notice that highlighting a component is forcing all items to re-render.`}</p>\n    <p>{`We can get around this using a custom comparator in `}<inlineCode parentName=\"p\">{`React.memo`}</inlineCode>{` as the second argument for the `}<inlineCode parentName=\"p\">{`ListItem`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// üê® Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// üê® Memoize the ListItem here using React.memo and use Domain Specific Knowledge\n// to help React know when it should trigger a re-render.\nListItem = React.memo(ListItem, (prevProps, nextProps) => {\n  if (prevProps.getItemProps !== nextProps.getItemProps) return false;\n  if (prevProps.items !== nextProps.items) return false;\n  if (prevProps.index !== nextProps.index) return false;\n  if (prevProps.selectItem !== nextProps.selectItem) return false;\n\n  if (prevProps.highlightedIndex !== nextProps.highlightedIndex) {\n    const wasPrevHighlighed = prevProps.highlightedIndex === prevProps.index;\n    const isNowHighlighted = nextProps.highlightedIndex === nextProps.index;\n\n    return wasPrevHighlighed === isNowHighlighted;\n  }\n\n  return true;\n});\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"primitive-values\"\n    }}>{`Primitive values`}</h3>\n    <p>{`Here we want to reduce the size of the custom comparator by only passing primitive values.`}</p>\n    <p>{`Now that we are passing primities, we don't need our custom comparator!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          isSelected={selectedItem?.id === item.id}\n          isHighlighted={highlightedIndex === index}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// üê® Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isSelected,\n  isHighlighted,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// üê® Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"window-large-lists-with-react-virtual\"\n    }}>{`Window Large Lists with react-virtual`}</h2>\n    <p>{`This updates an incredibly large list to use react-virtual which can make a `}<inlineCode parentName=\"p\">{`ul`}</inlineCode>{` absolute and then we use a custom styled `}<inlineCode parentName=\"p\">{`li`}</inlineCode>{` in addition to the list item to provide the items:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Window large lists with react-virtual\n// http://localhost:3000/isolated/exercise/04.js\n\nimport * as React from 'react';\n// üê® import the useVirtual hook from react-virtual\nimport { useVirtual } from 'react-virtual';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\n// üí∞ I made this for you, you'll need it later:\nconst getVirtualRowStyles = ({ size, start }) => ({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: size,\n  transform: \\`translateY(\\${start}px)\\`,\n});\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n  // üê® accept listRef, virtualRows, totalHeight\n  listRef,\n  virtualRows,\n  totalHeight,\n}) {\n  return (\n    // üê® pass the listRef to the \\`getMenuProps\\` prop getter function below:\n    // üí∞  getMenuProps({ref: listRef})\n    <ul {...getMenuProps({ ref: listRef })}>\n      {/* üê® add a li here with an inline style for the height set to the totalHeight */}\n      <li style={{ height: totalHeight }} />\n      {/*\n        ü¶â this is to ensure that the scrollable area of the <ul /> is the\n        same height it would be if we were actually rendering everything\n      */}\n      {/* instead of mapping the \"items\" we're going to map over the virtualRows */}\n      {/* üê® swap \\`items\\` with \\`virtualRows\\` */}\n      {/*\n        üí∞ a virtual row is an object with the following properties:\n        - index: you can use this to get the \\`item\\` via \\`items[index]\\`\n        - size: set the \"height\" style to this value\n        - start: this is how many pixels from the scrollTop this item should be\n      */}\n      {virtualRows.map(({ index, size, start }) => {\n        const item = items[index];\n        return (\n          <ListItem\n            key={item.id}\n            getItemProps={getItemProps}\n            item={item}\n            index={index}\n            isSelected={selectedItem?.id === item.id}\n            isHighlighted={highlightedIndex === index}\n            // üê® pass a style prop, you can get the inline styles from getVirtualRowStyles()\n            // make sure to pass an object with the size (the height of the row)\n            // and start (where the row starts relative to the scrollTop of its container).\n            style={getVirtualRowStyles({ size, start })}\n          >\n            {item.name}\n          </ListItem>\n        );\n      })}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isHighlighted,\n  isSelected,\n  // üê® accept the style prop\n  style,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n          fontWeight: isSelected ? 'bold' : 'normal',\n          // üê® spread the incoming styles onto this inline style object\n          ...style,\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: items, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n\n  // üê® create a listRef with React.useRef\n  // which will be used for the parentRef option you pass to useVirtual\n  // and should be applied to the <ul /> for our menu. This is how react-virtual\n  // knows how to scroll our items as the user scrolls.\n  const listRef = React.useRef();\n\n  // üê® call useVirtual with the following configuration options:\n  // - size (the number of items)\n  // - parentRef (the listRef you created above)\n  // - estimateSize (a memoized callback function that returns the size for each item)\n  //   üí∞ in our case, every item has the same size, so this will do: React.useCallback(() => 20, [])\n  // - overscan (the number of additional rows to render outside the scrollable view)\n  //   üí∞ You can play around with that number, but you probably don't need more than 10.\n  // üê® you can set the return value of your useVirtual call to \\`rowVirtualizer\\`\n  const rowVirtualizer = useVirtual({\n    size: items.length,\n    parentRef: listRef,\n    estimateSize: React.useCallback(() => 20, []),\n    overscan: 10,\n  });\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n    // we want to override Downshift's scrollIntoView functionality because\n    // react-virtual will handle scrolling for us:\n    // üê® set scrollIntoView to a \"no-op\" function\n    // üí∞ scrollIntoView: () => {},\n    scrollIntoView: () => {},\n    // üê® when the highlightedIndex changes, then tell react-virtual to scroll\n    // to that index.\n    // üí∞ onHighlightedIndexChange: ({highlightedIndex}) => highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n    onHighlightedIndexChange: ({ highlightedIndex }) =>\n      highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n          // üê® pass the following props:\n          listRef={listRef}\n          virtualRows={rowVirtualizer.virtualItems}\n          totalHeight={rowVirtualizer.totalSize}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"optimize-context-value\"\n    }}>{`Optimize Context Value`}</h2>\n    <p>{`In this challenge, we are memoizing the value we are passing as the value to the Context Provider.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`\"The way that context works is that whenever the provided value changes from one render to another, it triggers a re-render of all the consuming components (which will re-render whether or not they‚Äôre memoized).\"`}</p>\n    </blockquote>\n    <p>{`A `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/kentcdodds/kentcdodds.com/blob/319db97260078ea4c263e75166f05e2cea21ccd1/content/blog/how-to-optimize-your-context-value/index.md\"\n      }}>{`post from Kent`}</a>{` highlights when it is important to memoize the context value:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Your context value changes frequently`}</li>\n      <li parentName=\"ol\">{`Your context has many consumers`}</li>\n      <li parentName=\"ol\">{`You are bothering to use React.memo (because things are legit slow)`}</li>\n      <li parentName=\"ol\">{`You've actually measured things and you know it's slow and needs to be optimized`}</li>\n    </ol>\n    <p>{`In the example given, we needed to ensure the provider was memoized so that the lower children were helped when `}<inlineCode parentName=\"p\">{`App`}</inlineCode>{` was force re-rendered:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n  // üê® memoize this value with React.useMemo\n  const value = React.useMemo(() => [state, dispatch], [state, dispatch]);\n  // const value = [state, dispatch]\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const [, dispatch] = useAppState();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const [state, dispatch] = useAppState();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <p>{`The results can be seen in these screenshots:`}</p>\n    <p><img alt=\"Force rerender without memoization\" src={require(\"./force-rerender-without-memoization.png\")} /></p>\n    <p><img alt=\"Force rerender with memoization\" src={require(\"./force-rerender-with-memoization.png\")} /></p>\n    <h3 {...{\n      \"id\": \"separate-the-contexts\"\n    }}>{`Separate the contexts`}</h3>\n    <p>{`Another issue we run into is that when we click on a grid item, our state is updating. Because the state \"did update\", we are getting a new array in the memoised `}<inlineCode parentName=\"p\">{`AppProvider`}</inlineCode>{` and therefore this change is re-rendering everything that consumes the state (even though the `}<inlineCode parentName=\"p\">{`Grid`}</inlineCode>{` only needs to consume the dispatch!)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: at the end of this challenge on production, we'll see that we didn't make `}<em parentName=\"p\">{`huge changes`}</em>{` to the timing.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"fix-perf-deatch-by-a-thousand-cuts\"\n    }}>{`Fix Perf Deatch by a Thousand Cuts`}</h2>\n    <p>{`In this example, we had to fix an input that was operating horrifically slow. The reason we come to find is related to a requirement of state colocation with the component.`}</p>\n    <p>{`It is important NOT to just add everything to the state context willy nilly. There are a lot of Performance implications with this.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Fix \"perf death by a thousand cuts\"\n// http://localhost:3000/isolated/exercise/06.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nAppStateContext.displayName = 'AppStateContext';\nconst AppDispatchContext = React.createContext();\nAppDispatchContext.displayName = 'AppDispatchContext';\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    // we're no longer managing the dogName state in our reducer\n    // üí£ remove this case\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // üê® replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [dogName, setDogName] = React.useState('');\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    setDogName(newDogName);\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"separate-contexts\"\n    }}>{`Separate Contexts`}</h3>\n    <p>{`This solution is about going for a different approach. The approach here is to handle when things are global. We can separate context out for different domains.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`It is really important to also measure after to see if you've made serious Performance improvements and not just added complexity.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\nconst DogContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction dogReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction DogProvider(props) {\n  const [state, dispatch] = React.useReducer(dogReducer, {\n    dogName: '',\n  });\n\n  const value = [state, dispatch];\n\n  return <DogProvider value={value} {...props} />;\n}\n\nfunction useDogContext() {\n  const context = React.useContext(DogContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // üê® replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [state, dispatch] = useDogContext();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    // üê® change this to call your state setter that you get from useState\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogProvider>\n            <DogNameInput />\n          </DogProvider>\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: Because the `}<inlineCode parentName=\"p\">{`AppProvider`}</inlineCode>{` not longer impacts anything other than the grid, we can also change the Providers to focus more where is matters:`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <DogProvider>\n          <DogNameInput />\n        </DogProvider>\n        <AppProvider>\n          <Grid />\n        </AppProvider>\n      </div>\n    </div>\n  );\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"consuming-components\"\n    }}>{`Consuming Components`}</h3>\n    <p>{`If we check our profiling after the changes that we made above, we will see that when we click a button, there are still all these smaller re-renderings that are happening.`}</p>\n    <p>{`In this particular scenario, it is the `}<inlineCode parentName=\"p\">{`const cell = state.grid[row][column]`}</inlineCode>{` line that we want to take out from the cell and calculate prior.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// This is like a \"man-in-middle\" that cares about state and can take that,\n// pass it down and then the rendering of the CellImpl can take advantage of memoisation\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  return <CellImpl cell={cell} row={row} column={column} />;\n}\nCell = React.memo(Cell);\n\nfunction CellImpl({ cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCellImpl = React.memo(CellImpl);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"slice-of-app-state\"\n    }}>{`Slice of App State`}</h3>\n    <p>{`\"I'm not super jazzed about making an intermediary component\". Instead, we can make a higher-order component to take care of it for us instead.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function withStateSlice(Comp, slice) {\n  const MemoComp = React.memo(Comp);\n  function Wrapper(props, ref) {\n    const state = useAppState();\n    return <MemoComp ref={ref} state={slice(state, props)} {...props} />;\n  }\n  Wrapper.displayName = \\`withStateSlice\\${Comp.dispayName || Comp.name}\\`;\n  return React.memo(React.forwardRef(Wrapper));\n}\n\nfunction Cell({ state: cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = withStateSlice(\n  Cell,\n  (state, { row, column }) => state.grid[row][column],\n);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"use-recoil\"\n    }}>{`Use Recoil`}</h3>\n    <p>{`For the specific problem we have with the massive grid (if we want to use something like that), we can use Recoil to resolve the problems that we run into.`}</p>\n    <p>{`It is worth noting that there is a complexity cost for using Recoil, but in our specific usecase, it is something that Recoil was built to solve:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Starting point for the Recoil Extra Credit\n// üíØ use recoil (exercise)\n// http://localhost:3000/isolated/exercise/06.extra-4.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n// üê® you're gonna need these:\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilCallback,\n  atomFamily,\n} from 'recoil';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\n// üê® create an atomFamily called \\`cellAtoms\\` here where the\n// default callback function accepts an object with the\n// \\`row\\` and \\`column\\` and returns the value from the initialGrid\n// üí∞ initialGrid[row][column]\nconst cellAtoms = atomFamily({\n  key: 'cells',\n  default: () => ({ row, column }) => initialGrid[row][column],\n});\n\n// üí∞ I'm going to give this hook to you as it's mostly here for our contrived\n// example purposes. Just comment this in when you're ready to use it.\n// Here's how it's used:\n// const updateGrid = useUpdateGrid()\n// then later: updateGrid({rows, columns})\nfunction useUpdateGrid() {\n  return useRecoilCallback(({ set }) => ({ rows, columns }) => {\n    for (let row = 0; row < rows; row++) {\n      for (let column = 0; column < columns; column++) {\n        if (Math.random() > 0.7) {\n          set(cellAtoms({ row, column }), Math.random() * 100);\n        }\n      }\n    }\n  });\n}\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n  });\n  // ü¶â notice that we don't even need to bother memoizing this value\n  const value = [state, dispatch];\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  // üê® we're no longer storing the grid in our app state, so instead you\n  // want to get the updateGrid function from useUpdateGrid\n  const updateGrid = useUpdateGrid();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => updateGrid({ rows, columns });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\n\nfunction Cell({ row, column }) {\n  const [cell, setCell] = useRecoilState(cellAtoms({ row, column }));\n  const handleClick = () => setCell(Math.random() * 100);\n\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <RecoilRoot>\n        <AppProvider>\n          <div>\n            <DogNameInput />\n            <Grid />\n          </div>\n        </AppProvider>\n      </RecoilRoot>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <p>{`Read more on `}<a parentName=\"p\" {...{\n        \"href\": \"https://recoiljs.org/docs/introduction/motivation\"\n      }}>{`Recoil`}</a>{` from their docs.`}</p>\n    <h2 {...{\n      \"id\": \"production-performance-monitoring\"\n    }}>{`Production Performance Monitoring`}</h2>\n    <p>{`A great way to prevent changes from regressions, we can use production performance monitoring.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: There is a small performance cost involved with profiling. Facebook A/B serves a version with profiling involved.`}</p>\n    </blockquote>\n    <p>{`This exercise looks at using the `}<a parentName=\"p\" {...{\n        \"href\": \"https://reactjs.org/docs/profiler.html\"\n      }}>{`React Profiler API`}</a>{`.`}</p>\n    <p>{`The usage and callback:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`<App>\n  <Profiler id=\"Navigation\" onRender={onRenderCallback}>\n    <Navigation {...props} />\n  </Profiler>\n  <Main {...props} />\n</App>;\n\n// callback\nfunction onRenderCallback(\n  id, // the \"id\" prop of the Profiler tree that has just committed\n  phase, // either \"mount\" (if the tree just mounted) or \"update\" (if it re-rendered)\n  actualDuration, // time spent rendering the committed update\n  baseDuration, // estimated time to render the entire subtree without memoization\n  startTime, // when React began rendering this update\n  commitTime, // when React committed this update\n  interactions, // the Set of interactions belonging to this update\n) {\n  // Aggregate or log render timings...\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`\"It‚Äôs important to note that unless you build your app using react-dom/profiling and scheduler/tracing-profiling this component won‚Äôt do anything.\"`}</p>\n    </blockquote>\n    <p>{`Kent also has a `}<a parentName=\"p\" {...{\n        \"href\": \"https://kentcdodds.com/blog/react-production-performance-monitoring/\"\n      }}>{`blog post`}</a>{` on the profiling.`}</p>\n    <p>{`The solution to record one:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Production performance monitoring\n// http://localhost:3000/isolated/exercise/07.js\n\nimport * as React from 'react';\n// üê® you're going to need the reportProfile function\n// üí∞ here, let me help you with that..\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      üê® Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"tracing-api\"\n    }}>{`Tracing API`}</h3>\n    <p>{`So we don't know \"why\" the user caused the rerendering so we can use an `}<inlineCode parentName=\"p\">{`unstable_trace`}</inlineCode>{` to check.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import * as React from 'react';\nimport { unstable_trace as trace } from 'scheduler/tracing';\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  // We can wrap the setCount callback to use the trace API\n  const increment = trace('click', performance.now(), () =>\n    setCount(c => c + 1),\n  );\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      üê® Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <p>{`That is it! Now when the user clicks, we can get more information thanks to the trace that comes under the `}<inlineCode parentName=\"p\">{`interactions`}</inlineCode>{` value.`}</p>\n    <p>{`With the `}<inlineCode parentName=\"p\">{`trace`}</inlineCode>{` API, we can also start to use the `}<inlineCode parentName=\"p\">{`user interactions`}</inlineCode>{` section of the React profile!`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","module.exports = __webpack_public_path__ + \"static/force-rerender-with-memoization-b63b1632d8dcc8bf32c8eade5c4ce2a9.png\";"],"sourceRoot":""}