{"version":3,"sources":["webpack:///../manual/COMP3520-OS/Pthread.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---manual-comp-3520-os-pthread-md-a65efb269470adcc08ce.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"pthreads\"\n    }}>{`Pthreads`}</h1>\n    <h2 {...{\n      \"id\": \"pthreads-api\"\n    }}>{`Pthreads API`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Defined in the ANSI/IEEE Posix 1003.1 - 1995 standard`}</li>\n      <li parentName=\"ul\">{`Subroutines comprise the Pthreads API can be informally grouped into three major classes:`}</li>\n    </ul>\n    <ol>\n      <li parentName=\"ol\">{`Thread management`}</li>\n      <li parentName=\"ol\">{`Mutexes `}</li>\n      <li parentName=\"ol\">{`Condition variables`}</li>\n    </ol>\n    <h1 {...{\n      \"id\": \"1-thread-management\"\n    }}>{`1: Thread Management`}</h1>\n    <ul>\n      <li parentName=\"ul\">{`first class of functions work directly on threads - creating, detatching, joining etc `}</li>\n      <li parentName=\"ul\">{`also include funcs to set/query thread attributes (joinable, scheduling etc)`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Create Threads`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`initially, single default thread - others must be explicitly created`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{}}>{`pthread_create(thread, attr, startRoutine, arg)\n// thread - unique identifier for the new thread (pthread_t)\n// attr - attr object used to set thread attributes (pthread_attr) - you can specify a thread attributes object, or NULL for the default values\n// startRoutine - C routine that the thread will execute \n// arg - single arg that may be passed to startRoutine - it must be passed by reference (pointer to struct) and NULL may be used if no arg is to be passed\n\n/*\n    If successful, the pthread_create() function shall return zero; otherwise, an error number shall be returned to indicate the error\n */\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Thread Attributes`}</strong></p>\n    <p>{`By default, a thread is created with certain attributes.`}</p>\n    <p>{`pthread_attr_init(attr) and pthread_attr_destroy(attr) are used to initialize/destroy the thread attribute object.`}</p>\n    <p>{`Other routines are then used to query/set specific attributes in the thread attribute object.`}</p>\n    <p><strong parentName=\"p\">{`Terminating Thread`}</strong></p>\n    <ol>\n      <li parentName=\"ol\">{`Thread makes call to the pthread_exit() subroutine `}</li>\n      <li parentName=\"ol\">{`Thread is cancelled by another thread via pthread_cancel() routine `}</li>\n      <li parentName=\"ol\">{`Entire process is terminated due to call to exit subroutine `}</li>\n    </ol>\n    <p>{`Routine: `}<inlineCode parentName=\"p\">{`pthread_exit(status)`}</inlineCode></p>\n    <ul>\n      <li parentName=\"ul\">{`used to explicitly exit the thread`}</li>\n      <li parentName=\"ul\">{`programmer may optionalyl specify a termination status, which is stored as a void pointer for any thread that may join the calling thread`}</li>\n    </ul>\n    <p>{`Cleanup: `}<inlineCode parentName=\"p\">{`pthread_exit()`}</inlineCode>{` does not close files; any files opened inside the thread will remain open after the thread is terminated.`}</p>\n    <p><strong parentName=\"p\">{`Example`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define NUM_THREADS 5\n\nvoid *PrintHello(void *threadid) {\n    int *tid;\n    tid = (int *)threadid;\n    printf(\"Hello World! It's me, thread #%d!\\\\n\", *tid);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t threads[NUM_THREADS];\n    int rc, t, tids[NUM_THREADS];\n    for (t=0; t< NUM_THREADS; t++) {\n        printf(\"In main: creating thread %d\\\\n\", t);\n        tids[t] = t;\n        rc = pthread_create(&threads[t], NULL, PrintHello, (void *)&tids[t]);\n\n        if (rc) {\n            printf(\"ERROR; return code from pthread_create() is %d\\\\n\", rc);\n            exit(-1);\n        }\n    }\n    pthread_exit(NULL); \n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"passing-arguments-to-threads\"\n    }}>{`Passing Arguments to Threads`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_create()`}</inlineCode>{` routine permits the programmer to pass one argument to the thread start routine.`}</p>\n    <p>{`For cases where multiple args must be passed, we can create a struct and use the reference pointer as an arg.`}</p>\n    <p>{`All args passed by reference must be cast to (void *)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`struct two_args {\n    int arg1;\n    int arg2;   \n};\n\nvoid *needs_2_args(void *ap) {\n    struct two_args *argp;\n    int a1, a2;\n\n    argp = (struct two_args *) ap;\n\n    // do stuff here\n    \n    a1 = argp->arg1;\n    a2 = argp->arg2;\n    \n    // do stuff here \n\n    free(argp);\n    pthread_exit(NULL);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_t t;\n    struct two_args *ap;\n    int rc;\n\n    // do stuff here \n\n    ap = (struct two_args *)malloc(sizeof(struct two_args));\n    ap->arg1 = 1;\n    ap->arg2 = 2;\n    rc = pthread_create(&t, NULL, needs_2_args, (void *) ap);\n\n    // do stuff here \n\n    pthread_exit(NULL);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"joining-and-detatching-threads\"\n    }}>{`Joining and Detatching Threads`}</h2>\n    <p><strong parentName=\"p\">{`Routines`}</strong></p>\n    <ol>\n      <li parentName=\"ol\">{`pthread_join(threadid, status)`}</li>\n      <li parentName=\"ol\">{`pthread_detach(threadit, status)`}</li>\n      <li parentName=\"ol\">{`pthread_attr_setdatachstate(attr, detachstate)`}</li>\n      <li parentName=\"ol\">{`pthread_attr_getdetachstate(attr, detachstate)`}</li>\n    </ol>\n    <ul>\n      <li parentName=\"ul\">{`\"joining\" is one way to accomplish synchronization between threads`}</li>\n      <li parentName=\"ul\">{`the `}<inlineCode parentName=\"li\">{`pthread_join()`}</inlineCode>{` subroutine blocks the calling thread until the specified threadid thread terminates`}</li>\n      <li parentName=\"ul\">{`The programmer is able to obtain the target thread's termination return status if it was specified in the target thread's call to `}<inlineCode parentName=\"li\">{`pthread_exit()`}</inlineCode></li>\n      <li parentName=\"ul\">{`When a thread if created, one of its attributes defines whether it is joinable or detached.`}</li>\n      <li parentName=\"ul\">{`Only threads that are create as joinable can be joined.`}</li>\n    </ul>\n    <p>{`To explicitly create a thread as joinable or detached, the attr argument in the `}<inlineCode parentName=\"p\">{`pthread_create()`}</inlineCode>{` routine is used:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Declare a pthread attribute ariable of the `}<inlineCode parentName=\"li\">{`pthread_attr_t data`}</inlineCode>{` type `}</li>\n      <li parentName=\"ol\">{`Initialize the attribute ariable with `}<inlineCode parentName=\"li\">{`pthread_attr_init()`}</inlineCode></li>\n      <li parentName=\"ol\">{`Set the attribute detached status with `}<inlineCode parentName=\"li\">{`pthread_attr_setdetachedstate()`}</inlineCode></li>\n      <li parentName=\"ol\">{`When done, ree library resources used by the attribute with `}<inlineCode parentName=\"li\">{`pthread_attr_destroy()`}</inlineCode></li>\n    </ol>\n    <p><strong parentName=\"p\">{`Example`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`void *BusyWork(void *null) {\n    // do stuff \n    pthread_exit((void *) 0);\n}\n\nint main(int argc, char *argv[]) {\n    pthread_attr_t attr;\n    int rc, t;\n    void *status;\n\n    /* init and set thread detached attribute */\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n\n    /* free attribute and wait for the other threads */\n    pthread_attr_destory(&attr);\n    for (t=0; t< NUM_THREADS; t++) {\n        rc = pthread_join(thread[t], &status);\n        // do stuff \n        printf(\"Completed join with thred %d status = %ld\\\\n\", t, (long)status);\n    }\n    pthread_exit(NULL);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"syncronisation-issues\"\n    }}>{`Syncronisation Issues`}</h2>\n    <p>{`When multiple threads attempt to manipulate the same data item, the results can often be incoherent if proper care is not take ie. race conditions.`}</p>\n    <h1 {...{\n      \"id\": \"2-mutexes\"\n    }}>{`2: Mutexes`}</h1>\n    <p>{`The second class of functions deal with synchronization - called a \"mutex\", which is an abbreviation for mutual exclusion.`}</p>\n    <h2 {...{\n      \"id\": \"creating-and-destroying-mutexes\"\n    }}>{`Creating and Destroying Mutexes`}</h2>\n    <h2 {...{\n      \"id\": \"routines\"\n    }}>{`Routines`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_mutex_init(mutex, attr)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutex_destroy(mutex)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutexattr_init(attr)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutexattr_destroy(attr)`}</inlineCode></p>\n    <p>{`A mutex must be declared with type `}<inlineCode parentName=\"p\">{`pthread_mutex_t`}</inlineCode>{`, and must be initialized before they can be used.`}</p>\n    <p>{`There are two ways to init a mutex variable:\n1. Statically, when declared eg `}<inlineCode parentName=\"p\">{`pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER`}</inlineCode>{`\n2. Dynamically, with the `}<inlineCode parentName=\"p\">{`pthread_mutex_init()`}</inlineCode>{` routine. This method permits setting mutex object attributes, `}<inlineCode parentName=\"p\">{`attr`}</inlineCode>{` (which my be specified as NULL to accept defaults).`}</p>\n    <p>{`The mutex is initially unlocked.`}</p>\n    <h2 {...{\n      \"id\": \"locking--unlocking-mutexes\"\n    }}>{`Locking & Unlocking Mutexes`}</h2>\n    <h2 {...{\n      \"id\": \"routines-1\"\n    }}>{`Routines`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_mutex_lock(mutex)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutex_unlock(mutex)`}</inlineCode>{`\n`}<inlineCode parentName=\"p\">{`pthread_mutex_trylock(mutex)`}</inlineCode></p>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`pthread_mutex_lock(mutex)`}</inlineCode>{` will lock the specified mutex`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`pthread_mutex_unlock(mutex)`}</inlineCode>{` will unlock a mutex if called by the owning thread\n- throws an error if already unlocked or owned by another thread`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`pthread_mutex_trylock(mutex)`}</inlineCode>{` will attempt to lock a mutex, however if the mutex is already locked it will return a \"EBUSY\" error code.\n- May be useful to prevent deadlocks!`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Example 1`}</strong></p>\n    <p>{`We can now write our previously incorrect code segment as...`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_mutex_t min_value_lock;\n\nmain() {\n    ...\n    pthread_mutex_init(&min_value_lock, NULL);\n    ...\n}\n\nvoid *find_min(void *list_ptr) {\n    ...\n    pthread_mutex_lock(&min_value_lock);\n    if (my_cost < best_cost) {\n        best_cost = my_cost;\n    }   \n    pthread_mutex_unlock(&min_value_lock);\n}\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Example 2`}</strong></p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`producer-consumer`}</inlineCode>{` scenario imposes the following constraints:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`The producer thread must not overwrite the shared buffer when the previous task has no been picked up by a consumer thread.`}</li>\n      <li parentName=\"ol\">{`The consumer threads must not pick up tasks until there is something present in the shared data structure.`}</li>\n      <li parentName=\"ol\">{`Individual consumer threads should pick up tasks one at a time.`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_mutex_t task_queue_lock;\nint task_available;\n\nmain() {\n    task_available = 0;\n    pthread_mutex_init(&task_queue_lock, NULL);\n}\n\nvoid *producer(void *producer_thread_data) {\n    ...\n    while (!done()) {\n        inserted = 0;\n        create_task(&my_task);\n        while (inserted == 0) {\n            pthread_mutex_lock(&task_queue_lock);\n            if (task_available == 0) {\n                insert_into_queue(my_task);\n                task_available = 1;\n                inserted = 1;\n            }\n            pthread_mutex_unlock(&task_queue_lock);\n        }\n    }\n}\n\nvoid *consumer(void *consumer_thread_data) {\n    ...\n    while (!done()) {\n        extracted = 0;\n        while (extracted == 0) {\n            pthread_mutex_lock(&task_queue_lock);\n            if (task_available == 1) {\n                extract_from_queue(&my_task);\n                task_available = 0;\n                extracted = 1;\n            }\n            pthread_mutex_unlock(&task_queue_lock);\n        }\n        process_task(my_task);\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"overheads-of-locking\"\n    }}>{`Overheads of Locking`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Locks represent serialization points since critical sections must be executed by threads one after another.`}</li>\n      <li parentName=\"ul\">{`Encapsulating large segments of the program within locks can lead to significant performance degradation.`}</li>\n      <li parentName=\"ul\">{`It is often possible to reduce the idling overhead associated with locks using `}<inlineCode parentName=\"li\">{`pthread_mutex_trylock`}</inlineCode>{`.`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Alleviating Locking Overhead`}</strong></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_mutex_t tryLock_lock = PTHREAD_MUTEX_INITIALIZER;\n\nlock_status = pthread_mutex_trylock(&tryLock_lock)\nif (lock_status == EBUSY) {\n    /* do something else */\n    ...\n} else {\n    /* do one thing */\n    ...\n    pthread_mutex_unlock(&tryLock_lock);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"monitors\"\n    }}>{`Monitors`}</h2>\n    <p>{`Mutexes provide powerful sync tools, but...`}</p>\n    <ul>\n      <li parentName=\"ul\">{`lock() and unlock() are scatteed among several threads, therefore it is difficult to understand their effects`}</li>\n      <li parentName=\"ul\">{`usage must be correct in all the threads `}</li>\n      <li parentName=\"ul\">{`one bad thread (or one programming error) can kill the whole system`}</li>\n    </ul>\n    <p>{`A `}<inlineCode parentName=\"p\">{`monitor`}</inlineCode>{` is a high-level abstraction that may provide a convenient and effective mechanism for thread synchronization.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`local data variables are accessible only by the monitor `}</li>\n      <li parentName=\"ul\">{`thread enters monitor by invoking one of its procedures `}</li>\n      <li parentName=\"ul\">{`only one thread may be executing in a the monitor at a time`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Monitor and Condition Variables`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`Monitor does not need to code certain sync constraints explicitly.`}</li>\n      <li parentName=\"ul\">{`However, it is not sufficiently powerful for modeling some other synchronization schemes.`}</li>\n      <li parentName=\"ul\">{`An additional sync mechanism ie `}<inlineCode parentName=\"li\">{`condition variable`}</inlineCode>{` is required.`}</li>\n    </ul>\n    <p><strong parentName=\"p\">{`Condition Variables`}</strong></p>\n    <ul>\n      <li parentName=\"ul\">{`The third class of functions address communications between threads that share a mutex`}</li>\n      <li parentName=\"ul\">{`A condition variable allows a thread to block itself until specified data reaches a predefined state.`}</li>\n      <li parentName=\"ul\">{`A condition variable indicates an event and has no value\n- One cannot store a value into nor retrieve a value from a condition variable.\n- If a thread must wait for an event to occur, that tread waits on the corresponding condition variable.\n- A condition variable has a queue for those threads that are waiting the corresponding event to occur to wait on.\n- If another thread causes the event to occur, that thread simply signal the corresponding condition variable.`}</li>\n      <li parentName=\"ul\">{`This class includes funcs to `}<inlineCode parentName=\"li\">{`create`}</inlineCode>{`, `}<inlineCode parentName=\"li\">{`destroy`}</inlineCode>{`, `}<inlineCode parentName=\"li\">{`wait`}</inlineCode>{` and `}<inlineCode parentName=\"li\">{`signal`}</inlineCode>{` based on specified variable values.`}</li>\n      <li parentName=\"ul\">{`Funcs to set/quey cond variable attrs are also included.`}</li>\n      <li parentName=\"ul\">{`Cond variable is always used in conjunction with a `}<inlineCode parentName=\"li\">{`mutex lock`}</inlineCode></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"create--destroying-cond-variables\"\n    }}>{`Create & Destroying Cond Variables`}</h2>\n    <h2 {...{\n      \"id\": \"routines-2\"\n    }}>{`Routines`}</h2>\n    <p>{`pthread_cond_init(condition, attr)\npthread_cond_destroy(condition)\npthread_condattr_init(attr)\npthread_condattr_destroy(attr)`}</p>\n    <p>{`Condition variables must be declared with type `}<inlineCode parentName=\"p\">{`pthread_cont_t`}</inlineCode>{`, and must be initialized before they can be used.`}</p>\n    <p>{`2 Ways to declare:\n1. Statically\n2. Dynamically `}</p>\n    <h2 {...{\n      \"id\": \"waiting-and-signaling-on-condition-variable\"\n    }}>{`Waiting and Signaling on Condition Variable`}</h2>\n    <p><inlineCode parentName=\"p\">{`pthread_cond_signal()`}</inlineCode>{` is used to signal (or wake up) another thread which is waiting on the condition variable and should be called after the `}<inlineCode parentName=\"p\">{`mutex`}</inlineCode>{` is locked.`}</p>\n    <p>{`It must unlock `}<inlineCode parentName=\"p\">{`mutex`}</inlineCode>{` in order for `}<inlineCode parentName=\"p\">{`pthread_cond_wait()`}</inlineCode>{` routine to complete.`}</p>\n    <p><inlineCode parentName=\"p\">{`pthread_cond_broadcast()`}</inlineCode>{` routine unlocks all of the threads blocked on the condition variable.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Proper locking and unlocked of mutex is essential for these routines\n- Failing to lock may cause it NOT to block\n- Failing to unlock the mutex may not allow a matching `}<inlineCode parentName=\"li\">{`pthread_cond_wait()`}</inlineCode>{` routine to complete (it will remain blocked)`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"producer-consumer-using-condition-variables\"\n    }}>{`Producer-Consumer Using Condition Variables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-c\"\n      }}>{`pthread_cond_t cond_queue_empty, cond_queue_full;\npthread_mutex_t task_queue_cond_lock;\nint task_available;\n// other data structures here \n\nmain() {\n    // declarations and initializations \n    task_available = 0;\n    pthread_cond_init(&cond_queue_empty, NULL);\n    pthread_cond_init(&cond_queue_full, NULL);\n    pthread_mutex_init(&task_queue_cond_lock, NULL);\n    // create and join producer and consumer threads\n}\n\nvoid *producer(void *producer_thread_data) {\n    while(!done()) {\n        create_task();\n        pthread_mutex_lock(&task_queue_cond_lock);\n        \n        while (task_available == 1) {\n            pthread_cond_wait(&cond_queue_empty,\n                &task_queue_cond_lock);\n        }\n\n        insert_into_queue();\n        task_available = 1;\n        pthread_cond_signal(&cond_queue_full);\n        pthread_mutex_unlock(&task_queue_cond_lock);\n    }\n}\n\nvoid *consumer(void *consumer_thread_data) {\n    while(!done()) {\n        pthread_mutex_lock(&task_queue_cond_lock);\n        while (task_available == 0) {\n            pthread_cond_wait(&cond_queue_full,\n                &task_queue_cond_lock);\n        }\n\n        my_task = extract_from_queue();\n        task_available = 0;\n        pthread_cond_signal(&cond_queue_empty);\n        pthread_mutex_unlock(&task_queue_cond_lock);\n        process_task(my_task);\n    }\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}