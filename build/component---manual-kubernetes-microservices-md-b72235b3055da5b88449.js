(window.webpackJsonp=window.webpackJsonp||[]).push([[321],{JoRN:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return c}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var a=t("/FXl"),o=t("TjRS");t("aD51");function l(){return(l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Kubernetes/Microservices.md"}});var s={_frontmatter:i},r=o.a;function c(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,["components"]);return Object(a.b)(r,l({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"7-microservices"},"7. Microservices"),Object(a.b)("p",null,"If we have multiple apps that require information from between each other, we need to start talking about the  ",Object(a.b)("strong",{parentName:"p"},"service mesh"),". Normally between applications,  we run into the following problems:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"There is no encryption"),Object(a.b)("li",{parentName:"ul"},"No retries."),Object(a.b)("li",{parentName:"ul"},"No fallover."),Object(a.b)("li",{parentName:"ul"},"No intelligent load balancer."),Object(a.b)("li",{parentName:"ul"},"No routing decisions."),Object(a.b)("li",{parentName:"ul"},"No metrics/logs/traces."),Object(a.b)("li",{parentName:"ul"},"No access control.")),Object(a.b)("p",null,"One solution is to implement ",Object(a.b)("strong",{parentName:"p"},"sidecars")," which is a proxy to every single microservice. This can resolve issues such as encryption, retries when a connection fails, intelligent load balancing."),Object(a.b)("p",null,"You could also add a ",Object(a.b)("strong",{parentName:"p"},"management interface")," which resolves routing decisions, metrics/logs/traces and access control (ie valid certificate etc)."),Object(a.b)("p",null,"This brings us to ",Object(a.b)("strong",{parentName:"p"},"Istio"),"."),Object(a.b)("p",null,Object(a.b)("img",{alt:"Istio diagram",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540090167/istio-diagram.png"})),Object(a.b)("h2",{id:"71-istio-installation"},"7.1 Istio Installation"),Object(a.b)("p",null,"If you want to use Istio, it's worth now using a node with enough memory ie t2.medium."),Object(a.b)("h3",{id:"kops-configuration"},"Kops configuration"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kops edit cluster kubernetes.newtech.academy\n")),Object(a.b)("p",null,"Add:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{}),"spec:\n  kubeAPIServer:\n    admissionControl:\n    - NamespaceLifecycle\n    - LimitRanger\n    - ServiceAccount\n    - PersistentVolumeLabel\n    - DefaultStorageClass\n    - DefaultTolerationSeconds\n    - MutatingAdmissionWebhook\n    - ValidatingAdmissionWebhook\n    - ResourceQuota\n    - NodeRestriction\n    - Priority\n")),Object(a.b)("h3",{id:"download-102"},"Download (1.0.2):"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ cd ~\n$ wget https://github.com/istio/istio/releases/download/1.0.2/istio-1.0.2-linux.tar.gz\ntar -xzvf istio-1.0.2-linux.tar.gz\n$ cd istio-1.0.2\n# Alternatively just export the PATH so you don't have to logout\n$ echo 'export PATH=\"$PATH:/home/ubuntu/istio-1.0.2/bin\"' >> ~/.profile\n$ istioctl # check everything is running correctly\n")),Object(a.b)("h3",{id:"download-latest"},"Download (latest):"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ cd ~\n$ curl -L https://git.io/getLatestIstio | sh -\n$ echo 'export PATH=\"$PATH:/home/ubuntu/istio-1.0.2/bin\"' >> ~/.profile # change 1.0.2 in your version -- alternative just export the PATH so you don't have to logout\n$ cd istio-1.0.2 # change 1.0.2 in your version\n")),Object(a.b)("h3",{id:"istio-install"},"Istio install"),Object(a.b)("p",null,"Apply CRDs:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kubectl apply -f ~/istio-1.0.2/install/kubernetes/helm/istio/templates/crds.yaml\n")),Object(a.b)("p",null,"Wait a few seconds."),Object(a.b)("p",null,"Option 1: with no mutual TLS authentication"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kubectl apply -f ~/istio-1.0.2/install/kubernetes/istio-demo.yaml\n")),Object(a.b)("p",null,"Option 2: or with mutual TLS authentication"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kubectl apply -f ~/istio-1.0.2/install/kubernetes/istio-demo-auth.yaml\n")),Object(a.b)("h2",{id:"72-example-app"},"7.2 Example app"),Object(a.b)("p",null,Object(a.b)("img",{alt:"Example app diagram",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540091246/Screen_Shot_2018-10-21_at_2.07.07_pm.png"})),Object(a.b)("h3",{id:"example-app-from-istio"},"Example app (from istio)"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),'export PATH="$PATH:/home/ubuntu/istio-1.0.2/bin"\nkubectl apply -f <(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml)\n')),Object(a.b)("h3",{id:"hello-world-app"},"Hello world app"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),'export PATH="$PATH:/home/ubuntu/istio-1.0.2/bin"\nkubectl apply -f <(istioctl kube-inject -f helloworld.yaml)\nkubectl apply -f helloworld-gw.yaml\n')),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld.yaml\n# Spinning up the container for a simple hello world app\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\n# Exposing a service for "hello"\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\n# Spinning up container for world\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: world\n        version: v1\n    spec:\n      containers:\n      - name: world\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "world-2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\n# Exposing world container\napiVersion: v1\nkind: Service\nmetadata:\n  name: world\n  labels:\n    app: world\nspec:\n  selector:\n    app: world\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\n# World 2 deployment\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-2\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: world-2\n        version: v1\n    spec:\n      containers:\n      - name: world-2\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!" \n        ports:\n        - name: http\n          containerPort: 8080\n---\n# Exposing service for world 2 deployment\napiVersion: v1\nkind: Service\nmetadata:\n  name: world-2\n  labels:\n    app: world-2\nspec:\n  selector:\n    app: world-2\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\n')),Object(a.b)("p",null,"After deploying and applying the Istio injection from following the above istio commands, we will see that each deploying will have an app running with it along with the sidebar."),Object(a.b)("p",null,"For the Istio gateway, we launch the following:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'apiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "*"\n  gateways:\n  - helloworld-gateway\n  # if we match uri /hello, then follow routing\n  http:\n  - match:\n    - uri:\n        prefix: /hello\n    route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        port:\n          number: 8080\n')),Object(a.b)("h2",{id:"73-advanced-istio-routing"},"7.3 Advanced Istio Routing"),Object(a.b)("p",null,Object(a.b)("img",{alt:"Advanced Routing Setup",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540109060/Screen_Shot_2018-10-21_at_7.04.07_pm.png"})),Object(a.b)("p",null,"Thanks to Istio, we can do advanced routing based around the above diagram thanks to the Deployments having different metadata:"),Object(a.b)("p",null,"The deployment:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-v2\nspec:\n  replicas: 3\n  template:\n    # we use this metadata for Istio to distinguish on routes\n    metadata:\n      labels:\n        app: hello\n        version: v2\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello, this is v2\n        - name: NEXT\n          value: "world-2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n')),Object(a.b)("p",null,"The routing:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld-v2-routing\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  # ! Subsets is where the magic happens!\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "hello.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - match:\n    - headers:\n        end-user:\n          exact: john\n    route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v2 # ! match v2 only\n        port:\n          number: 8080\n  - route: # default route for hello.example.com\n    - destination:\n        host: ! hello.default.svc.cluster.local\n        subset: v1 # match v1 only\n        port:\n          number: 8080\n')),Object(a.b)("p",null,'Now, if we apply this virtual service to the service mesh, then based on whether we pass the "end-user" header or not, we will hit either v1 or v2!'),Object(a.b)("p",null,"We can test by running ",Object(a.b)("inlineCode",{parentName:"p"},'curl loadbalanceraddress.domain.com -H "host: hello.example.com"'),"."),Object(a.b)("p",null,"For v2 we can run `",Object(a.b)("inlineCode",{parentName:"p"},'curl loadbalanceraddress.domain.com -H "host: hello.example.com" -H "end-user: John"'),". "),Object(a.b)("h2",{id:"74-canary-deployments"},"7.4 Canary deployments"),Object(a.b)("p",null,"Canary deployments basically want routing mainly to the first version, but we also want some A/B testing to have version 2 having a 10% weight."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "hello.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v1\n        port:\n          number: 8080\n      weight: 90\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v2\n        port:\n          number: 8080\n      weight: 10\n')),Object(a.b)("h2",{id:"75-running-retries"},"7.5 Running retries"),Object(a.b)("p",null,"If one of the pods stop working, we can retry to another pod without the client seeing any of the issues. The example app has one of three pods running with a 5s latency but a 2s timeout to demonstrate this. It looks like the following:"),Object(a.b)("p",null,Object(a.b)("img",{alt:"Retry diagram",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540110459/Screen_Shot_2018-10-21_at_7.26.50_pm.png"})),Object(a.b)("p",null,"We can see this being done with ",Object(a.b)("inlineCode",{parentName:"p"},"Hello World v3")," so we can see this in action with:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld-v3.yaml\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-v3\nspec:\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v3\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: MY_POD_NAME\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.name\n        - name: TEXT\n          value: hello, this is $(MY_POD_NAME)\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-v3-latency\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v3\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: MY_POD_NAME\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.name\n        - name: TEXT\n          value: hello, this is $(MY_POD_NAME)\n        - name: LATENCY\n          value: "5"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n  - name: v3\n    labels:\n      version: v3\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-v3\nspec:\n  hosts:\n  - "hello-v3.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route: # default route for hello.example.com\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v3 # match v3 only\n        port:\n          number: 8080\n    timeout: 10s\n    retries:\n      attempts: 2\n      perTryTimeout: 2s\n')),Object(a.b)("p",null,"We can also call ",Object(a.b)("inlineCode",{parentName:"p"},"kubectl get destinationrule")," etc to get and describe particular rules."),Object(a.b)("h2",{id:"76-mutual-tls-example"},"7.6 Mutual TLS example"),Object(a.b)("p",null,"Create pods, services, destinationrules, virtualservices"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"kubectl create -f <(istioctl kube-inject -f helloworld-tls.yaml)\nkubectl create -f helloworld-legacy.yaml\n")),Object(a.b)("p",null,"The goals of Istio security are:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Security by default:")," no changes needed for application code and infrastructure."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Defense in depth:")," integrate with existing security systems to provide multiple layers of defense."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Zero-trust network:")," build security solutions on untrusted networks.")),Object(a.b)("p",null,"Two types of auth:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Transport authentication (service to service authentication) using Mutual TLS."),Object(a.b)("li",{parentName:"ol"},"Origin authentication (end-user authentication). Verifying the end user using JWTs.")),Object(a.b)("p",null,"Mutual TLS can be turned on ",Object(a.b)("strong",{parentName:"p"},"without having to change the code of applications")," (because of the sidecar deployment)."),Object(a.b)("p",null,"It provides each service with a ",Object(a.b)("strong",{parentName:"p"},"strong identity"),"."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Attacks like impersonation be rerouting DNS records will fail, because a fake application can't prove its identity using the certificate mechanism."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Secures (encrypts)")," service-to-service and end-user-to-service communication."),Object(a.b)("li",{parentName:"ul"},"Provides key and certificate management to ",Object(a.b)("strong",{parentName:"li"},"manage generation, distribution and rotation"),".")),Object(a.b)("p",null,Object(a.b)("img",{alt:"TLS Example App",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540153502/Screen_Shot_2018-10-22_at_7.24.10_am.png"})),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Legacy applications with not have a sidecar. "),Object(a.b)("li",{parentName:"ul"},"One service will go LTR, and the other RTL.")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'apiVersion: v1\nkind: Namespace\nmetadata:\n  name: ns1\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: ns2\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-tls\n  namespace: ns1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world.ns2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-tls\n  namespace: ns2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "end.legacy:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-reverse-tls\n  namespace: ns2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world-reverse\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "end-reverse.ns1:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: end-reverse-tls\n  namespace: ns1\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: end-reverse\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  namespace: ns1\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world\n  namespace: ns2\n  labels:\n    app: world\nspec:\n  selector:\n    app: world\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world-reverse\n  namespace: ns2\n  labels:\n    app: world-reverse\nspec:\n  selector:\n    app: world-reverse\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: end-reverse\n  namespace: ns1\n  labels:\n    app: end-reverse\nspec:\n  selector:\n    app: end-reverse\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.ns1.svc.cluster.local\n  # uncomment to enable mutual TLS\n  #trafficPolicy:\n  #  tls:\n  #    mode: ISTIO_MUTUAL\n  subsets:\n  - name: v1-tls\n    labels:\n      version: v1-tls\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello-reverse\nspec:\n  host: hello-reverse.legacy.svc.cluster.local\n  # uncomment to enable mutual TLS\n  #trafficPolicy:\n  #  tls:\n  #    mode: ISTIO_MUTUAL\n  subsets:\n  - name: v1-tls\n    labels:\n      version: v1-tls\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-tls\nspec:\n  hosts:\n  - "hello-tls.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.ns1.svc.cluster.local\n        subset: v1-tls # match v3 only\n        port:\n          number: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-tls-reverse\nspec:\n  hosts:\n  - "hello-tls-reverse.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello-reverse.legacy.svc.cluster.local\n        subset: v1-tls\n        port:\n          number: 8080\n')),Object(a.b)("p",null,"As for the missing legacy services, they can be found in the ",Object(a.b)("inlineCode",{parentName:"p"},"helloworld-legacy")," file:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'apiVersion: v1\nkind: Namespace\nmetadata:\n  name: legacy\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: end-tls\n  namespace: legacy\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: end\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello-reverse-tls\n  namespace: legacy\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello-reverse\n        version: v1-tls\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world-reverse.ns2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: end\n  namespace: legacy\n  labels:\n    app: end\nspec:\n  selector:\n    app: end\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello-reverse\n  namespace: legacy\n  labels:\n    app: hello-reverse\nspec:\n  selector:\n    app: hello-reverse\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n')),Object(a.b)("p",null,"Both these files can applied by running the following:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kubectl apply -f <(istioctl kube-inject -f helloworld-tls.yaml)\n$ kubectl apply -f helloworld-legacy.yaml\n$ kubetl get svc -o wide -n istio-system # get services from istio-system services\n# After getting the load balancer, you can then curl the ELB passing the Host header\n")),Object(a.b)("p",null,"Now we need to ",Object(a.b)("strong",{parentName:"p"},"enable TLS authetication.")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld-rbac-enable.yaml\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\n# ensures mtls is push to side cars\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "legacy"\nspec:\n  host: "end.legacy.svc.cluster.local"\n  trafficPolicy:\n    tls:\n      mode: DISABLE\n')),Object(a.b)("p",null,"Apply this file to enable mutual TLS that works one way but not the other (as like in the diagram). However, in the above yaml files we did now enable the traffic policy, so you need to update that and apply the updated files for all of this to work."),Object(a.b)("h2",{id:"77-end-user-authentication"},"7.7 End-user authentication"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"kubectl create -f <(istioctl kube-inject -f helloworld-jwt.yaml)\nkubectl create -f helloworld-jwt-enable.yaml\n")),Object(a.b)("p",null,"If we want to access a Pod, we need to use a gateway. "),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld-gw.yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "*"\n  gateways:\n  - helloworld-gateway\n  http:\n  - match:\n    - uri:\n        prefix: /hello\n    route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        port:\n          number: 8080\n')),Object(a.b)("p",null,"If you want a service within Istio, you will always need to define the ",Object(a.b)("inlineCode",{parentName:"p"},"VirtualService"),". We don't need the ",Object(a.b)("inlineCode",{parentName:"p"},"VirtualService")," for services that are accessed by the client."),Object(a.b)("h2",{id:"78-rbac-with-istio-and-mtls"},"7.8 RBAC with Istio and MTLS"),Object(a.b)("p",null,"Now that we have MTLS, we have strong identites."),Object(a.b)("p",null,"Based on those identities, we can start doing ",Object(a.b)("strong",{parentName:"p"},"Role Based Access Control (RBAC)"),"."),Object(a.b)("p",null,"RBAC allows us to limit access ",Object(a.b)("strong",{parentName:"p"},"between our services")," and from ",Object(a.b)("strong",{parentName:"p"},"end-user to services"),"."),Object(a.b)("p",null,"Istio is able to verify the identity of a service by ",Object(a.b)("strong",{parentName:"p"},"checking the identity of the x.509 certificate (which comes with enabled mutual TLS)"),". Example: with RBAC, service A might be able to be contacted by B, but not by C."),Object(a.b)("p",null,"Istio is using SPIFFE standard (another CNFC project)."),Object(a.b)("p",null,"RBAC in istio:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Can provide ",Object(a.b)("strong",{parentName:"li"},"service-to-service")," and ",Object(a.b)("strong",{parentName:"li"},"end-user-to-service")," auth."),Object(a.b)("li",{parentName:"ul"},"Supports ",Object(a.b)("strong",{parentName:"li"},"conditions")," and ",Object(a.b)("strong",{parentName:"li"},"role-binding"),".",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"You can bind to ",Object(a.b)("strong",{parentName:"li"},"ServiceAccounts")," (which can be linked to pods)."),Object(a.b)("li",{parentName:"ul"},"End-user-to-service can for example let you create ",Object(a.b)("strong",{parentName:"li"},"condition on being authenticated using JWT"),"."),Object(a.b)("li",{parentName:"ul"},"It has high performance."),Object(a.b)("li",{parentName:"ul"},"Not enabled by default."),Object(a.b)("li",{parentName:"ul"},"We can enable it globally or on a namespace.")))),Object(a.b)("p",null,'Example for including it on the "default" namespace:'),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'apiVersion: "rbac.istio.io/v1alpha1"\nkind: RbacConfig\nmetadata:\n  name: default\nspec:\n  mode: \'ON_WITH_INCLUSION\'\n  inclusion:\n    namespaces: ["default"]\n---\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n')),Object(a.b)("p",null,"We can then create a ",Object(a.b)("strong",{parentName:"p"},"ServiceRole")," specifying the rules and a ",Object(a.b)("strong",{parentName:"p"},"ServiceRoleBinding")," to link a ",Object(a.b)("strong",{parentName:"p"},"ServiceRole")," to a subject (example Kubernetes ",Object(a.b)("strong",{parentName:"p"},"ServiceAccount"),")."),Object(a.b)("p",null,"Example of how we want the demo to look when it comes to what it can contact:"),Object(a.b)("p",null,Object(a.b)("img",{alt:"Contact rules",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540155683/Screen_Shot_2018-10-22_at_8.00.47_am.png"})),Object(a.b)("p",null,"The order for the following is:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"Create ",Object(a.b)("strong",{parentName:"li"},"ServiceRoles")," that only enable certain methods and services with specific access."),Object(a.b)("li",{parentName:"ol"},"Enable ",Object(a.b)("strong",{parentName:"li"},"ServiceRoleBindings")," to bind that the ",Object(a.b)("strong",{parentName:"li"},"ServiceRoles")," to a ",Object(a.b)("strong",{parentName:"li"},"subject")," (or ",Object(a.b)("strong",{parentName:"li"},"ingress controller name")," in the first case)."),Object(a.b)("li",{parentName:"ol"},"Create the ",Object(a.b)("strong",{parentName:"li"},"ServiceAccounts")," that have the correct metadata required for the ",Object(a.b)("strong",{parentName:"li"},"ServiceRoleBindings"),"."),Object(a.b)("li",{parentName:"ol"},"Create the ",Object(a.b)("strong",{parentName:"li"},"Deployments")," that have the affiliated ",Object(a.b)("strong",{parentName:"li"},"ServiceAccount")," required."),Object(a.b)("li",{parentName:"ol"},"Create a ",Object(a.b)("strong",{parentName:"li"},"Service")," for that ",Object(a.b)("strong",{parentName:"li"},"Deployment"),"."),Object(a.b)("li",{parentName:"ol"},"Create the ",Object(a.b)("strong",{parentName:"li"},"Gateway")," that uses the default ",Object(a.b)("strong",{parentName:"li"},"Istio Gateway")," to access the ",Object(a.b)("strong",{parentName:"li"},"Services"),"."),Object(a.b)("li",{parentName:"ol"},"Create the ",Object(a.b)("strong",{parentName:"li"},"VirtualService")," that gives us access to the hello world app through the ",Object(a.b)("strong",{parentName:"li"},"Gateway")," connected to the ",Object(a.b)("strong",{parentName:"li"},"Service")," which sits within the ",Object(a.b)("strong",{parentName:"li"},"ServiceMesh")," from the ",Object(a.b)("strong",{parentName:"li"},"IngressController"),"."),Object(a.b)("li",{parentName:"ol"},"Create the ",Object(a.b)("strong",{parentName:"li"},"DestinationRule")," that allows allows access to the ",Object(a.b)("strong",{parentName:"li"},"VirtualService")," using ",Object(a.b)("strong",{parentName:"li"},"MTLS")," from the ",Object(a.b)("strong",{parentName:"li"},"IngressController")," which is a ",Object(a.b)("strong",{parentName:"li"},"Reverse Proxy internal load balancer")," accessed from the external ",Object(a.b)("strong",{parentName:"li"},"AWS LoadBalancer")," tied to the accessible ",Object(a.b)("strong",{parentName:"li"},"DNS Records"),"."),Object(a.b)("li",{parentName:"ol"},"You can now access the microservice from the ",Object(a.b)("strong",{parentName:"li"},"AWS LoadBalancer Route53 alias")," passing the ",Object(a.b)("strong",{parentName:"li"},"internal namespace domain")," as the ",Object(a.b)("strong",{parentName:"li"},"host header"),".")),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# ! helloworld-rbac.yaml file\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRole\nmetadata:\n  name: hello-viewer\n  namespace: default\nspec:\n  rules:\n  - services: ["hello.default.svc.cluster.local"]\n    methods: ["GET", "HEAD"]\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRole\nmetadata:\n  name: world-viewer\n  namespace: default\nspec:\n  rules:\n  - services: ["world.default.svc.cluster.local"]\n    methods: ["GET", "HEAD"]\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRole\nmetadata:\n  name: world-2-viewer\n  namespace: default\nspec:\n  rules:\n  - services: ["world-2.default.svc.cluster.local"]\n    methods: ["GET", "HEAD"]\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRoleBinding\nmetadata:\n  name: istio-ingress-binding\n  namespace: default\nspec:\n  subjects:\n  - properties:\n      source.namespace: "istio-system"\n  roleRef:\n    kind: ServiceRole\n    name: "hello-viewer"\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRoleBinding\nmetadata:\n  name: hello-user-binding\n  namespace: default\nspec:\n  subjects:\n  - user: "cluster.local/ns/default/sa/hello"\n  roleRef:\n    kind: ServiceRole\n    name: "world-viewer"\n---\napiVersion: "rbac.istio.io/v1alpha1"\nkind: ServiceRoleBinding\nmetadata:\n  name: world-user-binding\n  namespace: default\nspec:\n  subjects:\n  - user: "cluster.local/ns/default/sa/world"\n  roleRef:\n    kind: ServiceRole\n    name: "world-2-viewer"\n---\n###\n### Kubernetes Service accounts\n###\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: hello\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: world\n---\n###\n### helloworld.yaml deployments, including a serviceaccount\n### for the hello deployment and the world deployment\n###\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1\n    spec:\n      serviceAccountName: hello  # service account\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: hello\n        - name: NEXT\n          value: "world:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world\n        version: v1\n    spec:\n      serviceAccountName: world  # service account\n      containers:\n      - name: world\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: world\n        - name: NEXT\n          value: "world-2:8080"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world\n  labels:\n    app: world\nspec:\n  selector:\n    app: world\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: world-2\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: world-2\n        version: v1\n    spec:\n      containers:\n      - name: world-2\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: "!!!"\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: world-2\n  labels:\n    app: world-2\nspec:\n  selector:\n    app: world-2\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld\nspec:\n  hosts:\n  - "hello-rbac.example.com"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        subset: v1\n        port:\n          number: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: hello\nspec:\n  host: hello.default.svc.cluster.local\n  # uncomment to enable mutual TLS\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n')),Object(a.b)("p",null,"This again requires the rbac prequisite:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld-rbac-enable.yaml\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\n# ensures mtls is push to side cars\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "legacy"\nspec:\n  host: "end.legacy.svc.cluster.local"\n  trafficPolicy:\n    tls:\n      mode: DISABLE\n')),Object(a.b)("p",null,Object(a.b)("img",{alt:"After applying the files to Istio",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540159695/Screen_Shot_2018-10-22_at_9.07.45_am.png"})),Object(a.b)("p",null,"Evidently enough, it is incredibly important to ensure the routing is set up correctly so there is no large scale failure."),Object(a.b)("h2",{id:"79-end-user-authentication"},"7.9 End-user Authentication"),Object(a.b)("p",null,"Istio currently supports JWT tokens to authenticate users."),Object(a.b)("p",null,"In the implementation, the user will receive a JWT token from an authenticated server after logging in."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"This app will provide us with a token that is ",Object(a.b)("strong",{parentName:"li"},"signed with a key"),"."),Object(a.b)("li",{parentName:"ul"},"The data is not encrypted, but the ",Object(a.b)("strong",{parentName:"li"},"token contains a signature"),", which can be ",Object(a.b)("strong",{parentName:"li"},"verified")," to see ",Object(a.b)("strong",{parentName:"li"},"whether it was really created by the server"),"."),Object(a.b)("li",{parentName:"ul"},"Only the server has the ",Object(a.b)("strong",{parentName:"li"},"private key"),", so we can't recreate or tamper with the token."),Object(a.b)("li",{parentName:"ul"},"Using microservices, every app would need to be ",Object(a.b)("strong",{parentName:"li"},"seperately configured"),"."),Object(a.b)("li",{parentName:"ul"},"Every service would need to ",Object(a.b)("strong",{parentName:"li"},"validate the token"),".",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Once validated the service would need to check whether the user has access to this service."))),Object(a.b)("li",{parentName:"ul"},"With Istio, ",Object(a.b)("strong",{parentName:"li"},"this can be taken away from the app code and managed centrally.")),Object(a.b)("li",{parentName:"ul"},"You can configure the ",Object(a.b)("strong",{parentName:"li"},"jwt token signature/properties")," you expect in into and have ",Object(a.b)("strong",{parentName:"li"},"policies to allow/disallow access to a service."),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},'Example "hello" app might only be accessible if user is authenticated.'),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("strong",{parentName:"li"},"sidecar")," will verify the ",Object(a.b)("strong",{parentName:"li"},"validity")," of the signature, to make sure the token is valid.")))),Object(a.b)("p",null,Object(a.b)("img",{alt:"JWT Token setup",src:"https://res.cloudinary.com/gitgoodclub/image/upload/v1540160832/Screen_Shot_2018-10-22_at_9.26.42_am.png"})),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# Istio with JWT Auth\n# helloworld-jwt.yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: helloworld-gateway\nspec:\n  selector:\n    istio: ingressgateway # use istio default controller\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - "*"\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-auth\nspec:\n  # this is a change to previous\n  hosts:\n  - "auth.kubernetes.newtech.academy"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: auth.default.svc.cluster.local\n        port:\n          number: 8080\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: helloworld-hello\nspec:\n  hosts:\n  - "hello.kubernetes.newtech.academy"\n  gateways:\n  - helloworld-gateway\n  http:\n  - route:\n    - destination:\n        host: hello.default.svc.cluster.local\n        port:\n          number: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: auth\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: auth\n        version: v1\n    spec:\n      containers:\n      - name: auth\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: this is the authentication service\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: auth\n  labels:\n    app: auth\nspec:\n  selector:\n    app: auth\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n---\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: hello\n        version: v1\n    spec:\n      containers:\n      - name: hello\n        image: wardviaene/http-echo\n        env:\n        - name: TEXT\n          value: Hello, you can only reach this service when authenticated\n        ports:\n        - name: http\n          containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\n  labels:\n    app: hello\nspec:\n  selector:\n    app: hello\n  ports:\n  - name: http\n    port: 8080\n    targetPort: 8080\n###\n### Enable TLS\n###\n---\napiVersion: authentication.istio.io/v1alpha1\nkind: "MeshPolicy"\nmetadata:\n  name: "default"\nspec:\n  peers:\n  - mtls: {}\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: "enable-mtls"\n  namespace: "default" # even though we specify a namespace, this rule applies to all namespaces\nspec:\n  host: "*.local"\n  trafficPolicy:\n    tls:\n      mode: ISTIO_MUTUAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n name: "api-server"\nspec:\n host: "kubernetes.default.svc.cluster.local"\n trafficPolicy:\n   tls:\n     mode: DISABLE\n')),Object(a.b)("p",null,"To get to auth, we need to create an alias for ",Object(a.b)("inlineCode",{parentName:"p"},"auth.domain.name")," in Route 53 to expose the load balancer."),Object(a.b)("p",null,"To enable the policy for the JWT token auth to take effect, we need to apply the following to the cluster:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),'# helloworld-jwt-enable.yaml\napiVersion: "authentication.istio.io/v1alpha1"\nkind: "Policy"\nmetadata:\n  name: "jwt-example"\nspec:\n  targets:\n  - name: hello\n  peers:\n  - mtls: {}\n  origins:\n  - jwt:\n      # jwksUri is from auth uri we setup in Route53\n      issuer: "http-echo@http-echo.kubernetes.newtech.academy"\n      jwksUri: "http://auth.kubernetes.newtech.academy/.well-known/jwks.json"\n  principalBinding: USE_ORIGIN\n---\n')),Object(a.b)("p",null,"After fetching the token, we can now access authenticated routes by passing the header ",Object(a.b)("inlineCode",{parentName:"p"},'"Authorization": "Bearer $TOKEN"'),"."),Object(a.b)("p",null,"The example uses ",Object(a.b)("a",l({parentName:"p"},{href:"https://github.com/wardviaene/http-echo/blob/master/main.go"}),"this Github repo")," with the /login route to do auth and another route to check the auth from other services."),Object(a.b)("p",null,"Something useful is that you can also check the logs of the Istio proxy. This can be done with ",Object(a.b)("inlineCode",{parentName:"p"},"kubectl logs <% pod_name %> -c istio-proxy"),"."),Object(a.b)("h2",{id:"710-istio-ingress-traffic"},"7.10 Istio Ingress Traffic"),Object(a.b)("p",null,"To enable ingress traffic to allow to access outside services, we can apply an external service file. The following example will allow the ",Object(a.b)("inlineCode",{parentName:"p"},"ifconfig.co")," hostname to be accessible from the pods."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-yaml"}),"# external-service.yaml\n#\n# http\n#\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: ifconfig-co-http\nspec:\n  hosts:\n  - ifconfig.co\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: DNS\n  location: MESH_EXTERNAL\n---\n#\n# https\n#\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: ifconfig-co-https\nspec:\n  hosts:\n  - ifconfig.co\n  ports:\n  - number: 443\n    name: https\n    protocol: HTTPS\n  resolution: DNS\n  location: MESH_EXTERNAL\n---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: ifconfig-co\nspec:\n  hosts:\n  - ifconfig.co\n  tls:\n  - match:\n    - port: 443\n      sni_hosts:\n      - ifconfig.co\n    route:\n    - destination:\n        host: ifconfig.co\n        port:\n          number: 443\n      weight: 100\n")),Object(a.b)("p",null,"You should now be able to log into the pod to try out contacting other services."),Object(a.b)("h2",{id:"710-distributed-tracing-with-jaegar"},"7.10 Distributed Tracing with Jaegar"),Object(a.b)("p",null,"Jaegar is automatically stored in the ",Object(a.b)("inlineCode",{parentName:"p"},"isto-system"),". You can confirm this with the following:"),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kubectl get pod -n istio-system # istio-tracing pod\n$ kubectl get svc -n istio-system # jaegar-[agent/collector/query]\n# You could export the port for jaegar-query by updating the service\n$ kubectl edit svc jaegar-query -n istio-system # changing ClusterIP to LoadBalancer\n")),Object(a.b)("p",null,"To find the traces, you need to find the svc ",Object(a.b)("strong",{parentName:"p"},"LoadBalancer")," port for Jaegar Query and then you can access the web url using the port."),Object(a.b)("p",null,"This ports are only internal, so you would either need to expose the IP address or use ",Object(a.b)("inlineCode",{parentName:"p"},"kubectl port-forward")," to forward all the ports on."),Object(a.b)("p",null,"To results, you'll need to use the ",Object(a.b)("inlineCode",{parentName:"p"},"open-tracing")," headers."),Object(a.b)("h2",{id:"711-istio-metrics-with-grafana"},"7.11 Istio Metrics with Grafana"),Object(a.b)("p",null,"Similar to Jaegar, you can find the Grafana service by getting the services for the Istio System."),Object(a.b)("pre",null,Object(a.b)("code",l({parentName:"pre"},{className:"language-bash"}),"$ kubectl get svc -n istio-system # grafana\n# You could export the port for grafana by updating the service\n$ kubectl edit svc grafana -n istio-system # changing ClusterIP to LoadBalancer\n")))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Kubernetes/Microservices.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-kubernetes-microservices-md-b72235b3055da5b88449.js.map