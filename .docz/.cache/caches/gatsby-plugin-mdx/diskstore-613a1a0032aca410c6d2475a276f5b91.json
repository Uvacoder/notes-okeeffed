{"expireTime":9007200848610905000,"key":"gatsby-plugin-mdx-entire-payload-29be2b9da3e956d34d71a813c8921a81-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"HackerRank Notes","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":19,"offset":185},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":19,"offset":185},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Hello, World!","position":{"start":{"line":10,"column":4,"offset":190},"end":{"line":10,"column":17,"offset":203},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":187},"end":{"line":10,"column":17,"offset":203},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- Enter your code here. Read input from STDIN. Print output to STDOUT\nhello_world :: IO()\nhello_world = putStrLn \"Hello World\"\n\n\n-- This part relates to Input/Output and can be used as it is. Do not modify this section\nmain = do\n\thello_world","position":{"start":{"line":12,"column":1,"offset":205},"end":{"line":21,"column":4,"offset":462},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Looped Hello, World!","position":{"start":{"line":23,"column":4,"offset":467},"end":{"line":23,"column":24,"offset":487},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":464},"end":{"line":23,"column":24,"offset":487},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Haskell uses recursion, not loops:","position":{"start":{"line":25,"column":1,"offset":489},"end":{"line":25,"column":35,"offset":523},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":489},"end":{"line":25,"column":35,"offset":523},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"{-# LANGUAGE FlexibleInstances, UndecidableInstances, DuplicateRecordFields #-}\n\nmodule Main where\n\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport Data.List\nimport Data.List.Split\nimport Data.Set\nimport Debug.Trace\nimport System.Environment\nimport System.IO\nimport System.IO.Unsafe\n\nprintNTimes n\n    | n == 1        = putStrLn \"Hello World\"\n    | otherwise     =\n        do\n            putStrLn \"Hello World\"\n            printNTimes (n-1)\n\nmain :: IO()\nmain = do\n    n <- readLn :: IO Int\n    printNTimes n","position":{"start":{"line":27,"column":1,"offset":525},"end":{"line":54,"column":4,"offset":1063},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Print a number n times","position":{"start":{"line":56,"column":4,"offset":1068},"end":{"line":56,"column":26,"offset":1090},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":1065},"end":{"line":56,"column":26,"offset":1090},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Based on input:","position":{"start":{"line":58,"column":1,"offset":1092},"end":{"line":58,"column":16,"offset":1107},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":1092},"end":{"line":58,"column":16,"offset":1107},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"3\n1\n2\n3","position":{"start":{"line":60,"column":1,"offset":1109},"end":{"line":65,"column":4,"offset":1129},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Expect to get:","position":{"start":{"line":67,"column":1,"offset":1131},"end":{"line":67,"column":15,"offset":1145},"indent":[]}}],"position":{"start":{"line":67,"column":1,"offset":1131},"end":{"line":67,"column":15,"offset":1145},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"1\n1\n1\n2\n2\n2\n3\n3\n3","position":{"start":{"line":69,"column":1,"offset":1147},"end":{"line":79,"column":4,"offset":1177},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Answer:","position":{"start":{"line":81,"column":1,"offset":1179},"end":{"line":81,"column":8,"offset":1186},"indent":[]}}],"position":{"start":{"line":81,"column":1,"offset":1179},"end":{"line":81,"column":8,"offset":1186},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"f :: Int -> [Int] -> [Int]\nf n arr = -- Complete this function\n    do\n        [num | num <- arr, _ <- [1..n]]\n\n-- This part handles the Input and Output and can be used as it is. Do not modify this part.\nmain :: IO ()\nmain = getContents >>=\n       mapM_ print. (\\(n:arr) -> f n arr). map read. words","position":{"start":{"line":83,"column":1,"offset":1188},"end":{"line":93,"column":4,"offset":1502},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Write your own filter","position":{"start":{"line":95,"column":4,"offset":1507},"end":{"line":95,"column":25,"offset":1528},"indent":[]}}],"position":{"start":{"line":95,"column":1,"offset":1504},"end":{"line":95,"column":25,"offset":1528},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Write a filter function where given delimiter ","position":{"start":{"line":97,"column":1,"offset":1530},"end":{"line":97,"column":47,"offset":1576},"indent":[]}},{"type":"inlineCode","value":"n","position":{"start":{"line":97,"column":47,"offset":1576},"end":{"line":97,"column":50,"offset":1579},"indent":[]}},{"type":"text","value":" you return all numbers smaller.","position":{"start":{"line":97,"column":50,"offset":1579},"end":{"line":97,"column":82,"offset":1611},"indent":[]}}],"position":{"start":{"line":97,"column":1,"offset":1530},"end":{"line":97,"column":82,"offset":1611},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"f :: Int -> [Int] -> [Int]\nf n arr =\n    do\n        [num | num <- arr, num < n]\n\n-- The Input/Output section. You do not need to change or modify this part\nmain = do\n    n <- readLn :: IO Int\n    inputdata <- getContents\n    let\n        numbers = map read (lines inputdata) :: [Int]\n    putStrLn . unlines $ (map show . f n) numbers","position":{"start":{"line":99,"column":1,"offset":1613},"end":{"line":112,"column":4,"offset":1960},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":115,"column":1,"offset":1963},"end":{"line":115,"column":31,"offset":1993},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":115,"column":31,"offset":1993}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"hackerrank-notes\"\n    }}>{`HackerRank Notes`}</h1>\n    <h2 {...{\n      \"id\": \"hello-world\"\n    }}>{`Hello, World!`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- Enter your code here. Read input from STDIN. Print output to STDOUT\nhello_world :: IO()\nhello_world = putStrLn \"Hello World\"\n\n\n-- This part relates to Input/Output and can be used as it is. Do not modify this section\nmain = do\n    hello_world\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"looped-hello-world\"\n    }}>{`Looped Hello, World!`}</h2>\n    <p>{`Haskell uses recursion, not loops:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`{-# LANGUAGE FlexibleInstances, UndecidableInstances, DuplicateRecordFields #-}\n\nmodule Main where\n\nimport Control.Monad\nimport Data.Array\nimport Data.Bits\nimport Data.List\nimport Data.List.Split\nimport Data.Set\nimport Debug.Trace\nimport System.Environment\nimport System.IO\nimport System.IO.Unsafe\n\nprintNTimes n\n    | n == 1        = putStrLn \"Hello World\"\n    | otherwise     =\n        do\n            putStrLn \"Hello World\"\n            printNTimes (n-1)\n\nmain :: IO()\nmain = do\n    n <- readLn :: IO Int\n    printNTimes n\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"print-a-number-n-times\"\n    }}>{`Print a number n times`}</h2>\n    <p>{`Based on input:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`3\n1\n2\n3\n`}</code></pre>\n    <p>{`Expect to get:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`1\n1\n1\n2\n2\n2\n3\n3\n3\n`}</code></pre>\n    <p>{`Answer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`f :: Int -> [Int] -> [Int]\nf n arr = -- Complete this function\n    do\n        [num | num <- arr, _ <- [1..n]]\n\n-- This part handles the Input and Output and can be used as it is. Do not modify this part.\nmain :: IO ()\nmain = getContents >>=\n       mapM_ print. (\\\\(n:arr) -> f n arr). map read. words\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"write-your-own-filter\"\n    }}>{`Write your own filter`}</h2>\n    <p>{`Write a filter function where given delimiter `}<inlineCode parentName=\"p\">{`n`}</inlineCode>{` you return all numbers smaller.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`f :: Int -> [Int] -> [Int]\nf n arr =\n    do\n        [num | num <- arr, num < n]\n\n-- The Input/Output section. You do not need to change or modify this part\nmain = do\n    n <- readLn :: IO Int\n    inputdata <- getContents\n    let\n        numbers = map read (lines inputdata) :: [Int]\n    putStrLn . unlines $ (map show . f n) numbers\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}