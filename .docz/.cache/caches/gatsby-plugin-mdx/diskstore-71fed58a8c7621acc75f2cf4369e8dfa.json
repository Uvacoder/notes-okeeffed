{"expireTime":9007200848610849000,"key":"gatsby-plugin-mdx-entire-payload-5a12ead04527d61dfef8dde8de64ccb9-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Developer's Guide to TypeScript","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":34,"offset":200},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":34,"offset":200},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Types","position":{"start":{"line":10,"column":4,"offset":205},"end":{"line":10,"column":9,"offset":210},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":202},"end":{"line":10,"column":9,"offset":210},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For types, we have all our basic types and we can also have custom types.","position":{"start":{"line":12,"column":1,"offset":212},"end":{"line":12,"column":74,"offset":285},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":212},"end":{"line":12,"column":74,"offset":285},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are two types, ","position":{"start":{"line":14,"column":1,"offset":287},"end":{"line":14,"column":22,"offset":308},"indent":[]}},{"type":"inlineCode","value":"primitive","position":{"start":{"line":14,"column":22,"offset":308},"end":{"line":14,"column":33,"offset":319},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":14,"column":33,"offset":319},"end":{"line":14,"column":38,"offset":324},"indent":[]}},{"type":"inlineCode","value":"object","position":{"start":{"line":14,"column":38,"offset":324},"end":{"line":14,"column":46,"offset":332},"indent":[]}},{"type":"text","value":" - the ","position":{"start":{"line":14,"column":46,"offset":332},"end":{"line":14,"column":53,"offset":339},"indent":[]}},{"type":"inlineCode","value":"object","position":{"start":{"line":14,"column":53,"offset":339},"end":{"line":14,"column":61,"offset":347},"indent":[]}},{"type":"text","value":" types itself can be what we define.","position":{"start":{"line":14,"column":61,"offset":347},"end":{"line":14,"column":97,"offset":383},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":287},"end":{"line":14,"column":97,"offset":383},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Why do we care? The compiler uses it to search for errors and it allows other engineers to understand what type of data is flowing around.","position":{"start":{"line":16,"column":1,"offset":385},"end":{"line":16,"column":139,"offset":523},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":385},"end":{"line":16,"column":139,"offset":523},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"interface Todo {\n  id: number;\n  completed: boolean;\n};\n\nconst todo = obj.data as Todo;","position":{"start":{"line":18,"column":1,"offset":525},"end":{"line":25,"column":4,"offset":630},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Declaring types examples","position":{"start":{"line":27,"column":4,"offset":635},"end":{"line":27,"column":28,"offset":659},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":632},"end":{"line":27,"column":28,"offset":659},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"// array\nlet colors: string[] = ['a', 'b', 'c'];\n\n// class\nclass Car {}\nlet car: Car = new Car();\n\n// object literal\nlet point: { x: number, y: number } = {\n  x: 10,\n  y: 20\n};\n\n// functions\nconst logNumber: (i: number) => void = (i: number) => {\n  console.log(i);\n};","position":{"start":{"line":29,"column":1,"offset":661},"end":{"line":47,"column":4,"offset":946},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The object literal gets a bit nasty, but we have ways around this using ","position":{"start":{"line":49,"column":1,"offset":948},"end":{"line":49,"column":73,"offset":1020},"indent":[]}},{"type":"inlineCode","value":"types","position":{"start":{"line":49,"column":73,"offset":1020},"end":{"line":49,"column":80,"offset":1027},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":49,"column":80,"offset":1027},"end":{"line":49,"column":85,"offset":1032},"indent":[]}},{"type":"inlineCode","value":"interfaces","position":{"start":{"line":49,"column":85,"offset":1032},"end":{"line":49,"column":97,"offset":1044},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":49,"column":97,"offset":1044},"end":{"line":49,"column":98,"offset":1045},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":948},"end":{"line":49,"column":98,"offset":1045},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"The 'any' type","position":{"start":{"line":51,"column":4,"offset":1050},"end":{"line":51,"column":18,"offset":1064},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":1047},"end":{"line":51,"column":18,"offset":1064},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const json = '{\"x\":10, \"y\": 20}';\nconst coordinates = JSON.parse(json); // by default gets any time\n\n// this is the better\nconst coor: { x: number, y: number } = JSON.parse(json);","position":{"start":{"line":53,"column":1,"offset":1066},"end":{"line":59,"column":4,"offset":1263},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"The 'void' and 'never' return types","position":{"start":{"line":61,"column":4,"offset":1268},"end":{"line":61,"column":39,"offset":1303},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":1265},"end":{"line":61,"column":39,"offset":1303},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"// Returns nothing\nconst logger = (message: string): void => console.log(message);\n\n// Never returns\nconst throwError = (message: string): never => throw new Error(message);","position":{"start":{"line":63,"column":1,"offset":1305},"end":{"line":69,"column":4,"offset":1496},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Interfaces","position":{"start":{"line":71,"column":4,"offset":1501},"end":{"line":71,"column":14,"offset":1511},"indent":[]}}],"position":{"start":{"line":71,"column":1,"offset":1498},"end":{"line":71,"column":14,"offset":1511},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"interface Vehicle {\n  name: string;\n  year: number;\n  broken: boolean;\n}\n\nconst oldCivic = {\n  name: 'civic',\n  year: 2000,\n  broken: true\n};\n\nconst printVehicle = (vehicle: Vehicle): void => {};","position":{"start":{"line":73,"column":1,"offset":1513},"end":{"line":87,"column":4,"offset":1726},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Abstract Classes","position":{"start":{"line":89,"column":4,"offset":1731},"end":{"line":89,"column":20,"offset":1747},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":1728},"end":{"line":89,"column":20,"offset":1747},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Good for classes that we only want to use to extend. Think expectation vs reality.","position":{"start":{"line":91,"column":1,"offset":1749},"end":{"line":91,"column":83,"offset":1831},"indent":[]}}],"position":{"start":{"line":91,"column":1,"offset":1749},"end":{"line":91,"column":83,"offset":1831},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Abstract classes:","position":{"start":{"line":93,"column":1,"offset":1833},"end":{"line":93,"column":18,"offset":1850},"indent":[]}}],"position":{"start":{"line":93,"column":1,"offset":1833},"end":{"line":93,"column":18,"offset":1850},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Cannot create objects directly","position":{"start":{"line":95,"column":4,"offset":1855},"end":{"line":95,"column":34,"offset":1885},"indent":[]}}],"position":{"start":{"line":95,"column":4,"offset":1855},"end":{"line":95,"column":34,"offset":1885},"indent":[]}}],"position":{"start":{"line":95,"column":1,"offset":1852},"end":{"line":95,"column":34,"offset":1885},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Only used as a parent class","position":{"start":{"line":96,"column":4,"offset":1889},"end":{"line":96,"column":31,"offset":1916},"indent":[]}}],"position":{"start":{"line":96,"column":4,"offset":1889},"end":{"line":96,"column":31,"offset":1916},"indent":[]}}],"position":{"start":{"line":96,"column":1,"offset":1886},"end":{"line":96,"column":31,"offset":1916},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Can contain real implementations of some methods","position":{"start":{"line":97,"column":4,"offset":1920},"end":{"line":97,"column":52,"offset":1968},"indent":[]}}],"position":{"start":{"line":97,"column":4,"offset":1920},"end":{"line":97,"column":52,"offset":1968},"indent":[]}}],"position":{"start":{"line":97,"column":1,"offset":1917},"end":{"line":97,"column":52,"offset":1968},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Can refer to methods that don't exist yet","position":{"start":{"line":98,"column":4,"offset":1972},"end":{"line":98,"column":45,"offset":2013},"indent":[]}}],"position":{"start":{"line":98,"column":4,"offset":1972},"end":{"line":98,"column":45,"offset":2013},"indent":[]}}],"position":{"start":{"line":98,"column":1,"offset":1969},"end":{"line":98,"column":45,"offset":2013},"indent":[]}}],"position":{"start":{"line":95,"column":1,"offset":1852},"end":{"line":98,"column":45,"offset":2013},"indent":[1,1,1]}},{"type":"code","lang":"javascript","meta":null,"value":"abstract class Examlpe {\n  // promises we will create this func later\n  abstract requireFunc(argA: number): void;\n\n  swap = (a:number) => requireFunc(a);\n}","position":{"start":{"line":100,"column":1,"offset":2015},"end":{"line":107,"column":4,"offset":2188},"indent":[1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Abstract classes vs Interfaces","position":{"start":{"line":109,"column":4,"offset":2193},"end":{"line":109,"column":34,"offset":2223},"indent":[]}}],"position":{"start":{"line":109,"column":1,"offset":2190},"end":{"line":109,"column":34,"offset":2223},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Interfaces promot loose coupling, Abstract/Inheritance is for strong coupling","position":{"start":{"line":111,"column":3,"offset":2227},"end":{"line":111,"column":80,"offset":2304},"indent":[]}}],"position":{"start":{"line":111,"column":3,"offset":2227},"end":{"line":111,"column":80,"offset":2304},"indent":[]}}],"position":{"start":{"line":111,"column":1,"offset":2225},"end":{"line":111,"column":80,"offset":2304},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Interfaces for very different objects we want to work together, Abstract/Inheritance for when we want to build up a definition of an object","position":{"start":{"line":112,"column":3,"offset":2307},"end":{"line":112,"column":142,"offset":2446},"indent":[]}}],"position":{"start":{"line":112,"column":3,"offset":2307},"end":{"line":112,"column":142,"offset":2446},"indent":[]}}],"position":{"start":{"line":112,"column":1,"offset":2305},"end":{"line":112,"column":142,"offset":2446},"indent":[]}}],"position":{"start":{"line":111,"column":1,"offset":2225},"end":{"line":112,"column":142,"offset":2446},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Enums","position":{"start":{"line":114,"column":4,"offset":2451},"end":{"line":114,"column":9,"offset":2456},"indent":[]}}],"position":{"start":{"line":114,"column":1,"offset":2448},"end":{"line":114,"column":9,"offset":2456},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"enum Result {\n  Win = 'W',\n  Loss = 'L',\n  Draw = 'D'\n}","position":{"start":{"line":116,"column":1,"offset":2458},"end":{"line":122,"column":4,"offset":2531},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generics","position":{"start":{"line":124,"column":4,"offset":2536},"end":{"line":124,"column":12,"offset":2544},"indent":[]}}],"position":{"start":{"line":124,"column":1,"offset":2533},"end":{"line":124,"column":12,"offset":2544},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Like function args, but for types in class/function definitions","position":{"start":{"line":126,"column":3,"offset":2548},"end":{"line":126,"column":66,"offset":2611},"indent":[]}}],"position":{"start":{"line":126,"column":3,"offset":2548},"end":{"line":126,"column":66,"offset":2611},"indent":[]}}],"position":{"start":{"line":126,"column":1,"offset":2546},"end":{"line":126,"column":66,"offset":2611},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Allow us to define the type of a property/argument/return value at a future point","position":{"start":{"line":127,"column":3,"offset":2614},"end":{"line":127,"column":84,"offset":2695},"indent":[]}}],"position":{"start":{"line":127,"column":3,"offset":2614},"end":{"line":127,"column":84,"offset":2695},"indent":[]}}],"position":{"start":{"line":127,"column":1,"offset":2612},"end":{"line":127,"column":84,"offset":2695},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Used heavily when writing useable code","position":{"start":{"line":128,"column":3,"offset":2698},"end":{"line":128,"column":41,"offset":2736},"indent":[]}}],"position":{"start":{"line":128,"column":3,"offset":2698},"end":{"line":128,"column":41,"offset":2736},"indent":[]}}],"position":{"start":{"line":128,"column":1,"offset":2696},"end":{"line":128,"column":41,"offset":2736},"indent":[]}}],"position":{"start":{"line":126,"column":1,"offset":2546},"end":{"line":128,"column":41,"offset":2736},"indent":[1,1]}},{"type":"code","lang":"javascript","meta":null,"value":"class HoldAnything<TypeOfData> {\n  data: TypeOfData;\n}\n\nconst holdNumber = new HolderAnything<number>();\nconst holdString = new HolderAnything<string>();\n\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\nconst holdCoordinates = new HolderAnything<Coordinates>();\n\n// TypeOfData can actually be called anything\n// Convention is normally T, but then we go alphabetical order if we need multiple generics\n\nclass holdMultipleAnything<T,U,V> {\n  firstThing: T;\n  secondThing: U;\n  thirdThing: V;\n}\n\nconst holdAllTheThings = new holdMultipleAnything<string, number, Coordinates>();","position":{"start":{"line":130,"column":1,"offset":2738},"end":{"line":155,"column":4,"offset":3335},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Constraints with Generics","position":{"start":{"line":157,"column":5,"offset":3341},"end":{"line":157,"column":30,"offset":3366},"indent":[]}}],"position":{"start":{"line":157,"column":1,"offset":3337},"end":{"line":157,"column":30,"offset":3366},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Cannot call base methods on generics since there is no guarantee without a interface","position":{"start":{"line":159,"column":3,"offset":3370},"end":{"line":159,"column":87,"offset":3454},"indent":[]}}],"position":{"start":{"line":159,"column":3,"offset":3370},"end":{"line":159,"column":87,"offset":3454},"indent":[]}}],"position":{"start":{"line":159,"column":1,"offset":3368},"end":{"line":159,"column":87,"offset":3454},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[],"position":{"start":{"line":160,"column":1,"offset":3455},"end":{"line":160,"column":2,"offset":3456},"indent":[]}}],"position":{"start":{"line":159,"column":1,"offset":3368},"end":{"line":160,"column":2,"offset":3456},"indent":[1]}},{"type":"code","lang":"javascript","meta":null,"value":"class Car {\n  print() {\n    console.log('Car');\n  }\n}\n\nclass House {\n  print() {\n    console.log('House');\n  }\n}\n\ninterface Printable {\n  print(): void;\n}\n\nfunction printWhatever<T extends Printable>(el: T) {\n  el.print();\n}\n\nprintWhatever(new Car());\nprintWhatever(new House());","position":{"start":{"line":162,"column":1,"offset":3458},"end":{"line":185,"column":4,"offset":3755},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"code","lang":"javascript","meta":null,"value":"// what you have to do without method overloading\nclass Utility {\n  static function addNumbers(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function addStrings(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.addNumbers(1,2) // return 2\nUtility.addStrings('Hello','World') // return \"Hello World\"\n\n// method overloading in other languages\nclass Utility {\n  static function add(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function add(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"Hello World\"\n\n// method overloading in other typescript\nclass Utility {\n  static function add(a:number, b: number): number;\n  static function add(a:string, b: string): string;\n\n  static function add(a, b) {\n    return a + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"HelloWorld\"","position":{"start":{"line":187,"column":1,"offset":3757},"end":{"line":225,"column":4,"offset":4707},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":228,"column":1,"offset":4710},"end":{"line":228,"column":31,"offset":4740},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":228,"column":31,"offset":4740}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"developers-guide-to-typescript\"\n    }}>{`Developer's Guide to TypeScript`}</h1>\n    <h2 {...{\n      \"id\": \"types\"\n    }}>{`Types`}</h2>\n    <p>{`For types, we have all our basic types and we can also have custom types.`}</p>\n    <p>{`There are two types, `}<inlineCode parentName=\"p\">{`primitive`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`object`}</inlineCode>{` - the `}<inlineCode parentName=\"p\">{`object`}</inlineCode>{` types itself can be what we define.`}</p>\n    <p>{`Why do we care? The compiler uses it to search for errors and it allows other engineers to understand what type of data is flowing around.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`interface Todo {\n  id: number;\n  completed: boolean;\n};\n\nconst todo = obj.data as Todo;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"declaring-types-examples\"\n    }}>{`Declaring types examples`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// array\nlet colors: string[] = ['a', 'b', 'c'];\n\n// class\nclass Car {}\nlet car: Car = new Car();\n\n// object literal\nlet point: { x: number, y: number } = {\n  x: 10,\n  y: 20\n};\n\n// functions\nconst logNumber: (i: number) => void = (i: number) => {\n  console.log(i);\n};\n`}</code></pre>\n    <p>{`The object literal gets a bit nasty, but we have ways around this using `}<inlineCode parentName=\"p\">{`types`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`interfaces`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"the-any-type\"\n    }}>{`The 'any' type`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const json = '{\"x\":10, \"y\": 20}';\nconst coordinates = JSON.parse(json); // by default gets any time\n\n// this is the better\nconst coor: { x: number, y: number } = JSON.parse(json);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"the-void-and-never-return-types\"\n    }}>{`The 'void' and 'never' return types`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// Returns nothing\nconst logger = (message: string): void => console.log(message);\n\n// Never returns\nconst throwError = (message: string): never => throw new Error(message);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"interfaces\"\n    }}>{`Interfaces`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`interface Vehicle {\n  name: string;\n  year: number;\n  broken: boolean;\n}\n\nconst oldCivic = {\n  name: 'civic',\n  year: 2000,\n  broken: true\n};\n\nconst printVehicle = (vehicle: Vehicle): void => {};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"abstract-classes\"\n    }}>{`Abstract Classes`}</h2>\n    <p>{`Good for classes that we only want to use to extend. Think expectation vs reality.`}</p>\n    <p>{`Abstract classes:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Cannot create objects directly`}</li>\n      <li parentName=\"ol\">{`Only used as a parent class`}</li>\n      <li parentName=\"ol\">{`Can contain real implementations of some methods`}</li>\n      <li parentName=\"ol\">{`Can refer to methods that don't exist yet`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`abstract class Examlpe {\n  // promises we will create this func later\n  abstract requireFunc(argA: number): void;\n\n  swap = (a:number) => requireFunc(a);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"abstract-classes-vs-interfaces\"\n    }}>{`Abstract classes vs Interfaces`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Interfaces promot loose coupling, Abstract/Inheritance is for strong coupling`}</li>\n      <li parentName=\"ul\">{`Interfaces for very different objects we want to work together, Abstract/Inheritance for when we want to build up a definition of an object`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"enums\"\n    }}>{`Enums`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`enum Result {\n  Win = 'W',\n  Loss = 'L',\n  Draw = 'D'\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"generics\"\n    }}>{`Generics`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Like function args, but for types in class/function definitions`}</li>\n      <li parentName=\"ul\">{`Allow us to define the type of a property/argument/return value at a future point`}</li>\n      <li parentName=\"ul\">{`Used heavily when writing useable code`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`class HoldAnything<TypeOfData> {\n  data: TypeOfData;\n}\n\nconst holdNumber = new HolderAnything<number>();\nconst holdString = new HolderAnything<string>();\n\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\nconst holdCoordinates = new HolderAnything<Coordinates>();\n\n// TypeOfData can actually be called anything\n// Convention is normally T, but then we go alphabetical order if we need multiple generics\n\nclass holdMultipleAnything<T,U,V> {\n  firstThing: T;\n  secondThing: U;\n  thirdThing: V;\n}\n\nconst holdAllTheThings = new holdMultipleAnything<string, number, Coordinates>();\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"constraints-with-generics\"\n    }}>{`Constraints with Generics`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Cannot call base methods on generics since there is no guarantee without a interface`}</li>\n      <li parentName=\"ul\"></li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`class Car {\n  print() {\n    console.log('Car');\n  }\n}\n\nclass House {\n  print() {\n    console.log('House');\n  }\n}\n\ninterface Printable {\n  print(): void;\n}\n\nfunction printWhatever<T extends Printable>(el: T) {\n  el.print();\n}\n\nprintWhatever(new Car());\nprintWhatever(new House());\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// what you have to do without method overloading\nclass Utility {\n  static function addNumbers(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function addStrings(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.addNumbers(1,2) // return 2\nUtility.addStrings('Hello','World') // return \"Hello World\"\n\n// method overloading in other languages\nclass Utility {\n  static function add(a:number, b: number): number {\n    return a + b;\n  }\n\n  static function add(a:string, b: string): string {\n    return a + \" \" + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"Hello World\"\n\n// method overloading in other typescript\nclass Utility {\n  static function add(a:number, b: number): number;\n  static function add(a:string, b: string): string;\n\n  static function add(a, b) {\n    return a + b;\n  }\n}\nUtility.add(1,2) // return 2\nUtility.add('Hello','World') // return \"HelloWorld\"\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}