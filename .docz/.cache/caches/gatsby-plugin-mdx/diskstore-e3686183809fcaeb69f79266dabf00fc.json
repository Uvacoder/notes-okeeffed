{"expireTime":9007200848610924000,"key":"gatsby-plugin-mdx-entire-payload-153d8bfdae8ae9589b1743a7efe75043-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Abstract Factory","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":19,"offset":185},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":19,"offset":185},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here we will cover the ","position":{"start":{"line":10,"column":1,"offset":187},"end":{"line":10,"column":24,"offset":210},"indent":[]}},{"type":"inlineCode","value":"creational","position":{"start":{"line":10,"column":24,"offset":210},"end":{"line":10,"column":36,"offset":222},"indent":[]}},{"type":"text","value":" design pattern ","position":{"start":{"line":10,"column":36,"offset":222},"end":{"line":10,"column":52,"offset":238},"indent":[]}},{"type":"inlineCode","value":"Abstract Factory","position":{"start":{"line":10,"column":52,"offset":238},"end":{"line":10,"column":70,"offset":256},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":10,"column":70,"offset":256},"end":{"line":10,"column":71,"offset":257},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":187},"end":{"line":10,"column":71,"offset":257},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Another creational pattern, the ","position":{"start":{"line":12,"column":1,"offset":259},"end":{"line":12,"column":33,"offset":291},"indent":[]}},{"type":"inlineCode","value":"Factory","position":{"start":{"line":12,"column":33,"offset":291},"end":{"line":12,"column":42,"offset":300},"indent":[]}},{"type":"text","value":" design pattern, differs from Abstract Factory in that the factory method is a single method, whereas an abstract factory is an object.","position":{"start":{"line":12,"column":42,"offset":300},"end":{"line":12,"column":177,"offset":435},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":259},"end":{"line":12,"column":177,"offset":435},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"... the Factory Method pattern uses inheritance and relies on a subclass to handle the desired object instantiation.","position":{"start":{"line":14,"column":3,"offset":439},"end":{"line":14,"column":119,"offset":555},"indent":[]}}],"position":{"start":{"line":14,"column":3,"offset":439},"end":{"line":14,"column":119,"offset":555},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":437},"end":{"line":14,"column":119,"offset":555},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This quote assumes the object is calling its own factory method, therefore the only thing that could change the return value would be a subclass.","position":{"start":{"line":16,"column":1,"offset":557},"end":{"line":16,"column":146,"offset":702},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":557},"end":{"line":16,"column":146,"offset":702},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"... with the Abstract Factory pattern, a class delegates the responsibility of object instantiation to another object via composition ...","position":{"start":{"line":18,"column":3,"offset":706},"end":{"line":18,"column":140,"offset":843},"indent":[]}}],"position":{"start":{"line":18,"column":3,"offset":706},"end":{"line":18,"column":140,"offset":843},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":704},"end":{"line":18,"column":140,"offset":843},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here there is an object A who wants to make a Foo object. Instead of making the Foo object itself (like in the factory method), it's going to get a different object (the abstract factory) to create the Foo object.","position":{"start":{"line":20,"column":1,"offset":845},"end":{"line":20,"column":214,"offset":1058},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":845},"end":{"line":20,"column":214,"offset":1058},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"// defining our abstract products\ninterface Processor {\n    performOperation(): void;\n}\n\ninterface HardDisk {\n    storeData(): void;\n}\n\ninterface Monitor {\n    displayPicture(): void;\n}\n\n// defining our concrete products\nclass ExpensiveProcessor implements Processor {\n    performOperation() {\n        console.log('Operation will perform quickly!');\n    }\n}\n\nclass CheapProcessor implements Processor {\n    performOperation() {\n        console.log('Operation will perform slowly!');\n    }\n}\n\nclass ExpensiveHDD implements HardDisk {\n    storeData() {\n        console.log('Data will take less time to store');\n    }\n}\n\nclass CheapHDD implements HardDisk {\n    storeData() {\n        console.log('Data will take more time to store');\n    }\n}\n\nclass HighResMonitor implements Monitor {\n    displayPicture() {\n        console.log('High picture quality');\n    }\n}\n\nclass LowResMonitor implements Monitor {\n    displayPicture() {\n        console.log('Low picture quality');\n    }\n}\n\n// defining the abstract factory\ninterface MachineAbstractFactory {\n    // each factory needs to implement these methods\n    getProcessor(): Processor;\n    getHardDisk(): HardDisk;\n    getMonitor(): Monitor;\n}\n\n// defining our concrete factories\nclass HighBudgetMachineFactory implements MachineAbstractFactory {\n    getProcessor(): Processor {\n        return new ExpensiveProcessor();\n    }\n\n    getHardDisk(): HardDisk {\n        return new ExpensiveHDD();\n    }\n\n    getMonitor(): Monitor {\n        return new HighResMonitor();\n    }\n}\n\nclass LowBudgetMachineFactory implements MachineAbstractFactory {\n    getProcessor(): Processor {\n        return new CheapProcessor();\n    }\n\n    getHardDisk(): HardDisk {\n        return new CheapHDD();\n    }\n\n    getMonitor(): Monitor {\n        return new LowResMonitor();\n    }\n}\n\n// defining our client and final product\ninterface Machine {\n    processor: Processor;\n    hdd: HardDisk;\n    monitor: Monitor;\n}\n\nclass ComputerShop {\n    // change access modifiers as suits\n    public category: MachineAbstractFactory;\n\n    // we'll pass a factory as category during instantiation\n    constructor(category: MachineAbstractFactory) {\n        this.category = category;\n    }\n\n    assembleMachine(): Machine {\n        const processor = this.category.getProcessor();\n        const hdd = this.category.getHardDisk();\n        const monitor = this.category.getMonitor();\n\n        // to be explicit\n        const machine: Machine = {\n            processor,\n            hdd,\n            monitor\n        }\n        return machine;\n    }\n}\n\n// running the code in action!\nconst cheapFactory = new LowBudgetMachineFactory();\nconst expensiveFactory = new HighBudgetMachineFactory();\n\n// ensure to pass the factory in during instantiation\n// using let to show variability, in code these\n// would likely be functions that take a factory\n// arg and constants for shop/machine\nlet shop;\nlet machine;\n\nshop = new ComputerShop(cheapFactory);\nmachine = shop.assembleMachine();\nmachine.hdd.storeData();\nmachine.processor.performOperation();\nmachine.monitor.displayPicture();\n\nshop = new ComputerShop(expensiveFactory);\nmachine = shop.assembleMachine();\nmachine.hdd.storeData();\nmachine.processor.performOperation();\nmachine.monitor.displayPicture();","position":{"start":{"line":22,"column":1,"offset":1060},"end":{"line":163,"column":4,"offset":4321},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"References","position":{"start":{"line":165,"column":4,"offset":4326},"end":{"line":165,"column":14,"offset":4336},"indent":[]}}],"position":{"start":{"line":165,"column":1,"offset":4323},"end":{"line":165,"column":14,"offset":4336},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns","children":[{"type":"text","value":"Difference between factory and abstract factory","position":{"start":{"line":167,"column":4,"offset":4341},"end":{"line":167,"column":51,"offset":4388},"indent":[]}}],"position":{"start":{"line":167,"column":3,"offset":4340},"end":{"line":167,"column":175,"offset":4512},"indent":[]}}],"position":{"start":{"line":167,"column":3,"offset":4340},"end":{"line":167,"column":175,"offset":4512},"indent":[]}}],"position":{"start":{"line":167,"column":1,"offset":4338},"end":{"line":167,"column":175,"offset":4512},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://www.codeproject.com/Articles/716413/Factory-Method-Pattern-vs-Abstract-Factory-Pattern","children":[{"type":"text","value":"ASP.NET Abstract Factory vs Factory","position":{"start":{"line":168,"column":4,"offset":4516},"end":{"line":168,"column":39,"offset":4551},"indent":[]}}],"position":{"start":{"line":168,"column":3,"offset":4515},"end":{"line":168,"column":136,"offset":4648},"indent":[]}}],"position":{"start":{"line":168,"column":3,"offset":4515},"end":{"line":168,"column":136,"offset":4648},"indent":[]}}],"position":{"start":{"line":168,"column":1,"offset":4513},"end":{"line":168,"column":136,"offset":4648},"indent":[]}}],"position":{"start":{"line":167,"column":1,"offset":4338},"end":{"line":168,"column":136,"offset":4648},"indent":[1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":171,"column":1,"offset":4651},"end":{"line":171,"column":31,"offset":4681},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":171,"column":31,"offset":4681}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"abstract-factory\"\n    }}>{`Abstract Factory`}</h1>\n    <p>{`Here we will cover the `}<inlineCode parentName=\"p\">{`creational`}</inlineCode>{` design pattern `}<inlineCode parentName=\"p\">{`Abstract Factory`}</inlineCode>{`.`}</p>\n    <p>{`Another creational pattern, the `}<inlineCode parentName=\"p\">{`Factory`}</inlineCode>{` design pattern, differs from Abstract Factory in that the factory method is a single method, whereas an abstract factory is an object.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`... the Factory Method pattern uses inheritance and relies on a subclass to handle the desired object instantiation.`}</p>\n    </blockquote>\n    <p>{`This quote assumes the object is calling its own factory method, therefore the only thing that could change the return value would be a subclass.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`... with the Abstract Factory pattern, a class delegates the responsibility of object instantiation to another object via composition ...`}</p>\n    </blockquote>\n    <p>{`Here there is an object A who wants to make a Foo object. Instead of making the Foo object itself (like in the factory method), it's going to get a different object (the abstract factory) to create the Foo object.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// defining our abstract products\ninterface Processor {\n    performOperation(): void;\n}\n\ninterface HardDisk {\n    storeData(): void;\n}\n\ninterface Monitor {\n    displayPicture(): void;\n}\n\n// defining our concrete products\nclass ExpensiveProcessor implements Processor {\n    performOperation() {\n        console.log('Operation will perform quickly!');\n    }\n}\n\nclass CheapProcessor implements Processor {\n    performOperation() {\n        console.log('Operation will perform slowly!');\n    }\n}\n\nclass ExpensiveHDD implements HardDisk {\n    storeData() {\n        console.log('Data will take less time to store');\n    }\n}\n\nclass CheapHDD implements HardDisk {\n    storeData() {\n        console.log('Data will take more time to store');\n    }\n}\n\nclass HighResMonitor implements Monitor {\n    displayPicture() {\n        console.log('High picture quality');\n    }\n}\n\nclass LowResMonitor implements Monitor {\n    displayPicture() {\n        console.log('Low picture quality');\n    }\n}\n\n// defining the abstract factory\ninterface MachineAbstractFactory {\n    // each factory needs to implement these methods\n    getProcessor(): Processor;\n    getHardDisk(): HardDisk;\n    getMonitor(): Monitor;\n}\n\n// defining our concrete factories\nclass HighBudgetMachineFactory implements MachineAbstractFactory {\n    getProcessor(): Processor {\n        return new ExpensiveProcessor();\n    }\n\n    getHardDisk(): HardDisk {\n        return new ExpensiveHDD();\n    }\n\n    getMonitor(): Monitor {\n        return new HighResMonitor();\n    }\n}\n\nclass LowBudgetMachineFactory implements MachineAbstractFactory {\n    getProcessor(): Processor {\n        return new CheapProcessor();\n    }\n\n    getHardDisk(): HardDisk {\n        return new CheapHDD();\n    }\n\n    getMonitor(): Monitor {\n        return new LowResMonitor();\n    }\n}\n\n// defining our client and final product\ninterface Machine {\n    processor: Processor;\n    hdd: HardDisk;\n    monitor: Monitor;\n}\n\nclass ComputerShop {\n    // change access modifiers as suits\n    public category: MachineAbstractFactory;\n\n    // we'll pass a factory as category during instantiation\n    constructor(category: MachineAbstractFactory) {\n        this.category = category;\n    }\n\n    assembleMachine(): Machine {\n        const processor = this.category.getProcessor();\n        const hdd = this.category.getHardDisk();\n        const monitor = this.category.getMonitor();\n\n        // to be explicit\n        const machine: Machine = {\n            processor,\n            hdd,\n            monitor\n        }\n        return machine;\n    }\n}\n\n// running the code in action!\nconst cheapFactory = new LowBudgetMachineFactory();\nconst expensiveFactory = new HighBudgetMachineFactory();\n\n// ensure to pass the factory in during instantiation\n// using let to show variability, in code these\n// would likely be functions that take a factory\n// arg and constants for shop/machine\nlet shop;\nlet machine;\n\nshop = new ComputerShop(cheapFactory);\nmachine = shop.assembleMachine();\nmachine.hdd.storeData();\nmachine.processor.performOperation();\nmachine.monitor.displayPicture();\n\nshop = new ComputerShop(expensiveFactory);\nmachine = shop.assembleMachine();\nmachine.hdd.storeData();\nmachine.processor.performOperation();\nmachine.monitor.displayPicture();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"references\"\n    }}>{`References`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://stackoverflow.com/questions/5739611/what-are-the-differences-between-abstract-factory-and-factory-design-patterns\"\n        }}>{`Difference between factory and abstract factory`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.codeproject.com/Articles/716413/Factory-Method-Pattern-vs-Abstract-Factory-Pattern\"\n        }}>{`ASP.NET Abstract Factory vs Factory`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}