{"expireTime":9007200849425564000,"key":"gatsby-plugin-mdx-entire-payload-42ba66858c550a64070cc09841116fed-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Go Tour Interfaces","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":21,"offset":187},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":21,"offset":187},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A type implements an interface by implementing its methods. There is no explicit declaration of intent, no \"implements\" keyword.","position":{"start":{"line":10,"column":1,"offset":189},"end":{"line":10,"column":129,"offset":317},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":189},"end":{"line":10,"column":129,"offset":317},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement","position":{"start":{"line":12,"column":1,"offset":319},"end":{"line":12,"column":147,"offset":465},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":319},"end":{"line":12,"column":147,"offset":465},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Under the hood, interface values can be thought of as a tuple of a value and a concrete type:","position":{"start":{"line":14,"column":1,"offset":467},"end":{"line":14,"column":94,"offset":560},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":467},"end":{"line":14,"column":94,"offset":560},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"(value, type)","position":{"start":{"line":16,"column":1,"offset":562},"end":{"line":18,"column":4,"offset":588},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"An interface value holds a value of a specific underlying concrete type.","position":{"start":{"line":20,"column":1,"offset":590},"end":{"line":20,"column":73,"offset":662},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":590},"end":{"line":20,"column":73,"offset":662},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Calling a method on an interface value executes the method of the same name on its underlying type.","position":{"start":{"line":22,"column":1,"offset":664},"end":{"line":22,"column":100,"offset":763},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":664},"end":{"line":22,"column":100,"offset":763},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tfmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n\tfmt.Println(f)\n}\n\nfunc main() {\n\tvar i I\n\n\ti = &T{\"Hello\"}\n\tdescribe(i)\n\ti.M()\n\n\ti = F(math.Pi)\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}","position":{"start":{"line":24,"column":1,"offset":765},"end":{"line":65,"column":4,"offset":1122},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Nil interface values","position":{"start":{"line":67,"column":4,"offset":1127},"end":{"line":67,"column":24,"offset":1147},"indent":[]}}],"position":{"start":{"line":67,"column":1,"offset":1124},"end":{"line":67,"column":24,"offset":1147},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A nil interface value holds neither value nor concrete type.","position":{"start":{"line":69,"column":1,"offset":1149},"end":{"line":69,"column":61,"offset":1209},"indent":[]}}],"position":{"start":{"line":69,"column":1,"offset":1149},"end":{"line":69,"column":61,"offset":1209},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.","position":{"start":{"line":71,"column":1,"offset":1211},"end":{"line":71,"column":151,"offset":1361},"indent":[]}}],"position":{"start":{"line":71,"column":1,"offset":1211},"end":{"line":71,"column":151,"offset":1361},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"The empty interface","position":{"start":{"line":73,"column":4,"offset":1366},"end":{"line":73,"column":23,"offset":1385},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":1363},"end":{"line":73,"column":23,"offset":1385},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The interface type that specifies zero methods is known as the empty interface:","position":{"start":{"line":75,"column":1,"offset":1387},"end":{"line":75,"column":80,"offset":1466},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":1387},"end":{"line":75,"column":80,"offset":1466},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"interface{}\nAn empty interface may hold values of any type. (Every type implements at least zero methods.)","position":{"start":{"line":77,"column":1,"offset":1468},"end":{"line":78,"column":95,"offset":1574},"indent":[1]}}],"position":{"start":{"line":77,"column":1,"offset":1468},"end":{"line":78,"column":95,"offset":1574},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.","position":{"start":{"line":80,"column":1,"offset":1576},"end":{"line":80,"column":145,"offset":1720},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":1576},"end":{"line":80,"column":145,"offset":1720},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = \"hello\"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}","position":{"start":{"line":82,"column":1,"offset":1722},"end":{"line":101,"column":4,"offset":1926},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Prints:","position":{"start":{"line":103,"column":1,"offset":1928},"end":{"line":103,"column":8,"offset":1935},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":1928},"end":{"line":103,"column":8,"offset":1935},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"(<nil>, <nil>)\n(42, int)\n(hello, string)","position":{"start":{"line":105,"column":1,"offset":1937},"end":{"line":109,"column":4,"offset":1990},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type assertions","position":{"start":{"line":111,"column":4,"offset":1995},"end":{"line":111,"column":19,"offset":2010},"indent":[]}}],"position":{"start":{"line":111,"column":1,"offset":1992},"end":{"line":111,"column":19,"offset":2010},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A type assertion provides access to an interface value's underlying concrete value.","position":{"start":{"line":113,"column":1,"offset":2012},"end":{"line":113,"column":84,"offset":2095},"indent":[]}}],"position":{"start":{"line":113,"column":1,"offset":2012},"end":{"line":113,"column":84,"offset":2095},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"t := i.(T)","position":{"start":{"line":115,"column":1,"offset":2097},"end":{"line":115,"column":13,"offset":2109},"indent":[]}}],"position":{"start":{"line":115,"column":1,"offset":2097},"end":{"line":115,"column":13,"offset":2109},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This statement asserts that the interface value ","position":{"start":{"line":117,"column":1,"offset":2111},"end":{"line":117,"column":49,"offset":2159},"indent":[]}},{"type":"inlineCode","value":"i","position":{"start":{"line":117,"column":49,"offset":2159},"end":{"line":117,"column":52,"offset":2162},"indent":[]}},{"type":"text","value":" holds the concrete type ","position":{"start":{"line":117,"column":52,"offset":2162},"end":{"line":117,"column":77,"offset":2187},"indent":[]}},{"type":"inlineCode","value":"T","position":{"start":{"line":117,"column":77,"offset":2187},"end":{"line":117,"column":80,"offset":2190},"indent":[]}},{"type":"text","value":" and assigns the underlying ","position":{"start":{"line":117,"column":80,"offset":2190},"end":{"line":117,"column":108,"offset":2218},"indent":[]}},{"type":"inlineCode","value":"T","position":{"start":{"line":117,"column":108,"offset":2218},"end":{"line":117,"column":111,"offset":2221},"indent":[]}},{"type":"text","value":" value to the variable ","position":{"start":{"line":117,"column":111,"offset":2221},"end":{"line":117,"column":134,"offset":2244},"indent":[]}},{"type":"inlineCode","value":"t","position":{"start":{"line":117,"column":134,"offset":2244},"end":{"line":117,"column":137,"offset":2247},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":117,"column":137,"offset":2247},"end":{"line":117,"column":138,"offset":2248},"indent":[]}}],"position":{"start":{"line":117,"column":1,"offset":2111},"end":{"line":117,"column":138,"offset":2248},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If ","position":{"start":{"line":119,"column":1,"offset":2250},"end":{"line":119,"column":4,"offset":2253},"indent":[]}},{"type":"inlineCode","value":"i","position":{"start":{"line":119,"column":4,"offset":2253},"end":{"line":119,"column":7,"offset":2256},"indent":[]}},{"type":"text","value":" does not hold a ","position":{"start":{"line":119,"column":7,"offset":2256},"end":{"line":119,"column":24,"offset":2273},"indent":[]}},{"type":"inlineCode","value":"T","position":{"start":{"line":119,"column":24,"offset":2273},"end":{"line":119,"column":27,"offset":2276},"indent":[]}},{"type":"text","value":", the statement will trigger a panic.","position":{"start":{"line":119,"column":27,"offset":2276},"end":{"line":119,"column":64,"offset":2313},"indent":[]}}],"position":{"start":{"line":119,"column":1,"offset":2250},"end":{"line":119,"column":64,"offset":2313},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.","position":{"start":{"line":121,"column":1,"offset":2315},"end":{"line":121,"column":185,"offset":2499},"indent":[]}}],"position":{"start":{"line":121,"column":1,"offset":2315},"end":{"line":121,"column":185,"offset":2499},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"t, ok := i.(T)","position":{"start":{"line":123,"column":1,"offset":2501},"end":{"line":123,"column":17,"offset":2517},"indent":[]}}],"position":{"start":{"line":123,"column":1,"offset":2501},"end":{"line":123,"column":17,"offset":2517},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If ","position":{"start":{"line":125,"column":1,"offset":2519},"end":{"line":125,"column":4,"offset":2522},"indent":[]}},{"type":"inlineCode","value":"i","position":{"start":{"line":125,"column":4,"offset":2522},"end":{"line":125,"column":7,"offset":2525},"indent":[]}},{"type":"text","value":" holds a ","position":{"start":{"line":125,"column":7,"offset":2525},"end":{"line":125,"column":16,"offset":2534},"indent":[]}},{"type":"inlineCode","value":"T","position":{"start":{"line":125,"column":16,"offset":2534},"end":{"line":125,"column":19,"offset":2537},"indent":[]}},{"type":"text","value":", then ","position":{"start":{"line":125,"column":19,"offset":2537},"end":{"line":125,"column":26,"offset":2544},"indent":[]}},{"type":"inlineCode","value":"t","position":{"start":{"line":125,"column":26,"offset":2544},"end":{"line":125,"column":29,"offset":2547},"indent":[]}},{"type":"text","value":" will be the underlying value and ok will be true.","position":{"start":{"line":125,"column":29,"offset":2547},"end":{"line":125,"column":79,"offset":2597},"indent":[]}}],"position":{"start":{"line":125,"column":1,"offset":2519},"end":{"line":125,"column":79,"offset":2597},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If ","position":{"start":{"line":127,"column":1,"offset":2599},"end":{"line":127,"column":4,"offset":2602},"indent":[]}},{"type":"inlineCode","value":"not, ok","position":{"start":{"line":127,"column":4,"offset":2602},"end":{"line":127,"column":13,"offset":2611},"indent":[]}},{"type":"text","value":" will be false and ","position":{"start":{"line":127,"column":13,"offset":2611},"end":{"line":127,"column":32,"offset":2630},"indent":[]}},{"type":"inlineCode","value":"t","position":{"start":{"line":127,"column":32,"offset":2630},"end":{"line":127,"column":35,"offset":2633},"indent":[]}},{"type":"text","value":" will be the zero value of type ","position":{"start":{"line":127,"column":35,"offset":2633},"end":{"line":127,"column":67,"offset":2665},"indent":[]}},{"type":"inlineCode","value":"T","position":{"start":{"line":127,"column":67,"offset":2665},"end":{"line":127,"column":70,"offset":2668},"indent":[]}},{"type":"text","value":", and no panic occurs.","position":{"start":{"line":127,"column":70,"offset":2668},"end":{"line":127,"column":92,"offset":2690},"indent":[]}}],"position":{"start":{"line":127,"column":1,"offset":2599},"end":{"line":127,"column":92,"offset":2690},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Note the similarity between this syntax and that of reading from a map.","position":{"start":{"line":129,"column":1,"offset":2692},"end":{"line":129,"column":72,"offset":2763},"indent":[]}}],"position":{"start":{"line":129,"column":1,"offset":2692},"end":{"line":129,"column":72,"offset":2763},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{} = \"hello\"\n\n\ts := i.(string)\n\tfmt.Println(s)\n\n\ts, ok := i.(string)\n\tfmt.Println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.Println(f, ok)\n\n\tf = i.(float64) // panic\n\tfmt.Println(f)\n}","position":{"start":{"line":131,"column":1,"offset":2765},"end":{"line":151,"column":4,"offset":3013},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type switches","position":{"start":{"line":153,"column":4,"offset":3018},"end":{"line":153,"column":17,"offset":3031},"indent":[]}}],"position":{"start":{"line":153,"column":1,"offset":3015},"end":{"line":153,"column":17,"offset":3031},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A type switch is a construct that permits several type assertions in series.","position":{"start":{"line":155,"column":1,"offset":3033},"end":{"line":155,"column":77,"offset":3109},"indent":[]}}],"position":{"start":{"line":155,"column":1,"offset":3033},"end":{"line":155,"column":77,"offset":3109},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.","position":{"start":{"line":157,"column":1,"offset":3111},"end":{"line":157,"column":204,"offset":3314},"indent":[]}}],"position":{"start":{"line":157,"column":1,"offset":3111},"end":{"line":157,"column":204,"offset":3314},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"switch v := i.(type) {\ncase T:\n    // here v has type T\ncase S:\n    // here v has type S\ndefault:\n    // no match; here v has the same type as i\n}","position":{"start":{"line":159,"column":1,"offset":3316},"end":{"line":168,"column":4,"offset":3476},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type.","position":{"start":{"line":170,"column":1,"offset":3478},"end":{"line":170,"column":139,"offset":3616},"indent":[]}}],"position":{"start":{"line":170,"column":1,"offset":3478},"end":{"line":170,"column":139,"offset":3616},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This switch statement tests whether the interface value i holds a value of type T or S. In each of the T and S cases, the variable v will be of type T or S respectively and hold the value held by i. In the default case (where there is no match), the variable v is of the same interface type and value as i.","position":{"start":{"line":172,"column":1,"offset":3618},"end":{"line":172,"column":307,"offset":3924},"indent":[]}}],"position":{"start":{"line":172,"column":1,"offset":3618},"end":{"line":172,"column":307,"offset":3924},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo(\"hello\")\n\tdo(true)\n}","position":{"start":{"line":174,"column":1,"offset":3926},"end":{"line":195,"column":4,"offset":4243},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Prints:","position":{"start":{"line":197,"column":1,"offset":4245},"end":{"line":197,"column":8,"offset":4252},"indent":[]}}],"position":{"start":{"line":197,"column":1,"offset":4245},"end":{"line":197,"column":8,"offset":4252},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"Twice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!","position":{"start":{"line":199,"column":1,"offset":4254},"end":{"line":203,"column":4,"offset":4335},"indent":[1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":206,"column":1,"offset":4338},"end":{"line":206,"column":31,"offset":4368},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":206,"column":31,"offset":4368}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"go-tour-interfaces\"\n    }}>{`Go Tour Interfaces`}</h1>\n    <p>{`A type implements an interface by implementing its methods. There is no explicit declaration of intent, no \"implements\" keyword.`}</p>\n    <p>{`Implicit interfaces decouple the definition of an interface from its implementation, which could then appear in any package without prearrangement`}</p>\n    <p>{`Under the hood, interface values can be thought of as a tuple of a value and a concrete type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`(value, type)\n`}</code></pre>\n    <p>{`An interface value holds a value of a specific underlying concrete type.`}</p>\n    <p>{`Calling a method on an interface value executes the method of the same name on its underlying type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype I interface {\n    M()\n}\n\ntype T struct {\n    S string\n}\n\nfunc (t *T) M() {\n    fmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n    fmt.Println(f)\n}\n\nfunc main() {\n    var i I\n\n    i = &T{\"Hello\"}\n    describe(i)\n    i.M()\n\n    i = F(math.Pi)\n    describe(i)\n    i.M()\n}\n\nfunc describe(i I) {\n    fmt.Printf(\"(%v, %T)\\\\n\", i, i)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"nil-interface-values\"\n    }}>{`Nil interface values`}</h2>\n    <p>{`A nil interface value holds neither value nor concrete type.`}</p>\n    <p>{`Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.`}</p>\n    <h2 {...{\n      \"id\": \"the-empty-interface\"\n    }}>{`The empty interface`}</h2>\n    <p>{`The interface type that specifies zero methods is known as the empty interface:`}</p>\n    <p>{`interface{}\nAn empty interface may hold values of any type. (Every type implements at least zero methods.)`}</p>\n    <p>{`Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{}\n    describe(i)\n\n    i = 42\n    describe(i)\n\n    i = \"hello\"\n    describe(i)\n}\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"(%v, %T)\\\\n\", i, i)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`(<nil>, <nil>)\n(42, int)\n(hello, string)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-assertions\"\n    }}>{`Type assertions`}</h2>\n    <p>{`A type assertion provides access to an interface value's underlying concrete value.`}</p>\n    <p><inlineCode parentName=\"p\">{`t := i.(T)`}</inlineCode></p>\n    <p>{`This statement asserts that the interface value `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` holds the concrete type `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` and assigns the underlying `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{` value to the variable `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{`.`}</p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` does not hold a `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, the statement will trigger a panic.`}</p>\n    <p>{`To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.`}</p>\n    <p><inlineCode parentName=\"p\">{`t, ok := i.(T)`}</inlineCode></p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`i`}</inlineCode>{` holds a `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, then `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{` will be the underlying value and ok will be true.`}</p>\n    <p>{`If `}<inlineCode parentName=\"p\">{`not, ok`}</inlineCode>{` will be false and `}<inlineCode parentName=\"p\">{`t`}</inlineCode>{` will be the zero value of type `}<inlineCode parentName=\"p\">{`T`}</inlineCode>{`, and no panic occurs.`}</p>\n    <p>{`Note the similarity between this syntax and that of reading from a map.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = \"hello\"\n\n    s := i.(string)\n    fmt.Println(s)\n\n    s, ok := i.(string)\n    fmt.Println(s, ok)\n\n    f, ok := i.(float64)\n    fmt.Println(f, ok)\n\n    f = i.(float64) // panic\n    fmt.Println(f)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-switches\"\n    }}>{`Type switches`}</h2>\n    <p>{`A type switch is a construct that permits several type assertions in series.`}</p>\n    <p>{`A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`switch v := i.(type) {\ncase T:\n    // here v has type T\ncase S:\n    // here v has type S\ndefault:\n    // no match; here v has the same type as i\n}\n`}</code></pre>\n    <p>{`The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type.`}</p>\n    <p>{`This switch statement tests whether the interface value i holds a value of type T or S. In each of the T and S cases, the variable v will be of type T or S respectively and hold the value held by i. In the default case (where there is no match), the variable v is of the same interface type and value as i.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Twice %v is %v\\\\n\", v, v*2)\n    case string:\n        fmt.Printf(\"%q is %v bytes long\\\\n\", v, len(v))\n    default:\n        fmt.Printf(\"I don't know about type %T!\\\\n\", v)\n    }\n}\n\nfunc main() {\n    do(21)\n    do(\"hello\")\n    do(true)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`Twice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}