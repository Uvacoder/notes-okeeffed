{"expireTime":9007200867335903000,"key":"gatsby-plugin-mdx-entire-payload-5118bb392601fa701936b38c0d68a9fd-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Useful Tidbits","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":17,"offset":183},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":17,"offset":183},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Importing crates vs std lib","position":{"start":{"line":10,"column":4,"offset":188},"end":{"line":10,"column":31,"offset":215},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":185},"end":{"line":10,"column":31,"offset":215},"indent":[]}},{"type":"code","lang":"rust","meta":null,"value":"// for extenal dependencies\nextern crate clap;\nuse clap::App;\n// for standard Rust libraries\nuse std::fs;","position":{"start":{"line":12,"column":1,"offset":217},"end":{"line":18,"column":4,"offset":334},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Reading YAML","position":{"start":{"line":20,"column":4,"offset":339},"end":{"line":20,"column":16,"offset":351},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":336},"end":{"line":20,"column":16,"offset":351},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Note that this is being done by using the ","position":{"start":{"line":22,"column":1,"offset":353},"end":{"line":22,"column":43,"offset":395},"indent":[]}},{"type":"inlineCode","value":"clap","position":{"start":{"line":22,"column":43,"offset":395},"end":{"line":22,"column":49,"offset":401},"indent":[]}},{"type":"text","value":" crate that is used for CLI tools - may need to update for appropraite use with ","position":{"start":{"line":22,"column":49,"offset":401},"end":{"line":22,"column":129,"offset":481},"indent":[]}},{"type":"inlineCode","value":"rust-yaml","position":{"start":{"line":22,"column":129,"offset":481},"end":{"line":22,"column":140,"offset":492},"indent":[]}},{"type":"text","value":":","position":{"start":{"line":22,"column":140,"offset":492},"end":{"line":22,"column":141,"offset":493},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":353},"end":{"line":22,"column":141,"offset":493},"indent":[]}},{"type":"code","lang":"rust","meta":null,"value":"#[macro_use]\nextern crate clap;\nuse clap::App;\n\nfn main() {\n  let yaml = load_yaml!(\"cli.yml\");\n  println!(\"{:#?}\", yaml);\n}","position":{"start":{"line":24,"column":1,"offset":495},"end":{"line":33,"column":4,"offset":631},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Reading JSON","position":{"start":{"line":35,"column":4,"offset":636},"end":{"line":35,"column":16,"offset":648},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":633},"end":{"line":35,"column":16,"offset":648},"indent":[]}},{"type":"code","lang":"rust","meta":null,"value":"#[macro_use]\nextern crate serde_json;\n\nuse std::path::Path;\nuse std::fs::File;\n\nfn main() {\n    let json_file_path = Path::new(\"src/test.json\");\n    let json_file = File::open(json_file_path).expect(\"file not found\");\n    let json: serde_json::Value = serde_json::from_reader(json_file).expect(\"JSON was not well-formatted\");\n    println!(\"{:#?}\", json);\n}","position":{"start":{"line":37,"column":1,"offset":650},"end":{"line":50,"column":4,"offset":1018},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Output:","position":{"start":{"line":52,"column":1,"offset":1020},"end":{"line":52,"column":8,"offset":1027},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":1020},"end":{"line":52,"column":8,"offset":1027},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"Object(\n    {\n        \"id\": String(\n            \"1234\"\n        ),\n        \"object\": Object(\n            {\n                \"array\": Array(\n                    [\n                        Number(\n                            1\n                        ),\n                        Number(\n                            2\n                        ),\n                        Number(\n                            3\n                        )\n                    ]\n                )\n            }\n        )\n    }\n)","position":{"start":{"line":54,"column":1,"offset":1029},"end":{"line":79,"column":4,"offset":1539},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Logging","position":{"start":{"line":81,"column":4,"offset":1544},"end":{"line":81,"column":11,"offset":1551},"indent":[]}}],"position":{"start":{"line":81,"column":1,"offset":1541},"end":{"line":81,"column":11,"offset":1551},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"You want to implement the Debug trait on your struct. Using #","position":{"start":{"line":83,"column":1,"offset":1553},"end":{"line":83,"column":62,"offset":1614},"indent":[]}},{"type":"linkReference","identifier":"derive(debug)","label":"derive(Debug)","referenceType":"shortcut","children":[{"type":"text","value":"derive(Debug)","position":{"start":{"line":83,"column":63,"offset":1615},"end":{"line":83,"column":76,"offset":1628},"indent":[]}}],"position":{"start":{"line":83,"column":62,"offset":1614},"end":{"line":83,"column":77,"offset":1629},"indent":[]}},{"type":"text","value":" is the easiest solution. Then you can print it with {:?}:","position":{"start":{"line":83,"column":77,"offset":1629},"end":{"line":83,"column":135,"offset":1687},"indent":[]}}],"position":{"start":{"line":83,"column":1,"offset":1553},"end":{"line":83,"column":135,"offset":1687},"indent":[]}},{"type":"code","lang":"rust","meta":null,"value":"#[derive(Debug)]\nstruct MyStruct{\n    a: i32,\n    b: i32\n}\n\nfn main() {\n    let x = MyStruct{ a: 10, b: 20 };\n    println!(\"{:?}\", x);\n}","position":{"start":{"line":85,"column":1,"offset":1689},"end":{"line":96,"column":4,"offset":1837},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In use:","position":{"start":{"line":98,"column":1,"offset":1839},"end":{"line":98,"column":8,"offset":1846},"indent":[]}}],"position":{"start":{"line":98,"column":1,"offset":1839},"end":{"line":98,"column":8,"offset":1846},"indent":[]}},{"type":"code","lang":"rust","meta":null,"value":"// assuming matches is a struct or array\nprintln!(\"{:?}\", matches); // logging out structs or arrays\nprintln!(\"{:#?}\", matches); // pretty print\nprintln!(\"{}\", matches.occurrences_of(\"verbose\"));","position":{"start":{"line":100,"column":1,"offset":1848},"end":{"line":105,"column":4,"offset":2055},"indent":[1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":107,"column":1,"offset":2057},"end":{"line":107,"column":31,"offset":2087},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":107,"column":31,"offset":2087}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"useful-tidbits\"\n    }}>{`Useful Tidbits`}</h1>\n    <h2 {...{\n      \"id\": \"importing-crates-vs-std-lib\"\n    }}>{`Importing crates vs std lib`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`// for extenal dependencies\nextern crate clap;\nuse clap::App;\n// for standard Rust libraries\nuse std::fs;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"reading-yaml\"\n    }}>{`Reading YAML`}</h2>\n    <p>{`Note that this is being done by using the `}<inlineCode parentName=\"p\">{`clap`}</inlineCode>{` crate that is used for CLI tools - may need to update for appropraite use with `}<inlineCode parentName=\"p\">{`rust-yaml`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`#[macro_use]\nextern crate clap;\nuse clap::App;\n\nfn main() {\n  let yaml = load_yaml!(\"cli.yml\");\n  println!(\"{:#?}\", yaml);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"reading-json\"\n    }}>{`Reading JSON`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`#[macro_use]\nextern crate serde_json;\n\nuse std::path::Path;\nuse std::fs::File;\n\nfn main() {\n    let json_file_path = Path::new(\"src/test.json\");\n    let json_file = File::open(json_file_path).expect(\"file not found\");\n    let json: serde_json::Value = serde_json::from_reader(json_file).expect(\"JSON was not well-formatted\");\n    println!(\"{:#?}\", json);\n}\n`}</code></pre>\n    <p>{`Output:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`Object(\n    {\n        \"id\": String(\n            \"1234\"\n        ),\n        \"object\": Object(\n            {\n                \"array\": Array(\n                    [\n                        Number(\n                            1\n                        ),\n                        Number(\n                            2\n                        ),\n                        Number(\n                            3\n                        )\n                    ]\n                )\n            }\n        )\n    }\n)\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"logging\"\n    }}>{`Logging`}</h2>\n    <p>{`You want to implement the Debug trait on your struct. Using #`}{`[derive(Debug)]`}{` is the easiest solution. Then you can print it with {:?}:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`#[derive(Debug)]\nstruct MyStruct{\n    a: i32,\n    b: i32\n}\n\nfn main() {\n    let x = MyStruct{ a: 10, b: 20 };\n    println!(\"{:?}\", x);\n}\n`}</code></pre>\n    <p>{`In use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-rust\"\n      }}>{`// assuming matches is a struct or array\nprintln!(\"{:?}\", matches); // logging out structs or arrays\nprintln!(\"{:#?}\", matches); // pretty print\nprintln!(\"{}\", matches.occurrences_of(\"verbose\"));\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}