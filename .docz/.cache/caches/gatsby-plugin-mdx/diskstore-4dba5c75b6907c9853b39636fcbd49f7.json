{"expireTime":9007200867335934000,"key":"gatsby-plugin-mdx-entire-payload-51873ce6527946a2cf4ac314dd11b929-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Kafka Basic Terms","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":20,"offset":186},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":20,"offset":186},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Messages","position":{"start":{"line":10,"column":4,"offset":191},"end":{"line":10,"column":12,"offset":199},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":188},"end":{"line":10,"column":12,"offset":199},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The base unit of data within Kafka is called a message. You could think of this as a ","position":{"start":{"line":12,"column":1,"offset":201},"end":{"line":12,"column":86,"offset":286},"indent":[]}},{"type":"inlineCode","value":"row","position":{"start":{"line":12,"column":86,"offset":286},"end":{"line":12,"column":91,"offset":291},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":12,"column":91,"offset":291},"end":{"line":12,"column":95,"offset":295},"indent":[]}},{"type":"inlineCode","value":"record","position":{"start":{"line":12,"column":95,"offset":295},"end":{"line":12,"column":103,"offset":303},"indent":[]}},{"type":"text","value":" if you are familiar with databases. A message is simply an array of bytes as far as Kafka is concerne, so it does not need to be a specific format.","position":{"start":{"line":12,"column":103,"offset":303},"end":{"line":12,"column":251,"offset":451},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":201},"end":{"line":12,"column":251,"offset":451},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A message can have an optional ","position":{"start":{"line":14,"column":1,"offset":453},"end":{"line":14,"column":32,"offset":484},"indent":[]}},{"type":"inlineCode","value":"key","position":{"start":{"line":14,"column":32,"offset":484},"end":{"line":14,"column":37,"offset":489},"indent":[]}},{"type":"text","value":" which again is simply an array of bytes. This key is used when messages are to be writting ot partitions in a more controlled manner.","position":{"start":{"line":14,"column":37,"offset":489},"end":{"line":14,"column":171,"offset":623},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":453},"end":{"line":14,"column":171,"offset":623},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Batches","position":{"start":{"line":16,"column":4,"offset":628},"end":{"line":16,"column":11,"offset":635},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":625},"end":{"line":16,"column":11,"offset":635},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For efficiency, messages are written into Kafka in batches. A ","position":{"start":{"line":18,"column":1,"offset":637},"end":{"line":18,"column":63,"offset":699},"indent":[]}},{"type":"inlineCode","value":"batch","position":{"start":{"line":18,"column":63,"offset":699},"end":{"line":18,"column":70,"offset":706},"indent":[]}},{"type":"text","value":" is just a collection of messages, all of which are being produced to the same ","position":{"start":{"line":18,"column":70,"offset":706},"end":{"line":18,"column":149,"offset":785},"indent":[]}},{"type":"inlineCode","value":"topic","position":{"start":{"line":18,"column":149,"offset":785},"end":{"line":18,"column":156,"offset":792},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":18,"column":156,"offset":792},"end":{"line":18,"column":161,"offset":797},"indent":[]}},{"type":"inlineCode","value":"partition","position":{"start":{"line":18,"column":161,"offset":797},"end":{"line":18,"column":172,"offset":808},"indent":[]}},{"type":"text","value":". This of course is a tradeoff between latency and throughput.","position":{"start":{"line":18,"column":172,"offset":808},"end":{"line":18,"column":234,"offset":870},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":637},"end":{"line":18,"column":234,"offset":870},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The larger the batch, the more messages per unit of time that can be handled but the longer it takes for the propagation of an individual message.","position":{"start":{"line":20,"column":1,"offset":872},"end":{"line":20,"column":147,"offset":1018},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":872},"end":{"line":20,"column":147,"offset":1018},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Batches are typically compressed for more efficient data transfer and storage at the cost of processing power.","position":{"start":{"line":22,"column":1,"offset":1020},"end":{"line":22,"column":111,"offset":1130},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":1020},"end":{"line":22,"column":111,"offset":1130},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Schemas","position":{"start":{"line":24,"column":4,"offset":1135},"end":{"line":24,"column":11,"offset":1142},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":1132},"end":{"line":24,"column":11,"offset":1142},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"While messages are byte arrays to Kafka, it is recommended to add additional structure in the form of a schema to be imposed on the message content so it can be easily understood.","position":{"start":{"line":26,"column":1,"offset":1144},"end":{"line":26,"column":180,"offset":1323},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":1144},"end":{"line":26,"column":180,"offset":1323},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are many options for this depending on application needs. JSON and XML are easy and human readable but lack features such as robust type handling and compatibility between schema versions.","position":{"start":{"line":28,"column":1,"offset":1325},"end":{"line":28,"column":195,"offset":1519},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":1325},"end":{"line":28,"column":195,"offset":1519},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Most Kafka devs favour the use of Apache Avro - a serialization framework originally designed for Hadoop. Avro has compact serialisation, schemas separate from message payloads and strong data typing and schema evolution with backward/forward compatibility.","position":{"start":{"line":30,"column":1,"offset":1521},"end":{"line":30,"column":258,"offset":1778},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1521},"end":{"line":30,"column":258,"offset":1778},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It is an imperative to choose a consistent data format.","position":{"start":{"line":32,"column":1,"offset":1780},"end":{"line":32,"column":56,"offset":1835},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1780},"end":{"line":32,"column":56,"offset":1835},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Topics","position":{"start":{"line":34,"column":4,"offset":1840},"end":{"line":34,"column":10,"offset":1846},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":1837},"end":{"line":34,"column":10,"offset":1846},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Topics are the categorisation of messages. Thing of this as a database table or folder in a filesystem.","position":{"start":{"line":36,"column":1,"offset":1848},"end":{"line":36,"column":104,"offset":1951},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":1848},"end":{"line":36,"column":104,"offset":1951},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Partitions","position":{"start":{"line":38,"column":4,"offset":1956},"end":{"line":38,"column":14,"offset":1966},"indent":[]}}],"position":{"start":{"line":38,"column":1,"offset":1953},"end":{"line":38,"column":14,"offset":1966},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Topics are additionally broken down into a number of ","position":{"start":{"line":40,"column":1,"offset":1968},"end":{"line":40,"column":54,"offset":2021},"indent":[]}},{"type":"inlineCode","value":"partitions","position":{"start":{"line":40,"column":54,"offset":2021},"end":{"line":40,"column":66,"offset":2033},"indent":[]}},{"type":"text","value":". Consider this analagous to the \"commit log\" where messages are written to it in an append-only fashion. A topic typically has multiple partitions, so there is no guarantee of message time-ordering across the entire topic - just within a single partition.","position":{"start":{"line":40,"column":66,"offset":2033},"end":{"line":40,"column":322,"offset":2289},"indent":[]}}],"position":{"start":{"line":40,"column":1,"offset":1968},"end":{"line":40,"column":322,"offset":2289},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Partitions are also used to provide redundancy and scalability.","position":{"start":{"line":42,"column":1,"offset":2291},"end":{"line":42,"column":64,"offset":2354},"indent":[]}}],"position":{"start":{"line":42,"column":1,"offset":2291},"end":{"line":42,"column":64,"offset":2354},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Each partition itself can be run from a separate server to enable horizontal scalability and improve performance.","position":{"start":{"line":44,"column":1,"offset":2356},"end":{"line":44,"column":114,"offset":2469},"indent":[]}}],"position":{"start":{"line":44,"column":1,"offset":2356},"end":{"line":44,"column":114,"offset":2469},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Streams","position":{"start":{"line":46,"column":4,"offset":2474},"end":{"line":46,"column":11,"offset":2481},"indent":[]}}],"position":{"start":{"line":46,"column":1,"offset":2471},"end":{"line":46,"column":11,"offset":2481},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Stream","position":{"start":{"line":48,"column":1,"offset":2483},"end":{"line":48,"column":9,"offset":2491},"indent":[]}},{"type":"text","value":" is often used when discussing data within systems like Kafka. Often a stream is considered to be a single topic of data, irrespective of the number of partitions. This represents a stream of data going from producers to consumers.","position":{"start":{"line":48,"column":9,"offset":2491},"end":{"line":48,"column":240,"offset":2722},"indent":[]}}],"position":{"start":{"line":48,"column":1,"offset":2483},"end":{"line":48,"column":240,"offset":2722},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Producers","position":{"start":{"line":50,"column":4,"offset":2727},"end":{"line":50,"column":13,"offset":2736},"indent":[]}}],"position":{"start":{"line":50,"column":1,"offset":2724},"end":{"line":50,"column":13,"offset":2736},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Producers create new messages. In alternative pub/sub systems, these can also be name ","position":{"start":{"line":52,"column":1,"offset":2738},"end":{"line":52,"column":87,"offset":2824},"indent":[]}},{"type":"inlineCode","value":"publishers","position":{"start":{"line":52,"column":87,"offset":2824},"end":{"line":52,"column":99,"offset":2836},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":52,"column":99,"offset":2836},"end":{"line":52,"column":103,"offset":2840},"indent":[]}},{"type":"inlineCode","value":"writers","position":{"start":{"line":52,"column":103,"offset":2840},"end":{"line":52,"column":112,"offset":2849},"indent":[]}},{"type":"text","value":". In general, a message is produced to a specific topic. By default, the producer does not care what partition a specific message is written to and will balance messages over all partitions of a topic evenly.","position":{"start":{"line":52,"column":112,"offset":2849},"end":{"line":52,"column":320,"offset":3057},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":2738},"end":{"line":52,"column":320,"offset":3057},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are cases when a producer will direct a message to a particular partition, normally makig use of the message key and a partitioner that will generate a hash of the key and map it to a specific partition to ensure all messages produced with a specific key will map to a specific partition.","position":{"start":{"line":54,"column":1,"offset":3059},"end":{"line":54,"column":295,"offset":3353},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":3059},"end":{"line":54,"column":295,"offset":3353},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Consumers","position":{"start":{"line":56,"column":4,"offset":3358},"end":{"line":56,"column":13,"offset":3367},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":3355},"end":{"line":56,"column":13,"offset":3367},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Consumers read messages. These can also be referred to as ","position":{"start":{"line":58,"column":1,"offset":3369},"end":{"line":58,"column":59,"offset":3427},"indent":[]}},{"type":"inlineCode","value":"subscribers","position":{"start":{"line":58,"column":59,"offset":3427},"end":{"line":58,"column":72,"offset":3440},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":58,"column":72,"offset":3440},"end":{"line":58,"column":76,"offset":3444},"indent":[]}},{"type":"inlineCode","value":"readers","position":{"start":{"line":58,"column":76,"offset":3444},"end":{"line":58,"column":85,"offset":3453},"indent":[]}},{"type":"text","value":" in other pub/sub systems.","position":{"start":{"line":58,"column":85,"offset":3453},"end":{"line":58,"column":111,"offset":3479},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":3369},"end":{"line":58,"column":111,"offset":3479},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"These guys subscribe to one or more topics and reads messages in order they were produced. Each message in a given partition has a unique offset, and by storing that offset of the last consumed message for each partition in either Zookeeper or Kafka itself, a consumer can stop and restart without losing its place.","position":{"start":{"line":60,"column":1,"offset":3481},"end":{"line":60,"column":316,"offset":3796},"indent":[]}}],"position":{"start":{"line":60,"column":1,"offset":3481},"end":{"line":60,"column":316,"offset":3796},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Consumer Group","position":{"start":{"line":62,"column":4,"offset":3801},"end":{"line":62,"column":18,"offset":3815},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":3798},"end":{"line":62,"column":18,"offset":3815},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Consumers work as part of a ","position":{"start":{"line":64,"column":1,"offset":3817},"end":{"line":64,"column":29,"offset":3845},"indent":[]}},{"type":"inlineCode","value":"consumer group","position":{"start":{"line":64,"column":29,"offset":3845},"end":{"line":64,"column":45,"offset":3861},"indent":[]}},{"type":"text","value":", which is one of more consumers that work together to consume a topic. This group assures that each partition is only consumed by one member.","position":{"start":{"line":64,"column":45,"offset":3861},"end":{"line":64,"column":187,"offset":4003},"indent":[]}}],"position":{"start":{"line":64,"column":1,"offset":3817},"end":{"line":64,"column":187,"offset":4003},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Ownership","position":{"start":{"line":66,"column":4,"offset":4008},"end":{"line":66,"column":13,"offset":4017},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":4005},"end":{"line":66,"column":13,"offset":4017},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This occurs when the mapping a consumer to a partition. In this way, consumers can scale horizontally to consume topics with a large number of messages. Additionally, if a consumer fails then there is redundancy.","position":{"start":{"line":68,"column":1,"offset":4019},"end":{"line":68,"column":213,"offset":4231},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":4019},"end":{"line":68,"column":213,"offset":4231},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Brokers","position":{"start":{"line":70,"column":4,"offset":4236},"end":{"line":70,"column":11,"offset":4243},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":4233},"end":{"line":70,"column":11,"offset":4243},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A single Kafka server is referred to as a ","position":{"start":{"line":72,"column":1,"offset":4245},"end":{"line":72,"column":43,"offset":4287},"indent":[]}},{"type":"inlineCode","value":"broker","position":{"start":{"line":72,"column":43,"offset":4287},"end":{"line":72,"column":51,"offset":4295},"indent":[]}},{"type":"text","value":". The broker receives messages from producers, assigns offets to them and commits the messages to storage on disk.","position":{"start":{"line":72,"column":51,"offset":4295},"end":{"line":72,"column":165,"offset":4409},"indent":[]}}],"position":{"start":{"line":72,"column":1,"offset":4245},"end":{"line":72,"column":165,"offset":4409},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The broker also service consumers. It respons to fech requests for partionans and respones with messages that have been committed to disk. A single broker could easily handle thousands of partitions and millions of messages per second pending the level of hardware.","position":{"start":{"line":74,"column":1,"offset":4411},"end":{"line":74,"column":266,"offset":4676},"indent":[]}}],"position":{"start":{"line":74,"column":1,"offset":4411},"end":{"line":74,"column":266,"offset":4676},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Clusters","position":{"start":{"line":76,"column":4,"offset":4681},"end":{"line":76,"column":12,"offset":4689},"indent":[]}}],"position":{"start":{"line":76,"column":1,"offset":4678},"end":{"line":76,"column":12,"offset":4689},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Kafka brokers are designed to operate as part of a ","position":{"start":{"line":78,"column":1,"offset":4691},"end":{"line":78,"column":52,"offset":4742},"indent":[]}},{"type":"inlineCode","value":"cluster","position":{"start":{"line":78,"column":52,"offset":4742},"end":{"line":78,"column":61,"offset":4751},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":78,"column":61,"offset":4751},"end":{"line":78,"column":62,"offset":4752},"indent":[]}}],"position":{"start":{"line":78,"column":1,"offset":4691},"end":{"line":78,"column":62,"offset":4752},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Controller","position":{"start":{"line":80,"column":4,"offset":4757},"end":{"line":80,"column":14,"offset":4767},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":4754},"end":{"line":80,"column":14,"offset":4767},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Within a cluster of brokers, one broker will also function as a cluster ","position":{"start":{"line":82,"column":1,"offset":4769},"end":{"line":82,"column":73,"offset":4841},"indent":[]}},{"type":"inlineCode","value":"controller","position":{"start":{"line":82,"column":73,"offset":4841},"end":{"line":82,"column":85,"offset":4853},"indent":[]}},{"type":"text","value":" (elected automatically). The controller is responsible for administrative operations:","position":{"start":{"line":82,"column":85,"offset":4853},"end":{"line":82,"column":171,"offset":4939},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":4769},"end":{"line":82,"column":171,"offset":4939},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Assigning partitions to brokers","position":{"start":{"line":84,"column":3,"offset":4943},"end":{"line":84,"column":34,"offset":4974},"indent":[]}}],"position":{"start":{"line":84,"column":3,"offset":4943},"end":{"line":84,"column":34,"offset":4974},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":4941},"end":{"line":84,"column":34,"offset":4974},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Monitoring health of brokers","position":{"start":{"line":85,"column":3,"offset":4977},"end":{"line":85,"column":31,"offset":5005},"indent":[]}}],"position":{"start":{"line":85,"column":3,"offset":4977},"end":{"line":85,"column":31,"offset":5005},"indent":[]}}],"position":{"start":{"line":85,"column":1,"offset":4975},"end":{"line":85,"column":31,"offset":5005},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":4941},"end":{"line":85,"column":31,"offset":5005},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"A partition is owned by a single broker in the cluster and that broker is called the ","position":{"start":{"line":87,"column":1,"offset":5007},"end":{"line":87,"column":86,"offset":5092},"indent":[]}},{"type":"inlineCode","value":"leader","position":{"start":{"line":87,"column":86,"offset":5092},"end":{"line":87,"column":94,"offset":5100},"indent":[]}},{"type":"text","value":" of the partition. A partition may be assigned to multiple brokers, which will result in the partition being replaced. This provides redundancy of messages in the partition - such that another broker can take over leadership if there is a broker failure. However, all ","position":{"start":{"line":87,"column":94,"offset":5100},"end":{"line":87,"column":362,"offset":5368},"indent":[]}},{"type":"inlineCode","value":"consumers","position":{"start":{"line":87,"column":362,"offset":5368},"end":{"line":87,"column":373,"offset":5379},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":87,"column":373,"offset":5379},"end":{"line":87,"column":378,"offset":5384},"indent":[]}},{"type":"inlineCode","value":"producers","position":{"start":{"line":87,"column":378,"offset":5384},"end":{"line":87,"column":389,"offset":5395},"indent":[]}},{"type":"text","value":" operating on that cluster must connect to the leader.","position":{"start":{"line":87,"column":389,"offset":5395},"end":{"line":87,"column":443,"offset":5449},"indent":[]}}],"position":{"start":{"line":87,"column":1,"offset":5007},"end":{"line":87,"column":443,"offset":5449},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Retention","position":{"start":{"line":89,"column":4,"offset":5454},"end":{"line":89,"column":13,"offset":5463},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":5451},"end":{"line":89,"column":13,"offset":5463},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This is a key feature of Kafka. Brokers are configured with a default retention for topics, either some period of time or size in bytes. If limits are reached, messaged are expired and deleted so that the retention configured is a minimum amount of data available at any time.","position":{"start":{"line":91,"column":1,"offset":5465},"end":{"line":91,"column":277,"offset":5741},"indent":[]}}],"position":{"start":{"line":91,"column":1,"offset":5465},"end":{"line":91,"column":277,"offset":5741},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Retention settings can also be set for individual topics. Example: tracking topic might be retained for days, application metrics only for a few hours.","position":{"start":{"line":93,"column":1,"offset":5743},"end":{"line":93,"column":152,"offset":5894},"indent":[]}}],"position":{"start":{"line":93,"column":1,"offset":5743},"end":{"line":93,"column":152,"offset":5894},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Log Compacted Retention","position":{"start":{"line":95,"column":4,"offset":5899},"end":{"line":95,"column":27,"offset":5922},"indent":[]}}],"position":{"start":{"line":95,"column":1,"offset":5896},"end":{"line":95,"column":27,"offset":5922},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If a topic is configured as ","position":{"start":{"line":97,"column":1,"offset":5924},"end":{"line":97,"column":29,"offset":5952},"indent":[]}},{"type":"inlineCode","value":"log compacted","position":{"start":{"line":97,"column":29,"offset":5952},"end":{"line":97,"column":44,"offset":5967},"indent":[]}},{"type":"text","value":", it means Kafka will retain only the last message produced with a particular key. This can be useful for data where only the last update is relevant.","position":{"start":{"line":97,"column":44,"offset":5967},"end":{"line":97,"column":194,"offset":6117},"indent":[]}}],"position":{"start":{"line":97,"column":1,"offset":5924},"end":{"line":97,"column":194,"offset":6117},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Multiple Clusters","position":{"start":{"line":99,"column":4,"offset":6122},"end":{"line":99,"column":21,"offset":6139},"indent":[]}}],"position":{"start":{"line":99,"column":1,"offset":6119},"end":{"line":99,"column":21,"offset":6139},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"As deployment grow, it is important to have multiple clusters. The benefits:","position":{"start":{"line":101,"column":1,"offset":6141},"end":{"line":101,"column":77,"offset":6217},"indent":[]}}],"position":{"start":{"line":101,"column":1,"offset":6141},"end":{"line":101,"column":77,"offset":6217},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Segregation of types of data","position":{"start":{"line":103,"column":3,"offset":6221},"end":{"line":103,"column":31,"offset":6249},"indent":[]}}],"position":{"start":{"line":103,"column":3,"offset":6221},"end":{"line":103,"column":31,"offset":6249},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":6219},"end":{"line":103,"column":31,"offset":6249},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Isolation for security requirements","position":{"start":{"line":104,"column":3,"offset":6252},"end":{"line":104,"column":38,"offset":6287},"indent":[]}}],"position":{"start":{"line":104,"column":3,"offset":6252},"end":{"line":104,"column":38,"offset":6287},"indent":[]}}],"position":{"start":{"line":104,"column":1,"offset":6250},"end":{"line":104,"column":38,"offset":6287},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Multiple datacenters (disaster recovery)","position":{"start":{"line":105,"column":3,"offset":6290},"end":{"line":105,"column":43,"offset":6330},"indent":[]}}],"position":{"start":{"line":105,"column":3,"offset":6290},"end":{"line":105,"column":43,"offset":6330},"indent":[]}}],"position":{"start":{"line":105,"column":1,"offset":6288},"end":{"line":105,"column":43,"offset":6330},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":6219},"end":{"line":105,"column":43,"offset":6330},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"With multiple datacenters, Kafka includes a tool called ","position":{"start":{"line":107,"column":1,"offset":6332},"end":{"line":107,"column":57,"offset":6388},"indent":[]}},{"type":"inlineCode","value":"MirrorMaker","position":{"start":{"line":107,"column":57,"offset":6388},"end":{"line":107,"column":70,"offset":6401},"indent":[]}},{"type":"text","value":" used for the purpose of copying messages between datacenters. At the core, it is simply a Kafka consumer and producer linked together with a queue. Messages are consumed from one Kafka cluster and produced for another.","position":{"start":{"line":107,"column":70,"offset":6401},"end":{"line":107,"column":289,"offset":6620},"indent":[]}}],"position":{"start":{"line":107,"column":1,"offset":6332},"end":{"line":107,"column":289,"offset":6620},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":110,"column":1,"offset":6623},"end":{"line":110,"column":31,"offset":6653},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":110,"column":31,"offset":6653}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"kafka-basic-terms\"\n    }}>{`Kafka Basic Terms`}</h1>\n    <h2 {...{\n      \"id\": \"messages\"\n    }}>{`Messages`}</h2>\n    <p>{`The base unit of data within Kafka is called a message. You could think of this as a `}<inlineCode parentName=\"p\">{`row`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`record`}</inlineCode>{` if you are familiar with databases. A message is simply an array of bytes as far as Kafka is concerne, so it does not need to be a specific format.`}</p>\n    <p>{`A message can have an optional `}<inlineCode parentName=\"p\">{`key`}</inlineCode>{` which again is simply an array of bytes. This key is used when messages are to be writting ot partitions in a more controlled manner.`}</p>\n    <h2 {...{\n      \"id\": \"batches\"\n    }}>{`Batches`}</h2>\n    <p>{`For efficiency, messages are written into Kafka in batches. A `}<inlineCode parentName=\"p\">{`batch`}</inlineCode>{` is just a collection of messages, all of which are being produced to the same `}<inlineCode parentName=\"p\">{`topic`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`partition`}</inlineCode>{`. This of course is a tradeoff between latency and throughput.`}</p>\n    <p>{`The larger the batch, the more messages per unit of time that can be handled but the longer it takes for the propagation of an individual message.`}</p>\n    <p>{`Batches are typically compressed for more efficient data transfer and storage at the cost of processing power.`}</p>\n    <h2 {...{\n      \"id\": \"schemas\"\n    }}>{`Schemas`}</h2>\n    <p>{`While messages are byte arrays to Kafka, it is recommended to add additional structure in the form of a schema to be imposed on the message content so it can be easily understood.`}</p>\n    <p>{`There are many options for this depending on application needs. JSON and XML are easy and human readable but lack features such as robust type handling and compatibility between schema versions.`}</p>\n    <p>{`Most Kafka devs favour the use of Apache Avro - a serialization framework originally designed for Hadoop. Avro has compact serialisation, schemas separate from message payloads and strong data typing and schema evolution with backward/forward compatibility.`}</p>\n    <p>{`It is an imperative to choose a consistent data format.`}</p>\n    <h2 {...{\n      \"id\": \"topics\"\n    }}>{`Topics`}</h2>\n    <p>{`Topics are the categorisation of messages. Thing of this as a database table or folder in a filesystem.`}</p>\n    <h2 {...{\n      \"id\": \"partitions\"\n    }}>{`Partitions`}</h2>\n    <p>{`Topics are additionally broken down into a number of `}<inlineCode parentName=\"p\">{`partitions`}</inlineCode>{`. Consider this analagous to the \"commit log\" where messages are written to it in an append-only fashion. A topic typically has multiple partitions, so there is no guarantee of message time-ordering across the entire topic - just within a single partition.`}</p>\n    <p>{`Partitions are also used to provide redundancy and scalability.`}</p>\n    <p>{`Each partition itself can be run from a separate server to enable horizontal scalability and improve performance.`}</p>\n    <h2 {...{\n      \"id\": \"streams\"\n    }}>{`Streams`}</h2>\n    <p><inlineCode parentName=\"p\">{`Stream`}</inlineCode>{` is often used when discussing data within systems like Kafka. Often a stream is considered to be a single topic of data, irrespective of the number of partitions. This represents a stream of data going from producers to consumers.`}</p>\n    <h2 {...{\n      \"id\": \"producers\"\n    }}>{`Producers`}</h2>\n    <p>{`Producers create new messages. In alternative pub/sub systems, these can also be name `}<inlineCode parentName=\"p\">{`publishers`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`writers`}</inlineCode>{`. In general, a message is produced to a specific topic. By default, the producer does not care what partition a specific message is written to and will balance messages over all partitions of a topic evenly.`}</p>\n    <p>{`There are cases when a producer will direct a message to a particular partition, normally makig use of the message key and a partitioner that will generate a hash of the key and map it to a specific partition to ensure all messages produced with a specific key will map to a specific partition.`}</p>\n    <h2 {...{\n      \"id\": \"consumers\"\n    }}>{`Consumers`}</h2>\n    <p>{`Consumers read messages. These can also be referred to as `}<inlineCode parentName=\"p\">{`subscribers`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`readers`}</inlineCode>{` in other pub/sub systems.`}</p>\n    <p>{`These guys subscribe to one or more topics and reads messages in order they were produced. Each message in a given partition has a unique offset, and by storing that offset of the last consumed message for each partition in either Zookeeper or Kafka itself, a consumer can stop and restart without losing its place.`}</p>\n    <h2 {...{\n      \"id\": \"consumer-group\"\n    }}>{`Consumer Group`}</h2>\n    <p>{`Consumers work as part of a `}<inlineCode parentName=\"p\">{`consumer group`}</inlineCode>{`, which is one of more consumers that work together to consume a topic. This group assures that each partition is only consumed by one member.`}</p>\n    <h2 {...{\n      \"id\": \"ownership\"\n    }}>{`Ownership`}</h2>\n    <p>{`This occurs when the mapping a consumer to a partition. In this way, consumers can scale horizontally to consume topics with a large number of messages. Additionally, if a consumer fails then there is redundancy.`}</p>\n    <h2 {...{\n      \"id\": \"brokers\"\n    }}>{`Brokers`}</h2>\n    <p>{`A single Kafka server is referred to as a `}<inlineCode parentName=\"p\">{`broker`}</inlineCode>{`. The broker receives messages from producers, assigns offets to them and commits the messages to storage on disk.`}</p>\n    <p>{`The broker also service consumers. It respons to fech requests for partionans and respones with messages that have been committed to disk. A single broker could easily handle thousands of partitions and millions of messages per second pending the level of hardware.`}</p>\n    <h2 {...{\n      \"id\": \"clusters\"\n    }}>{`Clusters`}</h2>\n    <p>{`Kafka brokers are designed to operate as part of a `}<inlineCode parentName=\"p\">{`cluster`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"controller\"\n    }}>{`Controller`}</h2>\n    <p>{`Within a cluster of brokers, one broker will also function as a cluster `}<inlineCode parentName=\"p\">{`controller`}</inlineCode>{` (elected automatically). The controller is responsible for administrative operations:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Assigning partitions to brokers`}</li>\n      <li parentName=\"ul\">{`Monitoring health of brokers`}</li>\n    </ul>\n    <p>{`A partition is owned by a single broker in the cluster and that broker is called the `}<inlineCode parentName=\"p\">{`leader`}</inlineCode>{` of the partition. A partition may be assigned to multiple brokers, which will result in the partition being replaced. This provides redundancy of messages in the partition - such that another broker can take over leadership if there is a broker failure. However, all `}<inlineCode parentName=\"p\">{`consumers`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`producers`}</inlineCode>{` operating on that cluster must connect to the leader.`}</p>\n    <h2 {...{\n      \"id\": \"retention\"\n    }}>{`Retention`}</h2>\n    <p>{`This is a key feature of Kafka. Brokers are configured with a default retention for topics, either some period of time or size in bytes. If limits are reached, messaged are expired and deleted so that the retention configured is a minimum amount of data available at any time.`}</p>\n    <p>{`Retention settings can also be set for individual topics. Example: tracking topic might be retained for days, application metrics only for a few hours.`}</p>\n    <h2 {...{\n      \"id\": \"log-compacted-retention\"\n    }}>{`Log Compacted Retention`}</h2>\n    <p>{`If a topic is configured as `}<inlineCode parentName=\"p\">{`log compacted`}</inlineCode>{`, it means Kafka will retain only the last message produced with a particular key. This can be useful for data where only the last update is relevant.`}</p>\n    <h2 {...{\n      \"id\": \"multiple-clusters\"\n    }}>{`Multiple Clusters`}</h2>\n    <p>{`As deployment grow, it is important to have multiple clusters. The benefits:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Segregation of types of data`}</li>\n      <li parentName=\"ul\">{`Isolation for security requirements`}</li>\n      <li parentName=\"ul\">{`Multiple datacenters (disaster recovery)`}</li>\n    </ul>\n    <p>{`With multiple datacenters, Kafka includes a tool called `}<inlineCode parentName=\"p\">{`MirrorMaker`}</inlineCode>{` used for the purpose of copying messages between datacenters. At the core, it is simply a Kafka consumer and producer linked together with a queue. Messages are consumed from one Kafka cluster and produced for another.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}