{"expireTime":9007200848610921000,"key":"gatsby-plugin-mdx-entire-payload-159c786119630194062803f41042a1a7-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Interpreter Design Pattern","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":29,"offset":195},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":29,"offset":195},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Purpose: Behavioural\nType: Class","position":{"start":{"line":10,"column":1,"offset":197},"end":{"line":11,"column":12,"offset":229},"indent":[1]}}],"position":{"start":{"line":10,"column":1,"offset":197},"end":{"line":11,"column":12,"offset":229},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"The Interpreter Design Pattern specifies how to evaluate sentences in a string.","position":{"start":{"line":13,"column":1,"offset":231},"end":{"line":13,"column":80,"offset":310},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":231},"end":{"line":13,"column":80,"offset":310},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The idea is to have a class for each symbol. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (intrepret) the sentence for a client.","position":{"start":{"line":15,"column":1,"offset":312},"end":{"line":15,"column":194,"offset":505},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":312},"end":{"line":15,"column":194,"offset":505},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Participants","position":{"start":{"line":17,"column":4,"offset":510},"end":{"line":17,"column":16,"offset":522},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":507},"end":{"line":17,"column":16,"offset":522},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"AbstractExpression (declares interpret method common to all nodes)","position":{"start":{"line":19,"column":3,"offset":526},"end":{"line":19,"column":69,"offset":592},"indent":[]}}],"position":{"start":{"line":19,"column":3,"offset":526},"end":{"line":19,"column":69,"offset":592},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":524},"end":{"line":19,"column":69,"offset":592},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"TerminalExpression (interpret terminal symbols in the grammar)","position":{"start":{"line":20,"column":3,"offset":595},"end":{"line":20,"column":65,"offset":657},"indent":[]}}],"position":{"start":{"line":20,"column":3,"offset":595},"end":{"line":20,"column":65,"offset":657},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":593},"end":{"line":20,"column":65,"offset":657},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"NonTerminalExpression (maintains instance variables of type AbstractExpression for nonterminal symbols in grammar)","position":{"start":{"line":21,"column":3,"offset":660},"end":{"line":21,"column":117,"offset":774},"indent":[]}}],"position":{"start":{"line":21,"column":3,"offset":660},"end":{"line":21,"column":117,"offset":774},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":658},"end":{"line":21,"column":117,"offset":774},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Context (info global to interpreter)","position":{"start":{"line":22,"column":3,"offset":777},"end":{"line":22,"column":39,"offset":813},"indent":[]}}],"position":{"start":{"line":22,"column":3,"offset":777},"end":{"line":22,"column":39,"offset":813},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":775},"end":{"line":22,"column":39,"offset":813},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Client (builds abstract syntax tree representing a particular sentence in the language that the grammar defines)","position":{"start":{"line":23,"column":3,"offset":816},"end":{"line":23,"column":115,"offset":928},"indent":[]}}],"position":{"start":{"line":23,"column":3,"offset":816},"end":{"line":23,"column":115,"offset":928},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":814},"end":{"line":23,"column":115,"offset":928},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":524},"end":{"line":23,"column":115,"offset":928},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Example","position":{"start":{"line":25,"column":4,"offset":933},"end":{"line":25,"column":11,"offset":940},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":930},"end":{"line":25,"column":11,"offset":940},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"class Context {\n  private _input;\n\n  constructor(input) {\n    this._input = input;\n  }\n\n  public set input(value) {\n    this._input = value;\n  }\n}\n\ninterface Expression {\n  interpret(context: Context): void;\n}\n\nclass TerminalExpression implements Expression {\n  interpret(context: Context): void {\n    // process comma\n    console.log('interpret terminal');\n  }\n}\n\nclass NoneTerminalExpression implements Expression {\n  interpret(context: Context): void {\n    // process variable\n    console.log('interpret nonterminal');\n  }\n}\n\n(function main() {\n  const context: Context = new Context('1 bird can fly');\n  const list = [];\n  list.push(new TerminalExpression());\n  list.push(new NoneTerminalExpression());\n\n  list.map((exp: Expression) => {\n    exp.interpret(context);\n  });\n})();","position":{"start":{"line":27,"column":1,"offset":942},"end":{"line":68,"column":4,"offset":1741},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":70,"column":4,"offset":1746},"end":{"line":70,"column":13,"offset":1755},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":1743},"end":{"line":70,"column":13,"offset":1755},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://ruslanspivak.com/lsbasi-part7/","children":[{"type":"text","value":"AST in action","position":{"start":{"line":72,"column":4,"offset":1760},"end":{"line":72,"column":17,"offset":1773},"indent":[]}}],"position":{"start":{"line":72,"column":3,"offset":1759},"end":{"line":72,"column":58,"offset":1814},"indent":[]}}],"position":{"start":{"line":72,"column":3,"offset":1759},"end":{"line":72,"column":58,"offset":1814},"indent":[]}}],"position":{"start":{"line":72,"column":1,"offset":1757},"end":{"line":72,"column":58,"offset":1814},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://www.baeldung.com/java-interpreter-pattern","children":[{"type":"text","value":"Java Interpreter for SQL","position":{"start":{"line":73,"column":4,"offset":1818},"end":{"line":73,"column":28,"offset":1842},"indent":[]}}],"position":{"start":{"line":73,"column":3,"offset":1817},"end":{"line":73,"column":80,"offset":1894},"indent":[]}}],"position":{"start":{"line":73,"column":3,"offset":1817},"end":{"line":73,"column":80,"offset":1894},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":1815},"end":{"line":73,"column":80,"offset":1894},"indent":[]}}],"position":{"start":{"line":72,"column":1,"offset":1757},"end":{"line":73,"column":80,"offset":1894},"indent":[1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":76,"column":1,"offset":1897},"end":{"line":76,"column":31,"offset":1927},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":76,"column":31,"offset":1927}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"interpreter-design-pattern\"\n    }}>{`Interpreter Design Pattern`}</h1>\n    <p>{`Purpose: Behavioural\nType: Class`}</p>\n    <p>{`The Interpreter Design Pattern specifies how to evaluate sentences in a string.`}</p>\n    <p>{`The idea is to have a class for each symbol. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (intrepret) the sentence for a client.`}</p>\n    <h2 {...{\n      \"id\": \"participants\"\n    }}>{`Participants`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`AbstractExpression (declares interpret method common to all nodes)`}</li>\n      <li parentName=\"ul\">{`TerminalExpression (interpret terminal symbols in the grammar)`}</li>\n      <li parentName=\"ul\">{`NonTerminalExpression (maintains instance variables of type AbstractExpression for nonterminal symbols in grammar)`}</li>\n      <li parentName=\"ul\">{`Context (info global to interpreter)`}</li>\n      <li parentName=\"ul\">{`Client (builds abstract syntax tree representing a particular sentence in the language that the grammar defines)`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"example\"\n    }}>{`Example`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Context {\n  private _input;\n\n  constructor(input) {\n    this._input = input;\n  }\n\n  public set input(value) {\n    this._input = value;\n  }\n}\n\ninterface Expression {\n  interpret(context: Context): void;\n}\n\nclass TerminalExpression implements Expression {\n  interpret(context: Context): void {\n    // process comma\n    console.log('interpret terminal');\n  }\n}\n\nclass NoneTerminalExpression implements Expression {\n  interpret(context: Context): void {\n    // process variable\n    console.log('interpret nonterminal');\n  }\n}\n\n(function main() {\n  const context: Context = new Context('1 bird can fly');\n  const list = [];\n  list.push(new TerminalExpression());\n  list.push(new NoneTerminalExpression());\n\n  list.map((exp: Expression) => {\n    exp.interpret(context);\n  });\n})();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://ruslanspivak.com/lsbasi-part7/\"\n        }}>{`AST in action`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.baeldung.com/java-interpreter-pattern\"\n        }}>{`Java Interpreter for SQL`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}