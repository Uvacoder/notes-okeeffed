{"expireTime":9007200867335966000,"key":"gatsby-plugin-mdx-entire-payload-1f67f3a10b6bbbb774a5b4f107c33b7d-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Elixir School","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":16,"offset":182},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":16,"offset":182},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"References and notes come from the ","position":{"start":{"line":10,"column":1,"offset":184},"end":{"line":10,"column":36,"offset":219},"indent":[]}},{"type":"link","title":null,"url":"https://elixirschool.com/en/","children":[{"type":"text","value":"Elixir School page","position":{"start":{"line":10,"column":37,"offset":220},"end":{"line":10,"column":55,"offset":238},"indent":[]}}],"position":{"start":{"line":10,"column":36,"offset":219},"end":{"line":10,"column":86,"offset":269},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":10,"column":86,"offset":269},"end":{"line":10,"column":87,"offset":270},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":184},"end":{"line":10,"column":87,"offset":270},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Basic Types","position":{"start":{"line":12,"column":4,"offset":275},"end":{"line":12,"column":15,"offset":286},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":272},"end":{"line":12,"column":15,"offset":286},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"These just include unusual ones that are important to know:","position":{"start":{"line":14,"column":1,"offset":288},"end":{"line":14,"column":60,"offset":347},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":288},"end":{"line":14,"column":60,"offset":347},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Atoms","position":{"start":{"line":16,"column":5,"offset":353},"end":{"line":16,"column":10,"offset":358},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":349},"end":{"line":16,"column":10,"offset":358},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A constant whose name is value - synonymous with Ruby Symbols:","position":{"start":{"line":18,"column":1,"offset":360},"end":{"line":18,"column":63,"offset":422},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":360},"end":{"line":18,"column":63,"offset":422},"indent":[]}},{"type":"code","lang":"elixir","meta":null,"value":":foo == :bar # returns false","position":{"start":{"line":20,"column":1,"offset":424},"end":{"line":22,"column":4,"offset":466},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Booleans ","position":{"start":{"line":24,"column":1,"offset":468},"end":{"line":24,"column":10,"offset":477},"indent":[]}},{"type":"inlineCode","value":"true","position":{"start":{"line":24,"column":10,"offset":477},"end":{"line":24,"column":16,"offset":483},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":24,"column":16,"offset":483},"end":{"line":24,"column":21,"offset":488},"indent":[]}},{"type":"inlineCode","value":"false","position":{"start":{"line":24,"column":21,"offset":488},"end":{"line":24,"column":28,"offset":495},"indent":[]}},{"type":"text","value":" are also the atoms ","position":{"start":{"line":24,"column":28,"offset":495},"end":{"line":24,"column":48,"offset":515},"indent":[]}},{"type":"inlineCode","value":":true","position":{"start":{"line":24,"column":48,"offset":515},"end":{"line":24,"column":55,"offset":522},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":24,"column":55,"offset":522},"end":{"line":24,"column":60,"offset":527},"indent":[]}},{"type":"inlineCode","value":":false","position":{"start":{"line":24,"column":60,"offset":527},"end":{"line":24,"column":68,"offset":535},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":24,"column":68,"offset":535},"end":{"line":24,"column":69,"offset":536},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":468},"end":{"line":24,"column":69,"offset":536},"indent":[]}},{"type":"code","lang":"elixir","meta":null,"value":"true |> is_atom # true\n:true |> is_boolean # true\n:true === true # true","position":{"start":{"line":26,"column":1,"offset":538},"end":{"line":30,"column":4,"offset":623},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The names of modules are also atoms:","position":{"start":{"line":32,"column":1,"offset":625},"end":{"line":32,"column":37,"offset":661},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":625},"end":{"line":32,"column":37,"offset":661},"indent":[]}},{"type":"code","lang":"elixir","meta":null,"value":"is_atom(MyApp.MyModule) # true","position":{"start":{"line":34,"column":1,"offset":663},"end":{"line":36,"column":4,"offset":707},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Atoms are also used to reference modules from Erlang libraries, including built in ones.","position":{"start":{"line":38,"column":1,"offset":709},"end":{"line":38,"column":89,"offset":797},"indent":[]}}],"position":{"start":{"line":38,"column":1,"offset":709},"end":{"line":38,"column":89,"offset":797},"indent":[]}},{"type":"code","lang":"elixir","meta":null,"value":":crypto.strong_rand_bytes 3 # <<23, 104, 108>>","position":{"start":{"line":40,"column":1,"offset":799},"end":{"line":42,"column":4,"offset":859},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Conditionals","position":{"start":{"line":44,"column":4,"offset":864},"end":{"line":44,"column":16,"offset":876},"indent":[]}}],"position":{"start":{"line":44,"column":1,"offset":861},"end":{"line":44,"column":16,"offset":876},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Elixir provides the ||, &&, and ! boolean operators. There are three additional operators whose first argument must be a boolean (true or false):","position":{"start":{"line":46,"column":1,"offset":878},"end":{"line":46,"column":146,"offset":1023},"indent":[]}}],"position":{"start":{"line":46,"column":1,"offset":878},"end":{"line":46,"column":146,"offset":1023},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"iex> true and 42\n42\niex> false or true\ntrue\niex> not false\ntrue\niex> 42 and true\n** (ArgumentError) argument error: 42\niex> not 42\n** (ArgumentError) argument error","position":{"start":{"line":48,"column":1,"offset":1025},"end":{"line":59,"column":4,"offset":1202},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Note: Elixir’s and and or actually map to ","position":{"start":{"line":61,"column":1,"offset":1204},"end":{"line":61,"column":43,"offset":1246},"indent":[]}},{"type":"inlineCode","value":"andalso","position":{"start":{"line":61,"column":43,"offset":1246},"end":{"line":61,"column":52,"offset":1255},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":61,"column":52,"offset":1255},"end":{"line":61,"column":57,"offset":1260},"indent":[]}},{"type":"inlineCode","value":"orelse","position":{"start":{"line":61,"column":57,"offset":1260},"end":{"line":61,"column":65,"offset":1268},"indent":[]}},{"type":"text","value":" in Erlang.","position":{"start":{"line":61,"column":65,"offset":1268},"end":{"line":61,"column":76,"offset":1279},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":1204},"end":{"line":61,"column":76,"offset":1279},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Comparisons","position":{"start":{"line":63,"column":4,"offset":1284},"end":{"line":63,"column":15,"offset":1295},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":1281},"end":{"line":63,"column":15,"offset":1295},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Elixir comes with all the comparison operators we’re used to: ==, !=, ===, !==, <=, >=, <, and >.","position":{"start":{"line":65,"column":1,"offset":1297},"end":{"line":65,"column":98,"offset":1394},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":1297},"end":{"line":65,"column":98,"offset":1394},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For strict comparison of integers and floats, use ===:","position":{"start":{"line":67,"column":1,"offset":1396},"end":{"line":67,"column":55,"offset":1450},"indent":[]}}],"position":{"start":{"line":67,"column":1,"offset":1396},"end":{"line":67,"column":55,"offset":1450},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"iex> 2 == 2.0\ntrue\niex> 2 === 2.0\nfalse","position":{"start":{"line":69,"column":1,"offset":1452},"end":{"line":74,"column":4,"offset":1504},"indent":[1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Interpolation","position":{"start":{"line":76,"column":4,"offset":1509},"end":{"line":76,"column":17,"offset":1522},"indent":[]}}],"position":{"start":{"line":76,"column":1,"offset":1506},"end":{"line":76,"column":17,"offset":1522},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"iex> name = \"Sean\"\niex> \"Hello #{name}\"\n\"Hello Sean\"","position":{"start":{"line":78,"column":1,"offset":1524},"end":{"line":82,"column":4,"offset":1589},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Concatenation","position":{"start":{"line":84,"column":4,"offset":1594},"end":{"line":84,"column":17,"offset":1607},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":1591},"end":{"line":84,"column":17,"offset":1607},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"iex> name = \"Sean\"\niex> \"Hello \" <> name\n\"Hello Sean\"","position":{"start":{"line":86,"column":1,"offset":1609},"end":{"line":90,"column":4,"offset":1675},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Pattern Matching","position":{"start":{"line":92,"column":4,"offset":1680},"end":{"line":92,"column":20,"offset":1696},"indent":[]}}],"position":{"start":{"line":92,"column":1,"offset":1677},"end":{"line":92,"column":20,"offset":1696},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Match Operator","position":{"start":{"line":94,"column":5,"offset":1702},"end":{"line":94,"column":19,"offset":1716},"indent":[]}}],"position":{"start":{"line":94,"column":1,"offset":1698},"end":{"line":94,"column":19,"offset":1716},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"# Assignment\niex> x = 1\n1\n# Pattern matching\niex> 1 = x\n1\niex> 2 = x\n** (MatchError) no match of right hand side value: 1\n\n# Lists\niex> list = [1, 2, 3]\niex> [1, 2, 3] = list\n[1, 2, 3]\niex> [] = list\n** (MatchError) no match of right hand side value: [1, 2, 3]\n\niex> [1 | tail] = list\n[1, 2, 3]\niex> tail\n[2, 3]\niex> [2 | _] = list\n** (MatchError) no match of right hand side value: [1, 2, 3]\n\n# Tuples\niex> {:ok, value} = {:ok, \"Successful!\"}\n{:ok, \"Successful!\"}\niex> value\n\"Successful!\"\niex> {:ok, value} = {:error}\n** (MatchError) no match of right hand side value: {:error}","position":{"start":{"line":96,"column":1,"offset":1718},"end":{"line":127,"column":4,"offset":2309},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Pin Operator","position":{"start":{"line":129,"column":5,"offset":2315},"end":{"line":129,"column":17,"offset":2327},"indent":[]}}],"position":{"start":{"line":129,"column":1,"offset":2311},"end":{"line":129,"column":17,"offset":2327},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"iex> x = 1\n1\niex> ^x = 2\n** (MatchError) no match of right hand side value: 2\niex> {x, ^x} = {2, 1}\n{2, 1}\niex> x\n2","position":{"start":{"line":131,"column":1,"offset":2329},"end":{"line":140,"column":4,"offset":2457},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"An example of pinning in a function clause:","position":{"start":{"line":142,"column":1,"offset":2459},"end":{"line":142,"column":44,"offset":2502},"indent":[]}}],"position":{"start":{"line":142,"column":1,"offset":2459},"end":{"line":142,"column":44,"offset":2502},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"iex> greeting = \"Hello\"\n\"Hello\"\niex> greet = fn\n...>   (^greeting, name) -> \"Hi #{name}\"\n...>   (greeting, name) -> \"#{greeting}, #{name}\"\n...> end\n#Function<12.54118792/2 in :erl_eval.expr/5>\niex> greet.(\"Hello\", \"Sean\")\n\"Hi Sean\"\niex> greet.(\"Mornin'\", \"Sean\")\n\"Mornin', Sean\"\niex> greeting\n\"Hello\"","position":{"start":{"line":144,"column":1,"offset":2504},"end":{"line":158,"column":4,"offset":2817},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":161,"column":1,"offset":2820},"end":{"line":161,"column":31,"offset":2850},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":161,"column":31,"offset":2850}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"elixir-school\"\n    }}>{`Elixir School`}</h1>\n    <p>{`References and notes come from the `}<a parentName=\"p\" {...{\n        \"href\": \"https://elixirschool.com/en/\"\n      }}>{`Elixir School page`}</a>{`.`}</p>\n    <h2 {...{\n      \"id\": \"basic-types\"\n    }}>{`Basic Types`}</h2>\n    <p>{`These just include unusual ones that are important to know:`}</p>\n    <h3 {...{\n      \"id\": \"atoms\"\n    }}>{`Atoms`}</h3>\n    <p>{`A constant whose name is value - synonymous with Ruby Symbols:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-elixir\"\n      }}>{`:foo == :bar # returns false\n`}</code></pre>\n    <p>{`Booleans `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{` are also the atoms `}<inlineCode parentName=\"p\">{`:true`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`:false`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-elixir\"\n      }}>{`true |> is_atom # true\n:true |> is_boolean # true\n:true === true # true\n`}</code></pre>\n    <p>{`The names of modules are also atoms:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-elixir\"\n      }}>{`is_atom(MyApp.MyModule) # true\n`}</code></pre>\n    <p>{`Atoms are also used to reference modules from Erlang libraries, including built in ones.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-elixir\"\n      }}>{`:crypto.strong_rand_bytes 3 # <<23, 104, 108>>\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"conditionals\"\n    }}>{`Conditionals`}</h2>\n    <p>{`Elixir provides the ||, &&, and ! boolean operators. There are three additional operators whose first argument must be a boolean (true or false):`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`iex> true and 42\n42\niex> false or true\ntrue\niex> not false\ntrue\niex> 42 and true\n** (ArgumentError) argument error: 42\niex> not 42\n** (ArgumentError) argument error\n`}</code></pre>\n    <p>{`Note: Elixir’s and and or actually map to `}<inlineCode parentName=\"p\">{`andalso`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`orelse`}</inlineCode>{` in Erlang.`}</p>\n    <h2 {...{\n      \"id\": \"comparisons\"\n    }}>{`Comparisons`}</h2>\n    <p>{`Elixir comes with all the comparison operators we’re used to: ==, !=, ===, !==, <=, >=, <, and >.`}</p>\n    <p>{`For strict comparison of integers and floats, use ===:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`iex> 2 == 2.0\ntrue\niex> 2 === 2.0\nfalse\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"interpolation\"\n    }}>{`Interpolation`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`iex> name = \"Sean\"\niex> \"Hello #{name}\"\n\"Hello Sean\"\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"concatenation\"\n    }}>{`Concatenation`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`iex> name = \"Sean\"\niex> \"Hello \" <> name\n\"Hello Sean\"\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"pattern-matching\"\n    }}>{`Pattern Matching`}</h2>\n    <h3 {...{\n      \"id\": \"match-operator\"\n    }}>{`Match Operator`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`# Assignment\niex> x = 1\n1\n# Pattern matching\niex> 1 = x\n1\niex> 2 = x\n** (MatchError) no match of right hand side value: 1\n\n# Lists\niex> list = [1, 2, 3]\niex> [1, 2, 3] = list\n[1, 2, 3]\niex> [] = list\n** (MatchError) no match of right hand side value: [1, 2, 3]\n\niex> [1 | tail] = list\n[1, 2, 3]\niex> tail\n[2, 3]\niex> [2 | _] = list\n** (MatchError) no match of right hand side value: [1, 2, 3]\n\n# Tuples\niex> {:ok, value} = {:ok, \"Successful!\"}\n{:ok, \"Successful!\"}\niex> value\n\"Successful!\"\niex> {:ok, value} = {:error}\n** (MatchError) no match of right hand side value: {:error}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"pin-operator\"\n    }}>{`Pin Operator`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`iex> x = 1\n1\niex> ^x = 2\n** (MatchError) no match of right hand side value: 2\niex> {x, ^x} = {2, 1}\n{2, 1}\niex> x\n2\n`}</code></pre>\n    <p>{`An example of pinning in a function clause:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`iex> greeting = \"Hello\"\n\"Hello\"\niex> greet = fn\n...>   (^greeting, name) -> \"Hi #{name}\"\n...>   (greeting, name) -> \"#{greeting}, #{name}\"\n...> end\n#Function<12.54118792/2 in :erl_eval.expr/5>\niex> greet.(\"Hello\", \"Sean\")\n\"Hi Sean\"\niex> greet.(\"Mornin'\", \"Sean\")\n\"Mornin', Sean\"\niex> greeting\n\"Hello\"\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}