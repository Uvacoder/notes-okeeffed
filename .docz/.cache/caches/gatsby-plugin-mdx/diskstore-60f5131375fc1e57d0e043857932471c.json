{"expireTime":9007200852878428000,"key":"gatsby-plugin-mdx-entire-payload-808829ce5a76d142f2b8b43fba8e940c-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Types and Typeclasses","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":24,"offset":190},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":24,"offset":190},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":10,"column":4,"offset":195},"end":{"line":10,"column":13,"offset":204},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":192},"end":{"line":10,"column":13,"offset":204},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"http://learnyouahaskell.com/types-and-typeclasses#believe-the-type","children":[{"type":"text","value":"Learn You A Haskell","position":{"start":{"line":12,"column":5,"offset":210},"end":{"line":12,"column":24,"offset":229},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":209},"end":{"line":12,"column":93,"offset":298},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":209},"end":{"line":12,"column":93,"offset":298},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":206},"end":{"line":12,"column":93,"offset":298},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":206},"end":{"line":12,"column":93,"offset":298},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Checking types on ghci","position":{"start":{"line":14,"column":4,"offset":303},"end":{"line":14,"column":26,"offset":325},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":300},"end":{"line":14,"column":26,"offset":325},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Use the ","position":{"start":{"line":16,"column":1,"offset":327},"end":{"line":16,"column":9,"offset":335},"indent":[]}},{"type":"inlineCode","value":":t","position":{"start":{"line":16,"column":9,"offset":335},"end":{"line":16,"column":13,"offset":339},"indent":[]}},{"type":"text","value":" command followed by a valid expression.","position":{"start":{"line":16,"column":13,"offset":339},"end":{"line":16,"column":53,"offset":379},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":327},"end":{"line":16,"column":53,"offset":379},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> :t 'a'\n'a' :: Char\nghci> :t True\nTrue :: Bool\nghci> :t \"HELLO!\"\n\"HELLO!\" :: [Char]\nghci> :t (True, 'a')\n(True, 'a') :: (Bool, Char)\nghci> :t 4 == 5\n4 == 5 :: Bool","position":{"start":{"line":18,"column":1,"offset":381},"end":{"line":29,"column":4,"offset":558},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Function Types","position":{"start":{"line":31,"column":4,"offset":563},"end":{"line":31,"column":18,"offset":577},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":560},"end":{"line":31,"column":18,"offset":577},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can choose to give functions an explicit type definition. This is considered good practice except for short functions.","position":{"start":{"line":33,"column":1,"offset":579},"end":{"line":33,"column":122,"offset":700},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":579},"end":{"line":33,"column":122,"offset":700},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"removeNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]","position":{"start":{"line":35,"column":1,"offset":702},"end":{"line":38,"column":4,"offset":815},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here is an example for a function that takes three ","position":{"start":{"line":40,"column":1,"offset":817},"end":{"line":40,"column":52,"offset":868},"indent":[]}},{"type":"inlineCode","value":"Int","position":{"start":{"line":40,"column":52,"offset":868},"end":{"line":40,"column":57,"offset":873},"indent":[]}},{"type":"text","value":" args and adds them together.","position":{"start":{"line":40,"column":57,"offset":873},"end":{"line":40,"column":86,"offset":902},"indent":[]}}],"position":{"start":{"line":40,"column":1,"offset":817},"end":{"line":40,"column":86,"offset":902},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"addThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z","position":{"start":{"line":42,"column":1,"offset":904},"end":{"line":45,"column":4,"offset":982},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Typeclasses","position":{"start":{"line":47,"column":4,"offset":987},"end":{"line":47,"column":15,"offset":998},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":984},"end":{"line":47,"column":15,"offset":998},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that is supports and implements the behaviour the typeclass describes.","position":{"start":{"line":49,"column":1,"offset":1000},"end":{"line":49,"column":181,"offset":1180},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":1000},"end":{"line":49,"column":181,"offset":1180},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> :t (==)\n(==) :: Eq a => a -> a -> Bool\nghci> 5 /= 5\nFalse\nghci> :t 5 /= 5\n5 /= 5 :: Bool\nghci> :t (>)\n(>) :: Ord a => a -> a -> Bool","position":{"start":{"line":51,"column":1,"offset":1182},"end":{"line":60,"column":4,"offset":1329},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Typeclass ","position":{"start":{"line":62,"column":1,"offset":1331},"end":{"line":62,"column":11,"offset":1341},"indent":[]}},{"type":"inlineCode","value":"Ord","position":{"start":{"line":62,"column":11,"offset":1341},"end":{"line":62,"column":16,"offset":1346},"indent":[]}},{"type":"text","value":" covers all comparing functions.","position":{"start":{"line":62,"column":16,"offset":1346},"end":{"line":62,"column":48,"offset":1378},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":1331},"end":{"line":62,"column":48,"offset":1378},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> \"Abrakadabra\" < \"Zebra\"\nTrue\nghci> \"Abrakadabra\" `compare` \"Zebra\"\nLT\nghci> 5 >= 2\nTrue\nghci> 5 `compare` 3\nGT","position":{"start":{"line":64,"column":1,"offset":1380},"end":{"line":73,"column":4,"offset":1505},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Members of ","position":{"start":{"line":75,"column":1,"offset":1507},"end":{"line":75,"column":12,"offset":1518},"indent":[]}},{"type":"inlineCode","value":"Show","position":{"start":{"line":75,"column":12,"offset":1518},"end":{"line":75,"column":18,"offset":1524},"indent":[]}},{"type":"text","value":" can be presented as strings. All types covered so far except for functions are a part of Show. The most used function that deals with the Show typeclass is show. It takes a value whose type is a member of Show and presents it to us as a string.","position":{"start":{"line":75,"column":18,"offset":1524},"end":{"line":75,"column":263,"offset":1769},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":1507},"end":{"line":75,"column":263,"offset":1769},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> show 3\n\"3\"\nghci> show 5.334\n\"5.334\"\nghci> show True\n\"True\"","position":{"start":{"line":77,"column":1,"offset":1771},"end":{"line":84,"column":4,"offset":1844},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Read","position":{"start":{"line":86,"column":1,"offset":1846},"end":{"line":86,"column":7,"offset":1852},"indent":[]}},{"type":"text","value":" is sort of the opposite typeclass of Show. The read function takes a string and returns a type which is a member of Read.","position":{"start":{"line":86,"column":7,"offset":1852},"end":{"line":86,"column":129,"offset":1974},"indent":[]}}],"position":{"start":{"line":86,"column":1,"offset":1846},"end":{"line":86,"column":129,"offset":1974},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> read \"True\" || False\nTrue\nghci> read \"8.2\" + 3.8\n12.0\nghci> read \"5\" - 2\n3\nghci> read \"[1,2,3,4]\" ++ [3]\n[1,2,3,4,3]","position":{"start":{"line":88,"column":1,"offset":1976},"end":{"line":97,"column":4,"offset":2107},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type Annotations","position":{"start":{"line":99,"column":4,"offset":2112},"end":{"line":99,"column":20,"offset":2128},"indent":[]}}],"position":{"start":{"line":99,"column":1,"offset":2109},"end":{"line":99,"column":20,"offset":2128},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Type annotations are a way of explicitly saying what the type of an expression should be. We do that by adding :: at the end of the expression and then specifying a type. Observe:","position":{"start":{"line":101,"column":1,"offset":2130},"end":{"line":101,"column":180,"offset":2309},"indent":[]}}],"position":{"start":{"line":101,"column":1,"offset":2130},"end":{"line":101,"column":180,"offset":2309},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> read \"5\" :: Int\n5\nghci> read \"5\" :: Float\n5.0\nghci> (read \"5\" :: Float) * 4\n20.0\nghci> read \"[1,2,3,4]\" :: [Int][1,2,3,4]\nghci> read \"(3, 'a')\" :: (Int, Char)\n(3, 'a')","position":{"start":{"line":103,"column":1,"offset":2311},"end":{"line":113,"column":4,"offset":2493},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Enum Members","position":{"start":{"line":115,"column":4,"offset":2498},"end":{"line":115,"column":16,"offset":2510},"indent":[]}}],"position":{"start":{"line":115,"column":1,"offset":2495},"end":{"line":115,"column":16,"offset":2510},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Enum","position":{"start":{"line":117,"column":1,"offset":2512},"end":{"line":117,"column":7,"offset":2518},"indent":[]}},{"type":"text","value":" members are sequentially ordered types — they can be enumerated. The main advantage of the ","position":{"start":{"line":117,"column":7,"offset":2518},"end":{"line":117,"column":99,"offset":2610},"indent":[]}},{"type":"inlineCode","value":"Enum","position":{"start":{"line":117,"column":99,"offset":2610},"end":{"line":117,"column":105,"offset":2616},"indent":[]}},{"type":"text","value":" typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the succ and pred functions. Types in this class: (), Bool, Char, Ordering, Int, Integer, Float and Double.","position":{"start":{"line":117,"column":105,"offset":2616},"end":{"line":117,"column":342,"offset":2853},"indent":[]}}],"position":{"start":{"line":117,"column":1,"offset":2512},"end":{"line":117,"column":342,"offset":2853},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> ['a'..'e']\n\"abcde\"\nghci> [LT .. GT]\n[LT,EQ,GT]\nghci> [3 .. 5]\n[3,4,5]\nghci> succ 'B'\n'C'","position":{"start":{"line":119,"column":1,"offset":2855},"end":{"line":128,"column":4,"offset":2958},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Bounded","position":{"start":{"line":130,"column":4,"offset":2963},"end":{"line":130,"column":11,"offset":2970},"indent":[]}}],"position":{"start":{"line":130,"column":1,"offset":2960},"end":{"line":130,"column":11,"offset":2970},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Bounded","position":{"start":{"line":132,"column":1,"offset":2972},"end":{"line":132,"column":10,"offset":2981},"indent":[]}},{"type":"text","value":" members have an upper and a lower bound.","position":{"start":{"line":132,"column":10,"offset":2981},"end":{"line":132,"column":51,"offset":3022},"indent":[]}}],"position":{"start":{"line":132,"column":1,"offset":2972},"end":{"line":132,"column":51,"offset":3022},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> minBound :: Int\n-2147483648\nghci> maxBound :: Char\n'\\1114111'\nghci> maxBound :: Bool\nTrue\nghci> minBound :: Bool\nFalse","position":{"start":{"line":134,"column":1,"offset":3024},"end":{"line":143,"column":4,"offset":3157},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"minBound and maxBound are interesting because they have a type of (Bounded a) => a. In a sense they are polymorphic constants.","position":{"start":{"line":145,"column":1,"offset":3159},"end":{"line":145,"column":127,"offset":3285},"indent":[]}}],"position":{"start":{"line":145,"column":1,"offset":3159},"end":{"line":145,"column":127,"offset":3285},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"All tuples are also part of Bounded if the components are also in it.","position":{"start":{"line":147,"column":1,"offset":3287},"end":{"line":147,"column":70,"offset":3356},"indent":[]}}],"position":{"start":{"line":147,"column":1,"offset":3287},"end":{"line":147,"column":70,"offset":3356},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> maxBound :: (Bool, Int, Char)\n(True,2147483647,'\\1114111')","position":{"start":{"line":149,"column":1,"offset":3358},"end":{"line":152,"column":4,"offset":3431},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Num","position":{"start":{"line":154,"column":4,"offset":3436},"end":{"line":154,"column":7,"offset":3439},"indent":[]}}],"position":{"start":{"line":154,"column":1,"offset":3433},"end":{"line":154,"column":7,"offset":3439},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Num","position":{"start":{"line":156,"column":1,"offset":3441},"end":{"line":156,"column":6,"offset":3446},"indent":[]}},{"type":"text","value":" is a numeric typeclass. Its members have the property of being able to act like numbers. Let's examine the type of a number.","position":{"start":{"line":156,"column":6,"offset":3446},"end":{"line":156,"column":131,"offset":3571},"indent":[]}}],"position":{"start":{"line":156,"column":1,"offset":3441},"end":{"line":156,"column":131,"offset":3571},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> :t 20\n20 :: (Num t) => t","position":{"start":{"line":158,"column":1,"offset":3573},"end":{"line":161,"column":4,"offset":3612},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"It appears that whole numbers are also polymorphic constants. They can act like any type that's a member of the Num typeclass.","position":{"start":{"line":163,"column":1,"offset":3614},"end":{"line":163,"column":127,"offset":3740},"indent":[]}}],"position":{"start":{"line":163,"column":1,"offset":3614},"end":{"line":163,"column":127,"offset":3740},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> 20 :: Int\n20\nghci> 20 :: Integer\n20\nghci> 20 :: Float\n20.0\nghci> 20 :: Double\n20.0","position":{"start":{"line":165,"column":1,"offset":3742},"end":{"line":174,"column":4,"offset":3839},"indent":[1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Those are types that are in the Num typeclass. If we examine the type of ","position":{"start":{"line":176,"column":1,"offset":3841},"end":{"line":176,"column":74,"offset":3914},"indent":[]}},{"type":"text","value":"*","position":{"start":{"line":176,"column":74,"offset":3914},"end":{"line":176,"column":76,"offset":3916},"indent":[]}},{"type":"text","value":", we'll see that it accepts all numbers.","position":{"start":{"line":176,"column":76,"offset":3916},"end":{"line":176,"column":116,"offset":3956},"indent":[]}}],"position":{"start":{"line":176,"column":1,"offset":3841},"end":{"line":176,"column":116,"offset":3956},"indent":[]}},{"type":"code","lang":"s","meta":null,"value":"ghci> :t (*)\n(*) :: (Num a) => a -> a -> a","position":{"start":{"line":178,"column":1,"offset":3958},"end":{"line":181,"column":4,"offset":4009},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"It takes two numbers of the same type and returns a number of that type. That's why ","position":{"start":{"line":183,"column":1,"offset":4011},"end":{"line":183,"column":85,"offset":4095},"indent":[]}},{"type":"inlineCode","value":"(5 :: Int) * (6 :: Integer)","position":{"start":{"line":183,"column":85,"offset":4095},"end":{"line":183,"column":114,"offset":4124},"indent":[]}},{"type":"text","value":" will result in a type error whereas ","position":{"start":{"line":183,"column":114,"offset":4124},"end":{"line":183,"column":151,"offset":4161},"indent":[]}},{"type":"inlineCode","value":"5 * (6 :: Integer)","position":{"start":{"line":183,"column":151,"offset":4161},"end":{"line":183,"column":171,"offset":4181},"indent":[]}},{"type":"text","value":" will work just fine and produce an Integer because 5 can act like an Integer or an Int.","position":{"start":{"line":183,"column":171,"offset":4181},"end":{"line":183,"column":259,"offset":4269},"indent":[]}}],"position":{"start":{"line":183,"column":1,"offset":4011},"end":{"line":183,"column":259,"offset":4269},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"To join Num, a type must already be friends with Show and Eq.","position":{"start":{"line":185,"column":1,"offset":4271},"end":{"line":185,"column":62,"offset":4332},"indent":[]}}],"position":{"start":{"line":185,"column":1,"offset":4271},"end":{"line":185,"column":62,"offset":4332},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Integral","position":{"start":{"line":187,"column":1,"offset":4334},"end":{"line":187,"column":11,"offset":4344},"indent":[]}},{"type":"text","value":" includes only integral (whole) numbers. In this typeclass are ","position":{"start":{"line":187,"column":11,"offset":4344},"end":{"line":187,"column":74,"offset":4407},"indent":[]}},{"type":"inlineCode","value":"Int","position":{"start":{"line":187,"column":74,"offset":4407},"end":{"line":187,"column":79,"offset":4412},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":187,"column":79,"offset":4412},"end":{"line":187,"column":84,"offset":4417},"indent":[]}},{"type":"inlineCode","value":"Integer","position":{"start":{"line":187,"column":84,"offset":4417},"end":{"line":187,"column":93,"offset":4426},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":187,"column":93,"offset":4426},"end":{"line":187,"column":94,"offset":4427},"indent":[]}}],"position":{"start":{"line":187,"column":1,"offset":4334},"end":{"line":187,"column":94,"offset":4427},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"Floating","position":{"start":{"line":189,"column":1,"offset":4429},"end":{"line":189,"column":11,"offset":4439},"indent":[]}},{"type":"text","value":" includes only floating point numbers, so ","position":{"start":{"line":189,"column":11,"offset":4439},"end":{"line":189,"column":53,"offset":4481},"indent":[]}},{"type":"inlineCode","value":"Float","position":{"start":{"line":189,"column":53,"offset":4481},"end":{"line":189,"column":60,"offset":4488},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":189,"column":60,"offset":4488},"end":{"line":189,"column":65,"offset":4493},"indent":[]}},{"type":"inlineCode","value":"Double","position":{"start":{"line":189,"column":65,"offset":4493},"end":{"line":189,"column":73,"offset":4501},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":189,"column":73,"offset":4501},"end":{"line":189,"column":74,"offset":4502},"indent":[]}}],"position":{"start":{"line":189,"column":1,"offset":4429},"end":{"line":189,"column":74,"offset":4502},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":192,"column":1,"offset":4505},"end":{"line":192,"column":31,"offset":4535},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":192,"column":31,"offset":4535}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"types-and-typeclasses\"\n    }}>{`Types and Typeclasses`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"http://learnyouahaskell.com/types-and-typeclasses#believe-the-type\"\n        }}>{`Learn You A Haskell`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"checking-types-on-ghci\"\n    }}>{`Checking types on ghci`}</h2>\n    <p>{`Use the `}<inlineCode parentName=\"p\">{`:t`}</inlineCode>{` command followed by a valid expression.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> :t 'a'\n'a' :: Char\nghci> :t True\nTrue :: Bool\nghci> :t \"HELLO!\"\n\"HELLO!\" :: [Char]\nghci> :t (True, 'a')\n(True, 'a') :: (Bool, Char)\nghci> :t 4 == 5\n4 == 5 :: Bool\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"function-types\"\n    }}>{`Function Types`}</h2>\n    <p>{`We can choose to give functions an explicit type definition. This is considered good practice except for short functions.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`removeNonUppercase :: [Char] -> [Char]\nremoveNonUppercase st = [ c | c <- st, c \\`elem\\` ['A'..'Z']]\n`}</code></pre>\n    <p>{`Here is an example for a function that takes three `}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{` args and adds them together.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`addThree :: Int -> Int -> Int -> Int\naddThree x y z = x + y + z\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"typeclasses\"\n    }}>{`Typeclasses`}</h2>\n    <p>{`A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that is supports and implements the behaviour the typeclass describes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> :t (==)\n(==) :: Eq a => a -> a -> Bool\nghci> 5 /= 5\nFalse\nghci> :t 5 /= 5\n5 /= 5 :: Bool\nghci> :t (>)\n(>) :: Ord a => a -> a -> Bool\n`}</code></pre>\n    <p>{`Typeclass `}<inlineCode parentName=\"p\">{`Ord`}</inlineCode>{` covers all comparing functions.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> \"Abrakadabra\" < \"Zebra\"\nTrue\nghci> \"Abrakadabra\" \\`compare\\` \"Zebra\"\nLT\nghci> 5 >= 2\nTrue\nghci> 5 \\`compare\\` 3\nGT\n`}</code></pre>\n    <p>{`Members of `}<inlineCode parentName=\"p\">{`Show`}</inlineCode>{` can be presented as strings. All types covered so far except for functions are a part of Show. The most used function that deals with the Show typeclass is show. It takes a value whose type is a member of Show and presents it to us as a string.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> show 3\n\"3\"\nghci> show 5.334\n\"5.334\"\nghci> show True\n\"True\"\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`Read`}</inlineCode>{` is sort of the opposite typeclass of Show. The read function takes a string and returns a type which is a member of Read.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> read \"True\" || False\nTrue\nghci> read \"8.2\" + 3.8\n12.0\nghci> read \"5\" - 2\n3\nghci> read \"[1,2,3,4]\" ++ [3]\n[1,2,3,4,3]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-annotations\"\n    }}>{`Type Annotations`}</h2>\n    <p>{`Type annotations are a way of explicitly saying what the type of an expression should be. We do that by adding :: at the end of the expression and then specifying a type. Observe:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> read \"5\" :: Int\n5\nghci> read \"5\" :: Float\n5.0\nghci> (read \"5\" :: Float) * 4\n20.0\nghci> read \"[1,2,3,4]\" :: [Int][1,2,3,4]\nghci> read \"(3, 'a')\" :: (Int, Char)\n(3, 'a')\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"enum-members\"\n    }}>{`Enum Members`}</h2>\n    <p><inlineCode parentName=\"p\">{`Enum`}</inlineCode>{` members are sequentially ordered types — they can be enumerated. The main advantage of the `}<inlineCode parentName=\"p\">{`Enum`}</inlineCode>{` typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the succ and pred functions. Types in this class: (), Bool, Char, Ordering, Int, Integer, Float and Double.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> ['a'..'e']\n\"abcde\"\nghci> [LT .. GT]\n[LT,EQ,GT]\nghci> [3 .. 5]\n[3,4,5]\nghci> succ 'B'\n'C'\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bounded\"\n    }}>{`Bounded`}</h2>\n    <p><inlineCode parentName=\"p\">{`Bounded`}</inlineCode>{` members have an upper and a lower bound.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> minBound :: Int\n-2147483648\nghci> maxBound :: Char\n'\\\\1114111'\nghci> maxBound :: Bool\nTrue\nghci> minBound :: Bool\nFalse\n`}</code></pre>\n    <p>{`minBound and maxBound are interesting because they have a type of (Bounded a) => a. In a sense they are polymorphic constants.`}</p>\n    <p>{`All tuples are also part of Bounded if the components are also in it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> maxBound :: (Bool, Int, Char)\n(True,2147483647,'\\\\1114111')\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"num\"\n    }}>{`Num`}</h2>\n    <p><inlineCode parentName=\"p\">{`Num`}</inlineCode>{` is a numeric typeclass. Its members have the property of being able to act like numbers. Let's examine the type of a number.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> :t 20\n20 :: (Num t) => t\n`}</code></pre>\n    <p>{`It appears that whole numbers are also polymorphic constants. They can act like any type that's a member of the Num typeclass.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> 20 :: Int\n20\nghci> 20 :: Integer\n20\nghci> 20 :: Float\n20.0\nghci> 20 :: Double\n20.0\n`}</code></pre>\n    <p>{`Those are types that are in the Num typeclass. If we examine the type of `}{`*`}{`, we'll see that it accepts all numbers.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`ghci> :t (*)\n(*) :: (Num a) => a -> a -> a\n`}</code></pre>\n    <p>{`It takes two numbers of the same type and returns a number of that type. That's why `}<inlineCode parentName=\"p\">{`(5 :: Int) * (6 :: Integer)`}</inlineCode>{` will result in a type error whereas `}<inlineCode parentName=\"p\">{`5 * (6 :: Integer)`}</inlineCode>{` will work just fine and produce an Integer because 5 can act like an Integer or an Int.`}</p>\n    <p>{`To join Num, a type must already be friends with Show and Eq.`}</p>\n    <p><inlineCode parentName=\"p\">{`Integral`}</inlineCode>{` includes only integral (whole) numbers. In this typeclass are `}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Integer`}</inlineCode>{`.`}</p>\n    <p><inlineCode parentName=\"p\">{`Floating`}</inlineCode>{` includes only floating point numbers, so `}<inlineCode parentName=\"p\">{`Float`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Double`}</inlineCode>{`.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}