{"expireTime":9007200849425488000,"key":"gatsby-plugin-mdx-entire-payload-2587264f595b2b6defc35c3a0186e1f1-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"TypeScript 3 Fundamentals v2","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":31,"offset":197},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":31,"offset":197},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":10,"column":4,"offset":202},"end":{"line":10,"column":13,"offset":211},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":199},"end":{"line":10,"column":13,"offset":211},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"vhttps://frontendmasters.com/courses/typescript-v2","children":[{"type":"text","value":"TS Resources","position":{"start":{"line":12,"column":5,"offset":217},"end":{"line":12,"column":17,"offset":229},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":216},"end":{"line":12,"column":70,"offset":282},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":216},"end":{"line":12,"column":70,"offset":282},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":213},"end":{"line":12,"column":70,"offset":282},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://github.com/mike-works/typescript-fundamentals/","children":[{"type":"text","value":"GitHub Resource","position":{"start":{"line":13,"column":5,"offset":287},"end":{"line":13,"column":20,"offset":302},"indent":[]}}],"position":{"start":{"line":13,"column":4,"offset":286},"end":{"line":13,"column":77,"offset":359},"indent":[]}}],"position":{"start":{"line":13,"column":4,"offset":286},"end":{"line":13,"column":77,"offset":359},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":283},"end":{"line":13,"column":77,"offset":359},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":213},"end":{"line":13,"column":77,"offset":359},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Variables","position":{"start":{"line":15,"column":4,"offset":364},"end":{"line":15,"column":13,"offset":373},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":361},"end":{"line":15,"column":13,"offset":373},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// basic typing\nlet x: string = 'string';\nx = 42; // ERROR","position":{"start":{"line":17,"column":1,"offset":375},"end":{"line":21,"column":4,"offset":451},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Tuples","position":{"start":{"line":23,"column":4,"offset":456},"end":{"line":23,"column":10,"offset":462},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":453},"end":{"line":23,"column":10,"offset":462},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"let bb: [numer, string, string, number] = [\n  123,\n  'Fake Street',\n  'Nowhere, USA',\n  10110,\n];\n\nbb = [1, 2, 3]; // ERROR\nbb.push(1, 2); // no type safety error :(","position":{"start":{"line":25,"column":1,"offset":464},"end":{"line":35,"column":4,"offset":647},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Tuples will need the type specified at declaration, otherwise it could infer an array of the wrong type.","position":{"start":{"line":37,"column":3,"offset":651},"end":{"line":37,"column":107,"offset":755},"indent":[]}}],"position":{"start":{"line":37,"column":3,"offset":651},"end":{"line":37,"column":107,"offset":755},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":649},"end":{"line":37,"column":107,"offset":755},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Exhaustive Switches","position":{"start":{"line":39,"column":4,"offset":760},"end":{"line":39,"column":23,"offset":779},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":757},"end":{"line":39,"column":23,"offset":779},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"enum constants = {\n  mrf = \"mrf\"\n}\n\n// doesn't need a default\nconst getValue = (value: constants) => {\n  switch (value) {\n    case constants.mrf:\n      return 'value'\n  }\n}","position":{"start":{"line":41,"column":1,"offset":781},"end":{"line":53,"column":4,"offset":971},"indent":[1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Intersectional and Union Types","position":{"start":{"line":55,"column":4,"offset":976},"end":{"line":55,"column":34,"offset":1006},"indent":[]}}],"position":{"start":{"line":55,"column":1,"offset":973},"end":{"line":55,"column":34,"offset":1006},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"type A = {\n  a: number;\n};\n\ntype B = {\n  b: number;\n};\n\ntype IntersectionAB = A | B;\n// valid\nconst aObj: IntersectionAB = {\n  a: 32,\n};\n\nconst bObj: IntersectionAB = {\n  b: 32,\n};\n\n// invalid\nconst cObj: IntersectionAB = {\n  a: 32,\n  b: 32,\n};\n\ntype UnionAB = A | B;\n// invalid\nconst aObj: UnionAB = {\n  a: 32,\n};\n\nconst bObj: UnionAB = {\n  b: 32,\n};\n\n// valid\nconst cObj: UnionAB = {\n  a: 32,\n  b: 32,\n};","position":{"start":{"line":57,"column":1,"offset":1008},"end":{"line":97,"column":4,"offset":1432},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type Systems","position":{"start":{"line":99,"column":4,"offset":1437},"end":{"line":99,"column":16,"offset":1449},"indent":[]}}],"position":{"start":{"line":99,"column":1,"offset":1434},"end":{"line":99,"column":16,"offset":1449},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are two types:","position":{"start":{"line":101,"column":1,"offset":1451},"end":{"line":101,"column":21,"offset":1471},"indent":[]}}],"position":{"start":{"line":101,"column":1,"offset":1451},"end":{"line":101,"column":21,"offset":1471},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Nominal Type Systems (Java): is x an instance of a class/type named ","position":{"start":{"line":103,"column":4,"offset":1476},"end":{"line":103,"column":72,"offset":1544},"indent":[]}},{"type":"inlineCode","value":"HTMLInputElement","position":{"start":{"line":103,"column":72,"offset":1544},"end":{"line":103,"column":90,"offset":1562},"indent":[]}},{"type":"text","value":"?","position":{"start":{"line":103,"column":90,"offset":1562},"end":{"line":103,"column":91,"offset":1563},"indent":[]}}],"position":{"start":{"line":103,"column":4,"offset":1476},"end":{"line":103,"column":91,"offset":1563},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":1473},"end":{"line":103,"column":91,"offset":1563},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Structural Type Systems (TS): cares only about shape.","position":{"start":{"line":104,"column":4,"offset":1567},"end":{"line":104,"column":57,"offset":1620},"indent":[]}}],"position":{"start":{"line":104,"column":4,"offset":1567},"end":{"line":104,"column":57,"offset":1620},"indent":[]}}],"position":{"start":{"line":104,"column":1,"offset":1564},"end":{"line":104,"column":57,"offset":1620},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":1473},"end":{"line":104,"column":57,"offset":1620},"indent":[1]}},{"type":"code","lang":"typescript","meta":null,"value":"function validateInputField(input: HTMLInputElement) {\n  /* ... */\n}\n\nvalidateInputField(x);","position":{"start":{"line":106,"column":1,"offset":1622},"end":{"line":112,"column":4,"offset":1732},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Specificity","position":{"start":{"line":114,"column":4,"offset":1737},"end":{"line":114,"column":15,"offset":1748},"indent":[]}}],"position":{"start":{"line":114,"column":1,"offset":1734},"end":{"line":114,"column":15,"offset":1748},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"TypeScript uses \"wider vs narrower\" to describle specificity. That means that we go from wide ","position":{"start":{"line":116,"column":1,"offset":1750},"end":{"line":116,"column":95,"offset":1844},"indent":[]}},{"type":"inlineCode","value":"any","position":{"start":{"line":116,"column":95,"offset":1844},"end":{"line":116,"column":100,"offset":1849},"indent":[]}},{"type":"text","value":" down to nothing ","position":{"start":{"line":116,"column":100,"offset":1849},"end":{"line":116,"column":117,"offset":1866},"indent":[]}},{"type":"inlineCode","value":"never","position":{"start":{"line":116,"column":117,"offset":1866},"end":{"line":116,"column":124,"offset":1873},"indent":[]}},{"type":"text","value":" with everything else in between.","position":{"start":{"line":116,"column":124,"offset":1873},"end":{"line":116,"column":157,"offset":1906},"indent":[]}}],"position":{"start":{"line":116,"column":1,"offset":1750},"end":{"line":116,"column":157,"offset":1906},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Type Aliases & extends","position":{"start":{"line":118,"column":4,"offset":1911},"end":{"line":118,"column":26,"offset":1933},"indent":[]}}],"position":{"start":{"line":118,"column":1,"offset":1908},"end":{"line":118,"column":26,"offset":1933},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Allow us to give a type a name.","position":{"start":{"line":120,"column":3,"offset":1937},"end":{"line":120,"column":34,"offset":1968},"indent":[]}}],"position":{"start":{"line":120,"column":3,"offset":1937},"end":{"line":120,"column":34,"offset":1968},"indent":[]}}],"position":{"start":{"line":120,"column":1,"offset":1935},"end":{"line":120,"column":34,"offset":1968},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Interfaces extend from interfaces, classes extend from classes.","position":{"start":{"line":122,"column":3,"offset":1972},"end":{"line":122,"column":66,"offset":2035},"indent":[]}}],"position":{"start":{"line":122,"column":3,"offset":1972},"end":{"line":122,"column":66,"offset":2035},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":1970},"end":{"line":122,"column":66,"offset":2035},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Interfaces cannot handle primitive types. JavaScript object and subobjects only (things with prototypes).","position":{"start":{"line":123,"column":3,"offset":2038},"end":{"line":123,"column":108,"offset":2143},"indent":[]}}],"position":{"start":{"line":123,"column":3,"offset":2038},"end":{"line":123,"column":108,"offset":2143},"indent":[]}}],"position":{"start":{"line":123,"column":1,"offset":2036},"end":{"line":123,"column":108,"offset":2143},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Main difference is you cannot implement/extend a union type.","position":{"start":{"line":124,"column":3,"offset":2146},"end":{"line":124,"column":63,"offset":2206},"indent":[]}}],"position":{"start":{"line":124,"column":3,"offset":2146},"end":{"line":124,"column":63,"offset":2206},"indent":[]}}],"position":{"start":{"line":124,"column":1,"offset":2144},"end":{"line":124,"column":63,"offset":2206},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":1970},"end":{"line":124,"column":63,"offset":2206},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generics","position":{"start":{"line":126,"column":4,"offset":2211},"end":{"line":126,"column":12,"offset":2219},"indent":[]}}],"position":{"start":{"line":126,"column":1,"offset":2208},"end":{"line":126,"column":12,"offset":2219},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Generics parameterize types in the same way functions parameterize valus.","position":{"start":{"line":128,"column":3,"offset":2223},"end":{"line":128,"column":76,"offset":2296},"indent":[]}}],"position":{"start":{"line":128,"column":3,"offset":2223},"end":{"line":128,"column":76,"offset":2296},"indent":[]}}],"position":{"start":{"line":128,"column":1,"offset":2221},"end":{"line":128,"column":76,"offset":2296},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// example of the parameterized function\nfunction wrappedValue(x) {\n  return {\n    value: x,\n  };\n}\n\n// example now as generic\n// the common convention is T\ninterface wrappedValue<X> {\n  value: X;\n}\n\nlet val: WrappedValue<string> = { value: '' };\nval.value; // expects string and shows that on the tooltip","position":{"start":{"line":130,"column":1,"offset":2298},"end":{"line":146,"column":4,"offset":2621},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Type parameters","position":{"start":{"line":148,"column":5,"offset":2627},"end":{"line":148,"column":20,"offset":2642},"indent":[]}}],"position":{"start":{"line":148,"column":1,"offset":2623},"end":{"line":148,"column":20,"offset":2642},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// this sets the fallback to any\ninterface wrappedValue<X = any> {\n  value: X;\n}","position":{"start":{"line":150,"column":1,"offset":2644},"end":{"line":155,"column":4,"offset":2742},"indent":[1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"TypeScript can also infer type ahead in the tooltip. Very handy use.","position":{"start":{"line":157,"column":3,"offset":2746},"end":{"line":157,"column":71,"offset":2814},"indent":[]}}],"position":{"start":{"line":157,"column":3,"offset":2746},"end":{"line":157,"column":71,"offset":2814},"indent":[]}}],"position":{"start":{"line":157,"column":1,"offset":2744},"end":{"line":157,"column":71,"offset":2814},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Constraints and scope","position":{"start":{"line":159,"column":5,"offset":2820},"end":{"line":159,"column":26,"offset":2841},"indent":[]}}],"position":{"start":{"line":159,"column":1,"offset":2816},"end":{"line":159,"column":26,"offset":2841},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Extending a generc means setting a minimum constraint that a generic must meet.","position":{"start":{"line":161,"column":3,"offset":2845},"end":{"line":161,"column":82,"offset":2924},"indent":[]}}],"position":{"start":{"line":161,"column":3,"offset":2845},"end":{"line":161,"column":82,"offset":2924},"indent":[]}}],"position":{"start":{"line":161,"column":1,"offset":2843},"end":{"line":161,"column":82,"offset":2924},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// an example of ensure that T has an id\nfunction arrayToDict<T extends { id: string }>(array: T[]): { [k: string]: T } {\n  const out: {\n    [k: string]: T;\n  } = {};\n  array.forEach(val => {\n    out[val.id] = val;\n  });\n  return out;\n}","position":{"start":{"line":163,"column":1,"offset":2926},"end":{"line":174,"column":4,"offset":3180},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Type parameters are also associated with scope:","position":{"start":{"line":176,"column":1,"offset":3182},"end":{"line":176,"column":48,"offset":3229},"indent":[]}}],"position":{"start":{"line":176,"column":1,"offset":3182},"end":{"line":176,"column":48,"offset":3229},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function startTuple<T>(a: T) {\n  return function finishTuple<U>(b: U) {\n    return [a, b] as [T, U];\n  };\n}","position":{"start":{"line":178,"column":1,"offset":3231},"end":{"line":184,"column":4,"offset":3356},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Generics in use with interfaces","position":{"start":{"line":186,"column":5,"offset":3362},"end":{"line":186,"column":36,"offset":3393},"indent":[]}}],"position":{"start":{"line":186,"column":1,"offset":3358},"end":{"line":186,"column":36,"offset":3393},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface Shape {\n  sides: number;\n}\n\ninterface Square extends Shape {\n  width: number;\n}\n\ninterface Circle extends Shape {\n  radius: number;\n}\n\n// what makes it worth while is it means any interface\n// that extends Shape\nfunction drawShape<S extends Shape>(shapes: S[]): S[] {\n  return; // fill in here\n}\n\nconst test1: Shape = //...\nconst test2: Circle = //...\ndrawShape(test1) // valid\ndrawShape(test2) // valid","position":{"start":{"line":188,"column":1,"offset":3395},"end":{"line":211,"column":4,"offset":3826},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Use cases for Generics","position":{"start":{"line":213,"column":5,"offset":3832},"end":{"line":213,"column":27,"offset":3854},"indent":[]}}],"position":{"start":{"line":213,"column":1,"offset":3828},"end":{"line":213,"column":27,"offset":3854},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Generics are necessary when we want to describe a relationship between two or more types (i.e., a function argument and return type).","position":{"start":{"line":215,"column":4,"offset":3859},"end":{"line":215,"column":137,"offset":3992},"indent":[]}}],"position":{"start":{"line":215,"column":4,"offset":3859},"end":{"line":215,"column":137,"offset":3992},"indent":[]}}],"position":{"start":{"line":215,"column":1,"offset":3856},"end":{"line":215,"column":137,"offset":3992},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Aside from interfaces and type aliases, if a type parameter is used only once, it can probably be eliminated.","position":{"start":{"line":216,"column":4,"offset":3996},"end":{"line":216,"column":113,"offset":4105},"indent":[]}}],"position":{"start":{"line":216,"column":4,"offset":3996},"end":{"line":216,"column":113,"offset":4105},"indent":[]}}],"position":{"start":{"line":216,"column":1,"offset":3993},"end":{"line":216,"column":113,"offset":4105},"indent":[]}}],"position":{"start":{"line":215,"column":1,"offset":3856},"end":{"line":216,"column":113,"offset":4105},"indent":[1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Relating this ie ","position":{"start":{"line":218,"column":3,"offset":4109},"end":{"line":218,"column":20,"offset":4126},"indent":[]}},{"type":"inlineCode","value":"I take T and will give you back a Dictionary of type T","position":{"start":{"line":218,"column":20,"offset":4126},"end":{"line":218,"column":76,"offset":4182},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":218,"column":76,"offset":4182},"end":{"line":218,"column":77,"offset":4183},"indent":[]}}],"position":{"start":{"line":218,"column":3,"offset":4109},"end":{"line":218,"column":77,"offset":4183},"indent":[]}}],"position":{"start":{"line":218,"column":1,"offset":4107},"end":{"line":218,"column":77,"offset":4183},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface Shape {\n  draw();\n}\ninterface Circle extends Shape {\n  radius: number;\n}\n\nfunction drawShapes1<S extends Shape>(shapes: S[]) {\n  shapes.forEach(s => s.draw());\n}\n\n// this is simpler. Above type param is not necessary\nfunction drawShapes2(shapes: Shape[]) {\n  shapes.forEach(s => s.draw());\n}","position":{"start":{"line":220,"column":1,"offset":4185},"end":{"line":236,"column":4,"offset":4504},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Interesting tidbit","position":{"start":{"line":238,"column":5,"offset":4510},"end":{"line":238,"column":23,"offset":4528},"indent":[]}}],"position":{"start":{"line":238,"column":1,"offset":4506},"end":{"line":238,"column":23,"offset":4528},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The following is both acceptable as far as TS is concerned:","position":{"start":{"line":240,"column":1,"offset":4530},"end":{"line":240,"column":60,"offset":4589},"indent":[]}}],"position":{"start":{"line":240,"column":1,"offset":4530},"end":{"line":240,"column":60,"offset":4589},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"// using interface\ninterface Shape {\n  sides: number;\n}\n\ninterface Circle extends Shape {\n  radius: number;\n}\n\ninterface Cube extends Shape {\n  threeD: boolean;\n}\n\nfunction createCircle<T extends Shape>(shape: T): T {\n  shape.sides = 1;\n  return shape;\n}\n\n// using types\ntype Shape2 = {\n  sides: number;\n};\n\ntype Circle2 = Shape2 & {\n  radius: number;\n};\n\ntype Cube2 = Shape2 & {\n  threeD: boolean;\n};\n\nfunction createCircle2<T extends Shape2>(shape: T): T {\n  shape.sides = 1;\n  return shape;\n}","position":{"start":{"line":242,"column":1,"offset":4591},"end":{"line":278,"column":4,"offset":5104},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Dictionary exercise","position":{"start":{"line":280,"column":5,"offset":5110},"end":{"line":280,"column":24,"offset":5129},"indent":[]}}],"position":{"start":{"line":280,"column":1,"offset":5106},"end":{"line":280,"column":24,"offset":5129},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"An example of creating a dictionary with the same type as the value.","position":{"start":{"line":282,"column":1,"offset":5131},"end":{"line":282,"column":69,"offset":5199},"indent":[]}}],"position":{"start":{"line":282,"column":1,"offset":5131},"end":{"line":282,"column":69,"offset":5199},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"export type Dict<T> = {\n  [K: string]: T | undefined;\n};\n\n// transforming from and then to\nexport function mapDict<T, S>(dict: Dict<T>, fn(arg: T, idx: number) => S): Dict<S> {\n  const out: Dict<S> = {}\n  Object.keys(dict).forEach((dKey, idx) => {\n    const thisItem = dict[dKey]\n    if (typeof thisItem !== undefined) {\n      out[dKey] = fn(thisIdem, idx);\n    }\n  })\n}","position":{"start":{"line":284,"column":1,"offset":5201},"end":{"line":299,"column":4,"offset":5589},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Top and Bottom Types","position":{"start":{"line":301,"column":4,"offset":5594},"end":{"line":301,"column":24,"offset":5614},"indent":[]}}],"position":{"start":{"line":301,"column":1,"offset":5591},"end":{"line":301,"column":24,"offset":5614},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Two top types:","position":{"start":{"line":303,"column":1,"offset":5616},"end":{"line":303,"column":15,"offset":5630},"indent":[]}}],"position":{"start":{"line":303,"column":1,"offset":5616},"end":{"line":303,"column":15,"offset":5630},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"any","position":{"start":{"line":305,"column":4,"offset":5635},"end":{"line":305,"column":9,"offset":5640},"indent":[]}}],"position":{"start":{"line":305,"column":4,"offset":5635},"end":{"line":305,"column":9,"offset":5640},"indent":[]}}],"position":{"start":{"line":305,"column":1,"offset":5632},"end":{"line":305,"column":9,"offset":5640},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"unknown","position":{"start":{"line":306,"column":4,"offset":5644},"end":{"line":306,"column":13,"offset":5653},"indent":[]}},{"type":"text","value":" - can receive any value","position":{"start":{"line":306,"column":13,"offset":5653},"end":{"line":306,"column":37,"offset":5677},"indent":[]}}],"position":{"start":{"line":306,"column":4,"offset":5644},"end":{"line":306,"column":37,"offset":5677},"indent":[]}}],"position":{"start":{"line":306,"column":1,"offset":5641},"end":{"line":306,"column":37,"offset":5677},"indent":[]}}],"position":{"start":{"line":305,"column":1,"offset":5632},"end":{"line":306,"column":37,"offset":5677},"indent":[1]}},{"type":"code","lang":"typescript","meta":null,"value":"let myAny: any = 32;\nlet myUnknown: unknown = 'hello, unknown';\n\nmyAny.foo.bar.baz; // works okay\nmyUnknown.foo; // error thrown","position":{"start":{"line":308,"column":1,"offset":5679},"end":{"line":314,"column":4,"offset":5825},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"When to use any?","position":{"start":{"line":316,"column":1,"offset":5827},"end":{"line":316,"column":17,"offset":5843},"indent":[]}}],"position":{"start":{"line":316,"column":1,"offset":5827},"end":{"line":316,"column":17,"offset":5843},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"When you want to maintan flexibility.","position":{"start":{"line":318,"column":3,"offset":5847},"end":{"line":318,"column":40,"offset":5884},"indent":[]}}],"position":{"start":{"line":318,"column":3,"offset":5847},"end":{"line":318,"column":40,"offset":5884},"indent":[]}}],"position":{"start":{"line":318,"column":1,"offset":5845},"end":{"line":318,"column":40,"offset":5884},"indent":[]}}],"position":{"start":{"line":318,"column":1,"offset":5845},"end":{"line":318,"column":40,"offset":5884},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When to use unknown?","position":{"start":{"line":320,"column":1,"offset":5886},"end":{"line":320,"column":21,"offset":5906},"indent":[]}}],"position":{"start":{"line":320,"column":1,"offset":5886},"end":{"line":320,"column":21,"offset":5906},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Good for \"private\" values.","position":{"start":{"line":322,"column":3,"offset":5910},"end":{"line":322,"column":29,"offset":5936},"indent":[]}}],"position":{"start":{"line":322,"column":3,"offset":5910},"end":{"line":322,"column":29,"offset":5936},"indent":[]}}],"position":{"start":{"line":322,"column":1,"offset":5908},"end":{"line":322,"column":29,"offset":5936},"indent":[]}}],"position":{"start":{"line":322,"column":1,"offset":5908},"end":{"line":322,"column":29,"offset":5936},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"if (typeof myUnknown === 'string') {\n  myUnknown.split(',');\n}\nif (myUnknown instanceof Promise) {\n  myUnknown.then(x => console.log(x));\n}\n\n// note on return type\ntype HasEmail = {\n  name: string;\n  email: string;\n};\nfunction isHasEmail(x: any): x is HasEmail {\n  return typeof x.name === 'string' && x.email === 'string';\n}\n\nif (isHasEmail(myKnown)) {\n  // do things\n}\n\n// most common guard\nfunction isDefined<T>(arg: T | undefined): arg is T {\n  return typeof arg !== 'undefined';\n}\n\nconst list = ['a', 'b', 'c', undefined];\nconst filtered = list.filter(isDefined);","position":{"start":{"line":324,"column":1,"offset":5938},"end":{"line":352,"column":4,"offset":6524},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Unknowns and Branded Types","position":{"start":{"line":354,"column":4,"offset":6529},"end":{"line":354,"column":30,"offset":6555},"indent":[]}}],"position":{"start":{"line":354,"column":1,"offset":6526},"end":{"line":354,"column":30,"offset":6555},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Branding and unbranding helps with unsafe issues. We cast to unknown and brand that enables us to cast without type errors.","position":{"start":{"line":356,"column":1,"offset":6557},"end":{"line":356,"column":124,"offset":6680},"indent":[]}}],"position":{"start":{"line":356,"column":1,"offset":6557},"end":{"line":356,"column":124,"offset":6680},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Withthe differing types, we can still ensure that things do not accidentally get mismatched when branding or unbranding.","position":{"start":{"line":358,"column":1,"offset":6682},"end":{"line":358,"column":121,"offset":6802},"indent":[]}}],"position":{"start":{"line":358,"column":1,"offset":6682},"end":{"line":358,"column":121,"offset":6802},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"This vs ","position":{"start":{"line":360,"column":3,"offset":6806},"end":{"line":360,"column":11,"offset":6814},"indent":[]}},{"type":"inlineCode","value":"private","position":{"start":{"line":360,"column":11,"offset":6814},"end":{"line":360,"column":20,"offset":6823},"indent":[]}},{"type":"text","value":"? Private can only be used in classes.","position":{"start":{"line":360,"column":20,"offset":6823},"end":{"line":360,"column":58,"offset":6861},"indent":[]}}],"position":{"start":{"line":360,"column":3,"offset":6806},"end":{"line":360,"column":58,"offset":6861},"indent":[]}}],"position":{"start":{"line":360,"column":1,"offset":6804},"end":{"line":360,"column":58,"offset":6861},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This is useful for library authors who want to keep things away from other users to change up.","position":{"start":{"line":362,"column":1,"offset":6863},"end":{"line":362,"column":95,"offset":6957},"indent":[]}}],"position":{"start":{"line":362,"column":1,"offset":6863},"end":{"line":362,"column":95,"offset":6957},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"interface BrandedA {\n  __this_is_branded_with_a: 'a';\n}\n\nfunction brandA(value: string): BrandedA {\n  return (value as unknown) as BrandedA;\n}\n\nfunction unbrandA(value: BrandedA): string {\n  return (value as unknown) as string;\n}\n\ninterface BrandedB {\n  __this_is_branded_with_b: 'b';\n}\n\nfunction brandB(value: { abc: string }): BrandedB {\n  return (value as unknown) as BrandedB;\n}\n\nfunction unbrandB(value: BrandedB): { abc: string } {\n  return (value as unknown) as { abc: string };\n}\n\nlet secretA = brandA('Secret value');\nlet secretB = brandA({ abc: 'Another secret value' });\n\nsecretA = secretB; // error: can't mix up\nunbrandB(secretA); // cannot happen\nunbrandA(secretB); // cannot happen","position":{"start":{"line":364,"column":1,"offset":6959},"end":{"line":395,"column":4,"offset":7673},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Bottom Types","position":{"start":{"line":397,"column":4,"offset":7678},"end":{"line":397,"column":16,"offset":7690},"indent":[]}}],"position":{"start":{"line":397,"column":1,"offset":7675},"end":{"line":397,"column":16,"offset":7690},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"never: If you create ","position":{"start":{"line":399,"column":3,"offset":7694},"end":{"line":399,"column":24,"offset":7715},"indent":[]}},{"type":"inlineCode","value":"never","position":{"start":{"line":399,"column":24,"offset":7715},"end":{"line":399,"column":31,"offset":7722},"indent":[]}},{"type":"text","value":" type, you shouldn't be here.","position":{"start":{"line":399,"column":31,"offset":7722},"end":{"line":399,"column":60,"offset":7751},"indent":[]}}],"position":{"start":{"line":399,"column":3,"offset":7694},"end":{"line":399,"column":60,"offset":7751},"indent":[]}}],"position":{"start":{"line":399,"column":1,"offset":7692},"end":{"line":399,"column":60,"offset":7751},"indent":[]}}],"position":{"start":{"line":399,"column":1,"offset":7692},"end":{"line":399,"column":60,"offset":7751},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"let x = 'abc' as string | number;\n\nif (typeof x === 'string') {\n  x.split(', ');\n} else if (typeof x === 'number') {\n  x.toFixed(2);\n} else {\n  // x is a never here\n}","position":{"start":{"line":401,"column":1,"offset":7753},"end":{"line":411,"column":4,"offset":7937},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Here is an example creating an unreachable error:","position":{"start":{"line":413,"column":1,"offset":7939},"end":{"line":413,"column":50,"offset":7988},"indent":[]}}],"position":{"start":{"line":413,"column":1,"offset":7939},"end":{"line":413,"column":50,"offset":7988},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"class UnreachableError extends Error {\n  constructor(val: never, message: string) {\n    super(`TypeScript thought we could never end up here ${message}`);\n  }\n}\n\nlet x = 4 as string | number;\n\nif (typeof x === 'string') {\n  x.split(', ');\n} else if (typeof x === 'number') {\n  x.toFixed(2);\n} else {\n  // if this isn't here, hates JavaScript debugging\n  // x is a never here\n  throw new UnreachableError(x, 'x should be string or number');\n}\n\n// What happens if x changes to string | number | boolean?\n// It will throw a runtime error saying you need to handle the case.","position":{"start":{"line":415,"column":1,"offset":7990},"end":{"line":436,"column":4,"offset":8578},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"This error is used for a runtime error!","position":{"start":{"line":438,"column":3,"offset":8582},"end":{"line":438,"column":42,"offset":8621},"indent":[]}}],"position":{"start":{"line":438,"column":3,"offset":8582},"end":{"line":438,"column":42,"offset":8621},"indent":[]}}],"position":{"start":{"line":438,"column":1,"offset":8580},"end":{"line":438,"column":42,"offset":8621},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Advanced Types","position":{"start":{"line":440,"column":4,"offset":8626},"end":{"line":440,"column":18,"offset":8640},"indent":[]}}],"position":{"start":{"line":440,"column":1,"offset":8623},"end":{"line":440,"column":18,"offset":8640},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"keyof","position":{"start":{"line":442,"column":3,"offset":8644},"end":{"line":442,"column":10,"offset":8651},"indent":[]}},{"type":"text","value":" - gets the key","position":{"start":{"line":442,"column":10,"offset":8651},"end":{"line":442,"column":25,"offset":8666},"indent":[]}}],"position":{"start":{"line":442,"column":3,"offset":8644},"end":{"line":442,"column":25,"offset":8666},"indent":[]}}],"position":{"start":{"line":442,"column":1,"offset":8642},"end":{"line":442,"column":25,"offset":8666},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"typeof","position":{"start":{"line":443,"column":3,"offset":8669},"end":{"line":443,"column":11,"offset":8677},"indent":[]}},{"type":"text","value":" - gets the typeof an element","position":{"start":{"line":443,"column":11,"offset":8677},"end":{"line":443,"column":40,"offset":8706},"indent":[]}}],"position":{"start":{"line":443,"column":3,"offset":8669},"end":{"line":443,"column":40,"offset":8706},"indent":[]}}],"position":{"start":{"line":443,"column":1,"offset":8667},"end":{"line":443,"column":40,"offset":8706},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Conditional type that uses a ternary.","position":{"start":{"line":444,"column":3,"offset":8709},"end":{"line":444,"column":40,"offset":8746},"indent":[]}}],"position":{"start":{"line":444,"column":3,"offset":8709},"end":{"line":444,"column":40,"offset":8746},"indent":[]}}],"position":{"start":{"line":444,"column":1,"offset":8707},"end":{"line":444,"column":40,"offset":8746},"indent":[]}}],"position":{"start":{"line":442,"column":1,"offset":8642},"end":{"line":444,"column":40,"offset":8746},"indent":[1,1]}},{"type":"code","lang":"typescript","meta":null,"value":"// Conditional ternany\ntype EventualType<T> = T extends Promise<infer S>\n  ? S //extract the type the promise resolves to\n  : T; // otherwise just let T pass through;","position":{"start":{"line":446,"column":1,"offset":8748},"end":{"line":451,"column":4,"offset":8932},"indent":[1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Utility Types","position":{"start":{"line":453,"column":4,"offset":8937},"end":{"line":453,"column":17,"offset":8950},"indent":[]}}],"position":{"start":{"line":453,"column":1,"offset":8934},"end":{"line":453,"column":17,"offset":8950},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Partial: makes all optional","position":{"start":{"line":455,"column":3,"offset":8954},"end":{"line":455,"column":30,"offset":8981},"indent":[]}}],"position":{"start":{"line":455,"column":3,"offset":8954},"end":{"line":455,"column":30,"offset":8981},"indent":[]}}],"position":{"start":{"line":455,"column":1,"offset":8952},"end":{"line":455,"column":30,"offset":8981},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Pick: choose specific properties","position":{"start":{"line":456,"column":3,"offset":8984},"end":{"line":456,"column":35,"offset":9016},"indent":[]}}],"position":{"start":{"line":456,"column":3,"offset":8984},"end":{"line":456,"column":35,"offset":9016},"indent":[]}}],"position":{"start":{"line":456,"column":1,"offset":8982},"end":{"line":456,"column":35,"offset":9016},"indent":[]}}],"position":{"start":{"line":455,"column":1,"offset":8952},"end":{"line":456,"column":35,"offset":9016},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Declaration Merging","position":{"start":{"line":458,"column":4,"offset":9021},"end":{"line":458,"column":23,"offset":9040},"indent":[]}}],"position":{"start":{"line":458,"column":1,"offset":9018},"end":{"line":458,"column":23,"offset":9040},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"You can stack class, namespace and interface on top each other and all will be exported under the same value and be interpretable based on use.","position":{"start":{"line":460,"column":1,"offset":9042},"end":{"line":460,"column":144,"offset":9185},"indent":[]}}],"position":{"start":{"line":460,"column":1,"offset":9042},"end":{"line":460,"column":144,"offset":9185},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":463,"column":1,"offset":9188},"end":{"line":463,"column":31,"offset":9218},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":463,"column":31,"offset":9218}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"typescript-3-fundamentals-v2\"\n    }}>{`TypeScript 3 Fundamentals v2`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"vhttps://frontendmasters.com/courses/typescript-v2\"\n        }}>{`TS Resources`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/mike-works/typescript-fundamentals/\"\n        }}>{`GitHub Resource`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"variables\"\n    }}>{`Variables`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// basic typing\nlet x: string = 'string';\nx = 42; // ERROR\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuples\"\n    }}>{`Tuples`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`let bb: [numer, string, string, number] = [\n  123,\n  'Fake Street',\n  'Nowhere, USA',\n  10110,\n];\n\nbb = [1, 2, 3]; // ERROR\nbb.push(1, 2); // no type safety error :(\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Tuples will need the type specified at declaration, otherwise it could infer an array of the wrong type.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"exhaustive-switches\"\n    }}>{`Exhaustive Switches`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`enum constants = {\n  mrf = \"mrf\"\n}\n\n// doesn't need a default\nconst getValue = (value: constants) => {\n  switch (value) {\n    case constants.mrf:\n      return 'value'\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"intersectional-and-union-types\"\n    }}>{`Intersectional and Union Types`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type A = {\n  a: number;\n};\n\ntype B = {\n  b: number;\n};\n\ntype IntersectionAB = A | B;\n// valid\nconst aObj: IntersectionAB = {\n  a: 32,\n};\n\nconst bObj: IntersectionAB = {\n  b: 32,\n};\n\n// invalid\nconst cObj: IntersectionAB = {\n  a: 32,\n  b: 32,\n};\n\ntype UnionAB = A | B;\n// invalid\nconst aObj: UnionAB = {\n  a: 32,\n};\n\nconst bObj: UnionAB = {\n  b: 32,\n};\n\n// valid\nconst cObj: UnionAB = {\n  a: 32,\n  b: 32,\n};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-systems\"\n    }}>{`Type Systems`}</h2>\n    <p>{`There are two types:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Nominal Type Systems (Java): is x an instance of a class/type named `}<inlineCode parentName=\"li\">{`HTMLInputElement`}</inlineCode>{`?`}</li>\n      <li parentName=\"ol\">{`Structural Type Systems (TS): cares only about shape.`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function validateInputField(input: HTMLInputElement) {\n  /* ... */\n}\n\nvalidateInputField(x);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"specificity\"\n    }}>{`Specificity`}</h2>\n    <p>{`TypeScript uses \"wider vs narrower\" to describle specificity. That means that we go from wide `}<inlineCode parentName=\"p\">{`any`}</inlineCode>{` down to nothing `}<inlineCode parentName=\"p\">{`never`}</inlineCode>{` with everything else in between.`}</p>\n    <h2 {...{\n      \"id\": \"type-aliases--extends\"\n    }}>{`Type Aliases & extends`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Allow us to give a type a name.`}</p>\n    </blockquote>\n    <ul>\n      <li parentName=\"ul\">{`Interfaces extend from interfaces, classes extend from classes.`}</li>\n      <li parentName=\"ul\">{`Interfaces cannot handle primitive types. JavaScript object and subobjects only (things with prototypes).`}</li>\n      <li parentName=\"ul\">{`Main difference is you cannot implement/extend a union type.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"generics\"\n    }}>{`Generics`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Generics parameterize types in the same way functions parameterize valus.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// example of the parameterized function\nfunction wrappedValue(x) {\n  return {\n    value: x,\n  };\n}\n\n// example now as generic\n// the common convention is T\ninterface wrappedValue<X> {\n  value: X;\n}\n\nlet val: WrappedValue<string> = { value: '' };\nval.value; // expects string and shows that on the tooltip\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"type-parameters\"\n    }}>{`Type parameters`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// this sets the fallback to any\ninterface wrappedValue<X = any> {\n  value: X;\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`TypeScript can also infer type ahead in the tooltip. Very handy use.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"constraints-and-scope\"\n    }}>{`Constraints and scope`}</h3>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Extending a generc means setting a minimum constraint that a generic must meet.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// an example of ensure that T has an id\nfunction arrayToDict<T extends { id: string }>(array: T[]): { [k: string]: T } {\n  const out: {\n    [k: string]: T;\n  } = {};\n  array.forEach(val => {\n    out[val.id] = val;\n  });\n  return out;\n}\n`}</code></pre>\n    <p>{`Type parameters are also associated with scope:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function startTuple<T>(a: T) {\n  return function finishTuple<U>(b: U) {\n    return [a, b] as [T, U];\n  };\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"generics-in-use-with-interfaces\"\n    }}>{`Generics in use with interfaces`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Shape {\n  sides: number;\n}\n\ninterface Square extends Shape {\n  width: number;\n}\n\ninterface Circle extends Shape {\n  radius: number;\n}\n\n// what makes it worth while is it means any interface\n// that extends Shape\nfunction drawShape<S extends Shape>(shapes: S[]): S[] {\n  return; // fill in here\n}\n\nconst test1: Shape = //...\nconst test2: Circle = //...\ndrawShape(test1) // valid\ndrawShape(test2) // valid\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"use-cases-for-generics\"\n    }}>{`Use cases for Generics`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Generics are necessary when we want to describe a relationship between two or more types (i.e., a function argument and return type).`}</li>\n      <li parentName=\"ol\">{`Aside from interfaces and type aliases, if a type parameter is used only once, it can probably be eliminated.`}</li>\n    </ol>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Relating this ie `}<inlineCode parentName=\"p\">{`I take T and will give you back a Dictionary of type T`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Shape {\n  draw();\n}\ninterface Circle extends Shape {\n  radius: number;\n}\n\nfunction drawShapes1<S extends Shape>(shapes: S[]) {\n  shapes.forEach(s => s.draw());\n}\n\n// this is simpler. Above type param is not necessary\nfunction drawShapes2(shapes: Shape[]) {\n  shapes.forEach(s => s.draw());\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"interesting-tidbit\"\n    }}>{`Interesting tidbit`}</h3>\n    <p>{`The following is both acceptable as far as TS is concerned:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// using interface\ninterface Shape {\n  sides: number;\n}\n\ninterface Circle extends Shape {\n  radius: number;\n}\n\ninterface Cube extends Shape {\n  threeD: boolean;\n}\n\nfunction createCircle<T extends Shape>(shape: T): T {\n  shape.sides = 1;\n  return shape;\n}\n\n// using types\ntype Shape2 = {\n  sides: number;\n};\n\ntype Circle2 = Shape2 & {\n  radius: number;\n};\n\ntype Cube2 = Shape2 & {\n  threeD: boolean;\n};\n\nfunction createCircle2<T extends Shape2>(shape: T): T {\n  shape.sides = 1;\n  return shape;\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"dictionary-exercise\"\n    }}>{`Dictionary exercise`}</h3>\n    <p>{`An example of creating a dictionary with the same type as the value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`export type Dict<T> = {\n  [K: string]: T | undefined;\n};\n\n// transforming from and then to\nexport function mapDict<T, S>(dict: Dict<T>, fn(arg: T, idx: number) => S): Dict<S> {\n  const out: Dict<S> = {}\n  Object.keys(dict).forEach((dKey, idx) => {\n    const thisItem = dict[dKey]\n    if (typeof thisItem !== undefined) {\n      out[dKey] = fn(thisIdem, idx);\n    }\n  })\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"top-and-bottom-types\"\n    }}>{`Top and Bottom Types`}</h2>\n    <p>{`Two top types:`}</p>\n    <ol>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`any`}</inlineCode></li>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`unknown`}</inlineCode>{` - can receive any value`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let myAny: any = 32;\nlet myUnknown: unknown = 'hello, unknown';\n\nmyAny.foo.bar.baz; // works okay\nmyUnknown.foo; // error thrown\n`}</code></pre>\n    <p>{`When to use any?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`When you want to maintan flexibility.`}</li>\n    </ul>\n    <p>{`When to use unknown?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Good for \"private\" values.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`if (typeof myUnknown === 'string') {\n  myUnknown.split(',');\n}\nif (myUnknown instanceof Promise) {\n  myUnknown.then(x => console.log(x));\n}\n\n// note on return type\ntype HasEmail = {\n  name: string;\n  email: string;\n};\nfunction isHasEmail(x: any): x is HasEmail {\n  return typeof x.name === 'string' && x.email === 'string';\n}\n\nif (isHasEmail(myKnown)) {\n  // do things\n}\n\n// most common guard\nfunction isDefined<T>(arg: T | undefined): arg is T {\n  return typeof arg !== 'undefined';\n}\n\nconst list = ['a', 'b', 'c', undefined];\nconst filtered = list.filter(isDefined);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"unknowns-and-branded-types\"\n    }}>{`Unknowns and Branded Types`}</h2>\n    <p>{`Branding and unbranding helps with unsafe issues. We cast to unknown and brand that enables us to cast without type errors.`}</p>\n    <p>{`Withthe differing types, we can still ensure that things do not accidentally get mismatched when branding or unbranding.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This vs `}<inlineCode parentName=\"p\">{`private`}</inlineCode>{`? Private can only be used in classes.`}</p>\n    </blockquote>\n    <p>{`This is useful for library authors who want to keep things away from other users to change up.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface BrandedA {\n  __this_is_branded_with_a: 'a';\n}\n\nfunction brandA(value: string): BrandedA {\n  return (value as unknown) as BrandedA;\n}\n\nfunction unbrandA(value: BrandedA): string {\n  return (value as unknown) as string;\n}\n\ninterface BrandedB {\n  __this_is_branded_with_b: 'b';\n}\n\nfunction brandB(value: { abc: string }): BrandedB {\n  return (value as unknown) as BrandedB;\n}\n\nfunction unbrandB(value: BrandedB): { abc: string } {\n  return (value as unknown) as { abc: string };\n}\n\nlet secretA = brandA('Secret value');\nlet secretB = brandA({ abc: 'Another secret value' });\n\nsecretA = secretB; // error: can't mix up\nunbrandB(secretA); // cannot happen\nunbrandA(secretB); // cannot happen\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bottom-types\"\n    }}>{`Bottom Types`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`never: If you create `}<inlineCode parentName=\"li\">{`never`}</inlineCode>{` type, you shouldn't be here.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let x = 'abc' as string | number;\n\nif (typeof x === 'string') {\n  x.split(', ');\n} else if (typeof x === 'number') {\n  x.toFixed(2);\n} else {\n  // x is a never here\n}\n`}</code></pre>\n    <p>{`Here is an example creating an unreachable error:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class UnreachableError extends Error {\n  constructor(val: never, message: string) {\n    super(\\`TypeScript thought we could never end up here \\${message}\\`);\n  }\n}\n\nlet x = 4 as string | number;\n\nif (typeof x === 'string') {\n  x.split(', ');\n} else if (typeof x === 'number') {\n  x.toFixed(2);\n} else {\n  // if this isn't here, hates JavaScript debugging\n  // x is a never here\n  throw new UnreachableError(x, 'x should be string or number');\n}\n\n// What happens if x changes to string | number | boolean?\n// It will throw a runtime error saying you need to handle the case.\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`This error is used for a runtime error!`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"advanced-types\"\n    }}>{`Advanced Types`}</h2>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`keyof`}</inlineCode>{` - gets the key`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`typeof`}</inlineCode>{` - gets the typeof an element`}</li>\n      <li parentName=\"ul\">{`Conditional type that uses a ternary.`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Conditional ternany\ntype EventualType<T> = T extends Promise<infer S>\n  ? S //extract the type the promise resolves to\n  : T; // otherwise just let T pass through;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"utility-types\"\n    }}>{`Utility Types`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Partial: makes all optional`}</li>\n      <li parentName=\"ul\">{`Pick: choose specific properties`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"declaration-merging\"\n    }}>{`Declaration Merging`}</h2>\n    <p>{`You can stack class, namespace and interface on top each other and all will be exported under the same value and be interpretable based on use.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}