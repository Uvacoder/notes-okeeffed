{"expireTime":9007200852878377000,"key":"gatsby-plugin-mdx-entire-payload-b8c9d130880931153bebf0826d7e20d0-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Creating Your Own Language","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":29,"offset":195},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":29,"offset":195},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":10,"column":4,"offset":200},"end":{"line":10,"column":13,"offset":209},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":197},"end":{"line":10,"column":13,"offset":209},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://github.com/stevekinney/dropbear/","children":[{"type":"text","value":"Dropbear GitHub language","position":{"start":{"line":12,"column":5,"offset":215},"end":{"line":12,"column":29,"offset":239},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":214},"end":{"line":12,"column":72,"offset":282},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":214},"end":{"line":12,"column":72,"offset":282},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":211},"end":{"line":12,"column":72,"offset":282},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"http://static.frontendmasters.com/resources/2019-05-31-build-your-own-programming-language/programming-language.pdf","children":[{"type":"text","value":"Slides","position":{"start":{"line":13,"column":5,"offset":287},"end":{"line":13,"column":11,"offset":293},"indent":[]}}],"position":{"start":{"line":13,"column":4,"offset":286},"end":{"line":13,"column":129,"offset":411},"indent":[]}}],"position":{"start":{"line":13,"column":4,"offset":286},"end":{"line":13,"column":129,"offset":411},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":283},"end":{"line":13,"column":129,"offset":411},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":211},"end":{"line":13,"column":129,"offset":411},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Why your own language?","position":{"start":{"line":15,"column":4,"offset":416},"end":{"line":15,"column":26,"offset":438},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":413},"end":{"line":15,"column":26,"offset":438},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are elements that are super practical for production code.","position":{"start":{"line":17,"column":1,"offset":440},"end":{"line":17,"column":65,"offset":504},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":440},"end":{"line":17,"column":65,"offset":504},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Use Cases","position":{"start":{"line":19,"column":5,"offset":510},"end":{"line":19,"column":14,"offset":519},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":506},"end":{"line":19,"column":14,"offset":519},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Domain-Specific Languages: Terraform, Gemfiles","position":{"start":{"line":21,"column":4,"offset":524},"end":{"line":21,"column":50,"offset":570},"indent":[]}}],"position":{"start":{"line":21,"column":4,"offset":524},"end":{"line":21,"column":50,"offset":570},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":521},"end":{"line":21,"column":50,"offset":570},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Templating languages: Handlebars, Pug","position":{"start":{"line":22,"column":4,"offset":574},"end":{"line":22,"column":41,"offset":611},"indent":[]}}],"position":{"start":{"line":22,"column":4,"offset":574},"end":{"line":22,"column":41,"offset":611},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":571},"end":{"line":22,"column":41,"offset":611},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":521},"end":{"line":22,"column":41,"offset":611},"indent":[1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Usecases at SendGrid","position":{"start":{"line":24,"column":5,"offset":617},"end":{"line":24,"column":25,"offset":637},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":613},"end":{"line":24,"column":25,"offset":637},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Drag + Drop editor takes HTML, parses it into an abstract syntax tree (AST) and manipulates it before serializing it back into HTML.","position":{"start":{"line":26,"column":3,"offset":641},"end":{"line":26,"column":135,"offset":773},"indent":[]}}],"position":{"start":{"line":26,"column":3,"offset":641},"end":{"line":26,"column":135,"offset":773},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":639},"end":{"line":26,"column":135,"offset":773},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Using it for own bespoke templating language for dynamic email templates.","position":{"start":{"line":27,"column":3,"offset":776},"end":{"line":27,"column":76,"offset":849},"indent":[]}}],"position":{"start":{"line":27,"column":3,"offset":776},"end":{"line":27,"column":76,"offset":849},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":774},"end":{"line":27,"column":76,"offset":849},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Sync position in side-by-side editor by breaking HTML into an AST and rewriting the elements with information about their position in the text editor.","position":{"start":{"line":28,"column":3,"offset":852},"end":{"line":28,"column":153,"offset":1002},"indent":[]}}],"position":{"start":{"line":28,"column":3,"offset":852},"end":{"line":28,"column":153,"offset":1002},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":850},"end":{"line":28,"column":153,"offset":1002},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":639},"end":{"line":28,"column":153,"offset":1002},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"What is a compiler?","position":{"start":{"line":30,"column":4,"offset":1007},"end":{"line":30,"column":23,"offset":1026},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1004},"end":{"line":30,"column":23,"offset":1026},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Something that turns a higher-level language into a lower-level langauge.","position":{"start":{"line":32,"column":3,"offset":1030},"end":{"line":32,"column":76,"offset":1103},"indent":[]}}],"position":{"start":{"line":32,"column":3,"offset":1030},"end":{"line":32,"column":76,"offset":1103},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1028},"end":{"line":32,"column":76,"offset":1103},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this particular example, we will follow the course that builds the language ","position":{"start":{"line":34,"column":1,"offset":1105},"end":{"line":34,"column":80,"offset":1184},"indent":[]}},{"type":"inlineCode","value":"Dropbear","position":{"start":{"line":34,"column":80,"offset":1184},"end":{"line":34,"column":90,"offset":1194},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":34,"column":90,"offset":1194},"end":{"line":34,"column":91,"offset":1195},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":1105},"end":{"line":34,"column":91,"offset":1195},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Lisp-like language","position":{"start":{"line":36,"column":3,"offset":1199},"end":{"line":36,"column":21,"offset":1217},"indent":[]}}],"position":{"start":{"line":36,"column":3,"offset":1199},"end":{"line":36,"column":21,"offset":1217},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":1197},"end":{"line":36,"column":21,"offset":1217},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Leverage existing JavaScript run-time","position":{"start":{"line":37,"column":3,"offset":1220},"end":{"line":37,"column":40,"offset":1257},"indent":[]}}],"position":{"start":{"line":37,"column":3,"offset":1220},"end":{"line":37,"column":40,"offset":1257},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":1218},"end":{"line":37,"column":40,"offset":1257},"indent":[]}}],"position":{"start":{"line":36,"column":1,"offset":1197},"end":{"line":37,"column":40,"offset":1257},"indent":[1]}},{"type":"code","lang":"s","meta":null,"value":"(add 1 2 (subtract 6 3))","position":{"start":{"line":39,"column":1,"offset":1259},"end":{"line":41,"column":4,"offset":1292},"indent":[1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Source code is meant to be human-readable.","position":{"start":{"line":43,"column":3,"offset":1296},"end":{"line":43,"column":45,"offset":1338},"indent":[]}}],"position":{"start":{"line":43,"column":3,"offset":1296},"end":{"line":43,"column":45,"offset":1338},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":1294},"end":{"line":43,"column":45,"offset":1338},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"The beauty of Scheme is that the full language only needs\n5 keywords and 8 syntactic forms. In comparison, Python\nhas 33 keywords and 110 syntactic forms, and Java has 50\nkeywords and 133 syntactic forms. — Peter Norvig.","position":{"start":{"line":45,"column":3,"offset":1342},"end":{"line":48,"column":52,"offset":1568},"indent":[3,3,3]}}],"position":{"start":{"line":45,"column":3,"offset":1342},"end":{"line":48,"column":52,"offset":1568},"indent":[3,3,3]}}],"position":{"start":{"line":45,"column":1,"offset":1340},"end":{"line":48,"column":52,"offset":1568},"indent":[1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Inspiration Resources","position":{"start":{"line":50,"column":5,"offset":1574},"end":{"line":50,"column":26,"offset":1595},"indent":[]}}],"position":{"start":{"line":50,"column":1,"offset":1570},"end":{"line":50,"column":26,"offset":1595},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://norvig.com/lispy.html","children":[{"type":"text","value":"https://norvig.com/lispy.html","position":{"start":{"line":52,"column":3,"offset":1599},"end":{"line":52,"column":32,"offset":1628},"indent":[]}}],"position":{"start":{"line":52,"column":3,"offset":1599},"end":{"line":52,"column":32,"offset":1628},"indent":[]}}],"position":{"start":{"line":52,"column":3,"offset":1599},"end":{"line":52,"column":32,"offset":1628},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":1597},"end":{"line":52,"column":32,"offset":1628},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://eloquentjavascript.net/12_language.html","children":[{"type":"text","value":"https://eloquentjavascript.net/12_language.html","position":{"start":{"line":53,"column":3,"offset":1631},"end":{"line":53,"column":50,"offset":1678},"indent":[]}}],"position":{"start":{"line":53,"column":3,"offset":1631},"end":{"line":53,"column":50,"offset":1678},"indent":[]}}],"position":{"start":{"line":53,"column":3,"offset":1631},"end":{"line":53,"column":50,"offset":1678},"indent":[]}}],"position":{"start":{"line":53,"column":1,"offset":1629},"end":{"line":53,"column":50,"offset":1678},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://github.com/jamiebuilds/the-super-tiny-compiler","children":[{"type":"text","value":"https://github.com/jamiebuilds/the-super-tiny-compiler","position":{"start":{"line":54,"column":3,"offset":1681},"end":{"line":54,"column":57,"offset":1735},"indent":[]}}],"position":{"start":{"line":54,"column":3,"offset":1681},"end":{"line":54,"column":57,"offset":1735},"indent":[]}}],"position":{"start":{"line":54,"column":3,"offset":1681},"end":{"line":54,"column":57,"offset":1735},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":1679},"end":{"line":54,"column":57,"offset":1735},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":1597},"end":{"line":54,"column":57,"offset":1735},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Stages of a Compiler","position":{"start":{"line":56,"column":4,"offset":1740},"end":{"line":56,"column":24,"offset":1760},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":1737},"end":{"line":56,"column":24,"offset":1760},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Parsing: Take source code and turn it into representation of that code.","position":{"start":{"line":58,"column":4,"offset":1765},"end":{"line":58,"column":75,"offset":1836},"indent":[]}}],"position":{"start":{"line":58,"column":4,"offset":1765},"end":{"line":58,"column":75,"offset":1836},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":1762},"end":{"line":58,"column":75,"offset":1836},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Transformation: Take source code and transforms it to do whatever the compiler wants it to do.","position":{"start":{"line":59,"column":4,"offset":1840},"end":{"line":59,"column":98,"offset":1934},"indent":[]}}],"position":{"start":{"line":59,"column":4,"offset":1840},"end":{"line":59,"column":98,"offset":1934},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":1837},"end":{"line":59,"column":98,"offset":1934},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Generation: Take the transformed representation and turns it into a new string of code.","position":{"start":{"line":60,"column":4,"offset":1938},"end":{"line":60,"column":91,"offset":2025},"indent":[]}}],"position":{"start":{"line":60,"column":4,"offset":1938},"end":{"line":60,"column":91,"offset":2025},"indent":[]}}],"position":{"start":{"line":60,"column":1,"offset":1935},"end":{"line":60,"column":91,"offset":2025},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":1762},"end":{"line":60,"column":91,"offset":2025},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Parsing","position":{"start":{"line":62,"column":4,"offset":2030},"end":{"line":62,"column":11,"offset":2037},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":2027},"end":{"line":62,"column":11,"offset":2037},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Parsing consists of:","position":{"start":{"line":64,"column":1,"offset":2039},"end":{"line":64,"column":21,"offset":2059},"indent":[]}}],"position":{"start":{"line":64,"column":1,"offset":2039},"end":{"line":64,"column":21,"offset":2059},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"Lexical analysis","position":{"start":{"line":66,"column":4,"offset":2064},"end":{"line":66,"column":22,"offset":2082},"indent":[]}}],"position":{"start":{"line":66,"column":4,"offset":2064},"end":{"line":66,"column":22,"offset":2082},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":2061},"end":{"line":66,"column":22,"offset":2082},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"Syntactic analysis","position":{"start":{"line":67,"column":4,"offset":2086},"end":{"line":67,"column":24,"offset":2106},"indent":[]}}],"position":{"start":{"line":67,"column":4,"offset":2086},"end":{"line":67,"column":24,"offset":2106},"indent":[]}}],"position":{"start":{"line":67,"column":1,"offset":2083},"end":{"line":67,"column":24,"offset":2106},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":2061},"end":{"line":67,"column":24,"offset":2106},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"Note: Lexing = Lexical analysis.","position":{"start":{"line":69,"column":1,"offset":2108},"end":{"line":69,"column":33,"offset":2140},"indent":[]}}],"position":{"start":{"line":69,"column":1,"offset":2108},"end":{"line":69,"column":33,"offset":2140},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Basically: take big string of code and turn it into ","position":{"start":{"line":71,"column":1,"offset":2142},"end":{"line":71,"column":53,"offset":2194},"indent":[]}},{"type":"inlineCode","value":"tokens","position":{"start":{"line":71,"column":53,"offset":2194},"end":{"line":71,"column":61,"offset":2202},"indent":[]}},{"type":"text","value":" where a ","position":{"start":{"line":71,"column":61,"offset":2202},"end":{"line":71,"column":70,"offset":2211},"indent":[]}},{"type":"inlineCode","value":"token","position":{"start":{"line":71,"column":70,"offset":2211},"end":{"line":71,"column":77,"offset":2218},"indent":[]}},{"type":"text","value":" is a small unit of the language.","position":{"start":{"line":71,"column":77,"offset":2218},"end":{"line":71,"column":110,"offset":2251},"indent":[]}}],"position":{"start":{"line":71,"column":1,"offset":2142},"end":{"line":71,"column":110,"offset":2251},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"How might a lexer work?","position":{"start":{"line":73,"column":1,"offset":2253},"end":{"line":73,"column":24,"offset":2276},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":2253},"end":{"line":73,"column":24,"offset":2276},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Accept input string of code","position":{"start":{"line":75,"column":3,"offset":2280},"end":{"line":75,"column":30,"offset":2307},"indent":[]}}],"position":{"start":{"line":75,"column":3,"offset":2280},"end":{"line":75,"column":30,"offset":2307},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":2278},"end":{"line":75,"column":30,"offset":2307},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Create var for tracking position (like cursor)","position":{"start":{"line":76,"column":3,"offset":2310},"end":{"line":76,"column":49,"offset":2356},"indent":[]}}],"position":{"start":{"line":76,"column":3,"offset":2310},"end":{"line":76,"column":49,"offset":2356},"indent":[]}}],"position":{"start":{"line":76,"column":1,"offset":2308},"end":{"line":76,"column":49,"offset":2356},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Make an array of tokens","position":{"start":{"line":77,"column":3,"offset":2359},"end":{"line":77,"column":26,"offset":2382},"indent":[]}}],"position":{"start":{"line":77,"column":3,"offset":2359},"end":{"line":77,"column":26,"offset":2382},"indent":[]}}],"position":{"start":{"line":77,"column":1,"offset":2357},"end":{"line":77,"column":26,"offset":2382},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Write a while loop that iterates through the source code input","position":{"start":{"line":78,"column":3,"offset":2385},"end":{"line":78,"column":65,"offset":2447},"indent":[]}}],"position":{"start":{"line":78,"column":3,"offset":2385},"end":{"line":78,"column":65,"offset":2447},"indent":[]}}],"position":{"start":{"line":78,"column":1,"offset":2383},"end":{"line":78,"column":65,"offset":2447},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Check each token, see if matches type","position":{"start":{"line":79,"column":3,"offset":2450},"end":{"line":79,"column":40,"offset":2487},"indent":[]}}],"position":{"start":{"line":79,"column":3,"offset":2450},"end":{"line":79,"column":40,"offset":2487},"indent":[]}}],"position":{"start":{"line":79,"column":1,"offset":2448},"end":{"line":79,"column":40,"offset":2487},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Add it to the array of token","position":{"start":{"line":80,"column":3,"offset":2490},"end":{"line":80,"column":31,"offset":2518},"indent":[]}}],"position":{"start":{"line":80,"column":3,"offset":2490},"end":{"line":80,"column":31,"offset":2518},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":2488},"end":{"line":80,"column":31,"offset":2518},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":2278},"end":{"line":80,"column":31,"offset":2518},"indent":[1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Using helpers","position":{"start":{"line":82,"column":5,"offset":2524},"end":{"line":82,"column":18,"offset":2537},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":2520},"end":{"line":82,"column":18,"offset":2537},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This is an example of helpers, but it is worth writing them early and often.","position":{"start":{"line":84,"column":1,"offset":2539},"end":{"line":84,"column":77,"offset":2615},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":2539},"end":{"line":84,"column":77,"offset":2615},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const isWhitespace = character => /\\s/.test(character);\nconst isNumber = character => /[0-9]/.test(character);\nconst isOperator = character => /[\\+\\-\\*\\/]/.test(character);","position":{"start":{"line":86,"column":1,"offset":2617},"end":{"line":90,"column":4,"offset":2807},"indent":[1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Turning strings to tokens","position":{"start":{"line":92,"column":5,"offset":2813},"end":{"line":92,"column":30,"offset":2838},"indent":[]}}],"position":{"start":{"line":92,"column":1,"offset":2809},"end":{"line":92,"column":30,"offset":2838},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Note that based on our syntax, we may need to collect multiple characters into a single token ie ","position":{"start":{"line":94,"column":1,"offset":2840},"end":{"line":94,"column":98,"offset":2937},"indent":[]}},{"type":"inlineCode","value":"22 + 23","position":{"start":{"line":94,"column":98,"offset":2937},"end":{"line":94,"column":107,"offset":2946},"indent":[]}},{"type":"text","value":" (which tokenizes as ","position":{"start":{"line":94,"column":107,"offset":2946},"end":{"line":94,"column":128,"offset":2967},"indent":[]}},{"type":"inlineCode","value":"['2','2','+','2','3']","position":{"start":{"line":94,"column":128,"offset":2967},"end":{"line":94,"column":151,"offset":2990},"indent":[]}},{"type":"text","value":")","position":{"start":{"line":94,"column":151,"offset":2990},"end":{"line":94,"column":152,"offset":2991},"indent":[]}}],"position":{"start":{"line":94,"column":1,"offset":2840},"end":{"line":94,"column":152,"offset":2991},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We write a ","position":{"start":{"line":96,"column":1,"offset":2993},"end":{"line":96,"column":12,"offset":3004},"indent":[]}},{"type":"inlineCode","value":"tokenize","position":{"start":{"line":96,"column":12,"offset":3004},"end":{"line":96,"column":22,"offset":3014},"indent":[]}},{"type":"text","value":" function that takes these helpers for us to tokenize the code that we are parsing.","position":{"start":{"line":96,"column":22,"offset":3014},"end":{"line":96,"column":105,"offset":3097},"indent":[]}}],"position":{"start":{"line":96,"column":1,"offset":2993},"end":{"line":96,"column":105,"offset":3097},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isParenthesis,\n  isQuote,\n} = require('./identify');\n\nconst tokenize = input => {\n  const tokens = [];\n  let cursor = 0;\n\n  while (cursor < input.length) {\n    const character = input[cursor];\n\n    if (isParenthesis(character)) {\n      tokens.push({\n        type: 'Parenthesis',\n        value: character,\n      });\n      cursor++;\n      continue;\n    }\n\n    if (isWhitespace(character)) {\n      cursor++;\n      continue;\n    }\n\n    if (isNumber(character)) {\n      let number = character;\n\n      while (isNumber(input[++cursor])) {\n        number += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Number',\n        value: parseInt(number, 10),\n      });\n\n      continue;\n    }\n\n    if (isLetter(character)) {\n      let symbol = character;\n\n      while (isLetter(input[++cursor])) {\n        symbol += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Name',\n        value: symbol,\n      });\n\n      continue;\n    }\n\n    if (isQuote(character)) {\n      let string = '';\n\n      while (!isQuote(input[++cursor])) {\n        string += input[cursor];\n      }\n\n      tokens.push({\n        type: 'String',\n        value: string,\n      });\n\n      cursor++;\n      continue;\n    }\n\n    throw new Error(`${character} is not valid`);\n  }\n\n  return tokens;\n};\n\nmodule.exports = { tokenize };","position":{"start":{"line":98,"column":1,"offset":3099},"end":{"line":181,"column":4,"offset":4462},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"String traversal and string manipulation in JavaScript is really fast.","position":{"start":{"line":183,"column":3,"offset":4466},"end":{"line":183,"column":73,"offset":4536},"indent":[]}}],"position":{"start":{"line":183,"column":3,"offset":4466},"end":{"line":183,"column":73,"offset":4536},"indent":[]}}],"position":{"start":{"line":183,"column":1,"offset":4464},"end":{"line":183,"column":73,"offset":4536},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Building an AST","position":{"start":{"line":185,"column":4,"offset":4541},"end":{"line":185,"column":19,"offset":4556},"indent":[]}}],"position":{"start":{"line":185,"column":1,"offset":4538},"end":{"line":185,"column":19,"offset":4556},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"How could we build an AST?","position":{"start":{"line":187,"column":1,"offset":4558},"end":{"line":187,"column":27,"offset":4584},"indent":[]}}],"position":{"start":{"line":187,"column":1,"offset":4558},"end":{"line":187,"column":27,"offset":4584},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Iterate through the array of tokens.","position":{"start":{"line":189,"column":4,"offset":4589},"end":{"line":189,"column":40,"offset":4625},"indent":[]}}],"position":{"start":{"line":189,"column":4,"offset":4589},"end":{"line":189,"column":40,"offset":4625},"indent":[]}}],"position":{"start":{"line":189,"column":1,"offset":4586},"end":{"line":189,"column":40,"offset":4625},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"For each number, string, etc. add that token to same level of the tree.","position":{"start":{"line":190,"column":4,"offset":4629},"end":{"line":190,"column":75,"offset":4700},"indent":[]}}],"position":{"start":{"line":190,"column":4,"offset":4629},"end":{"line":190,"column":75,"offset":4700},"indent":[]}}],"position":{"start":{"line":190,"column":1,"offset":4626},"end":{"line":190,"column":75,"offset":4700},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"For each ","position":{"start":{"line":191,"column":4,"offset":4704},"end":{"line":191,"column":13,"offset":4713},"indent":[]}},{"type":"inlineCode","value":"CallExpression","position":{"start":{"line":191,"column":13,"offset":4713},"end":{"line":191,"column":29,"offset":4729},"indent":[]}},{"type":"text","value":" (e.g. function) collect the parameters and then recurse down into the function body.","position":{"start":{"line":191,"column":29,"offset":4729},"end":{"line":191,"column":114,"offset":4814},"indent":[]}}],"position":{"start":{"line":191,"column":4,"offset":4704},"end":{"line":191,"column":114,"offset":4814},"indent":[]}}],"position":{"start":{"line":191,"column":1,"offset":4701},"end":{"line":191,"column":114,"offset":4814},"indent":[]}}],"position":{"start":{"line":189,"column":1,"offset":4586},"end":{"line":191,"column":114,"offset":4814},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Babel is kind of the de facto standard for the AST, so it is worth being able to parse our tokens into a format that Babel can handle.","position":{"start":{"line":193,"column":1,"offset":4816},"end":{"line":193,"column":135,"offset":4950},"indent":[]}}],"position":{"start":{"line":193,"column":1,"offset":4816},"end":{"line":193,"column":135,"offset":4950},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"// identify.js\nconst LETTER = /[a-zA-Z]/;\nconst WHITESPACE = /\\s+/;\nconst NUMBER = /^[0-9]+$/;\nconst OPERATORS = ['+', '-', '*', '/', '%'];\n\nconst isLetter = character => LETTER.test(character);\n\nconst isWhitespace = character => WHITESPACE.test(character);\n\nconst isNumber = character => NUMBER.test(character);\n\nconst isOpeningParenthesis = character => character === '(';\n\nconst isClosingParenthesis = character => character === ')';\n\nconst isParenthesis = character =>\n  isOpeningParenthesis(character) || isClosingParenthesis(character);\n\nconst isQuote = character => character === '\"';\n\nconst isOperator = character => OPERATORS.includes(character);\n\nmodule.exports = {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isOpeningParenthesis,\n  isClosingParenthesis,\n  isParenthesis,\n  isQuote,\n  isOperator,\n};\n\n// utilities.js\nconst tap = require('lodash/tap');\n\nconst pipe = (...funcs) => value =>\n  funcs.reduce((value, func) => func(value), value);\n\nconst log = value => tap(value, console.log);\n\nconst peek = array => array[0];\nconst pop = array => array.shift();\n\nmodule.exports = {\n  pipe,\n  log,\n  peek,\n  pop,\n  tap,\n};\n\n// parse.js\nconst { isOpeningParenthesis, isClosingParenthesis } = require('./identify');\nconst { specialForms } = require('./special-forms');\nconst { peek, pop } = require('./utilities');\n\nconst parenthesize = tokens => {\n  const token = pop(tokens);\n\n  if (isOpeningParenthesis(token.value)) {\n    const expression = [];\n\n    while (!isClosingParenthesis(peek(tokens).value)) {\n      expression.push(parenthesize(tokens));\n    }\n\n    pop(tokens);\n    return expression;\n  }\n\n  return token;\n};\n\nconst parse = tokens => {\n  if (Array.isArray(tokens)) {\n    const [first, ...rest] = tokens;\n    return {\n      type: 'CallExpression',\n      name: first.value,\n      arguments: rest.map(parse),\n    };\n  }\n\n  const token = tokens;\n\n  if (token.type === 'Number') {\n    return {\n      type: 'NumericLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'String') {\n    return {\n      type: 'StringLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'Name') {\n    return {\n      type: 'Identifier',\n      name: token.value,\n    };\n  }\n};\n\nmodule.exports = { parse: tokens => parse(parenthesize(tokens)) };","position":{"start":{"line":195,"column":1,"offset":4952},"end":{"line":306,"column":4,"offset":7231},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"REPL","position":{"start":{"line":308,"column":4,"offset":7236},"end":{"line":308,"column":8,"offset":7240},"indent":[]}}],"position":{"start":{"line":308,"column":1,"offset":7233},"end":{"line":308,"column":8,"offset":7240},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Read-Evaluation-Print-Loop","position":{"start":{"line":310,"column":3,"offset":7244},"end":{"line":310,"column":29,"offset":7270},"indent":[]}}],"position":{"start":{"line":310,"column":3,"offset":7244},"end":{"line":310,"column":29,"offset":7270},"indent":[]}}],"position":{"start":{"line":310,"column":1,"offset":7242},"end":{"line":310,"column":29,"offset":7270},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We are going to build a REPL + CLI tool that you could expand.","position":{"start":{"line":312,"column":1,"offset":7272},"end":{"line":312,"column":63,"offset":7334},"indent":[]}}],"position":{"start":{"line":312,"column":1,"offset":7272},"end":{"line":312,"column":63,"offset":7334},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Notes for this REPL:","position":{"start":{"line":314,"column":1,"offset":7336},"end":{"line":314,"column":21,"offset":7356},"indent":[]}}],"position":{"start":{"line":314,"column":1,"offset":7336},"end":{"line":314,"column":21,"offset":7356},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"We're been using functions like add and subtract, but what do\nthose mean?","position":{"start":{"line":316,"column":4,"offset":7361},"end":{"line":317,"column":15,"offset":7437},"indent":[4]}}],"position":{"start":{"line":316,"column":4,"offset":7361},"end":{"line":317,"column":15,"offset":7437},"indent":[4]}}],"position":{"start":{"line":316,"column":1,"offset":7358},"end":{"line":317,"column":15,"offset":7437},"indent":[1]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Above and beyond having a syntax, most languages have some\namount of a standard library of built-in functions, objects, and\nmethods.","position":{"start":{"line":318,"column":4,"offset":7441},"end":{"line":320,"column":12,"offset":7579},"indent":[4,4]}}],"position":{"start":{"line":318,"column":4,"offset":7441},"end":{"line":320,"column":12,"offset":7579},"indent":[4,4]}}],"position":{"start":{"line":318,"column":1,"offset":7438},"end":{"line":320,"column":12,"offset":7579},"indent":[1,1]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"We’re leveraging JavaScript’s built-in numbers and arrays, but\nwe’re going to need some functions too.","position":{"start":{"line":321,"column":4,"offset":7583},"end":{"line":322,"column":43,"offset":7688},"indent":[4]}}],"position":{"start":{"line":321,"column":4,"offset":7583},"end":{"line":322,"column":43,"offset":7688},"indent":[4]}}],"position":{"start":{"line":321,"column":1,"offset":7580},"end":{"line":322,"column":43,"offset":7688},"indent":[1]}}],"position":{"start":{"line":316,"column":1,"offset":7358},"end":{"line":322,"column":43,"offset":7688},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Since JavaScript is our compile target, we’ll implement our\nbuilt-in functions as JavaScript functions.","position":{"start":{"line":324,"column":1,"offset":7690},"end":{"line":325,"column":44,"offset":7793},"indent":[1]}}],"position":{"start":{"line":324,"column":1,"offset":7690},"end":{"line":325,"column":44,"offset":7793},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"We will add what we need to our ","position":{"start":{"line":327,"column":1,"offset":7795},"end":{"line":327,"column":33,"offset":7827},"indent":[]}},{"type":"inlineCode","value":"standard-library.js","position":{"start":{"line":327,"column":33,"offset":7827},"end":{"line":327,"column":54,"offset":7848},"indent":[]}},{"type":"text","value":" code:","position":{"start":{"line":327,"column":54,"offset":7848},"end":{"line":327,"column":60,"offset":7854},"indent":[]}}],"position":{"start":{"line":327,"column":1,"offset":7795},"end":{"line":327,"column":60,"offset":7854},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const all = fn => (...list) => list.reduce(fn);\n\nconst add = all((a, b) => a + b);\nconst subtract = all((a, b) => a - b);\nconst multiply = all((a, b) => a * b);\nconst divide = all((a, b) => a / b);\nconst modulo = all((a, b) => a % b);\nconst log = console.log;\n\nconst environment = {\n  add,\n  subtract,\n  multiply,\n  divide,\n  modulo,\n  log,\n  pi: Math.PI,\n  max(...args) {\n    return Math.max(...args);\n  },\n};\n\nmodule.exports = { environment };","position":{"start":{"line":329,"column":1,"offset":7856},"end":{"line":353,"column":4,"offset":8319},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Then for the REPL ","position":{"start":{"line":355,"column":1,"offset":8321},"end":{"line":355,"column":19,"offset":8339},"indent":[]}},{"type":"inlineCode","value":"evaluate.js","position":{"start":{"line":355,"column":19,"offset":8339},"end":{"line":355,"column":32,"offset":8352},"indent":[]}},{"type":"text","value":":","position":{"start":{"line":355,"column":32,"offset":8352},"end":{"line":355,"column":33,"offset":8353},"indent":[]}}],"position":{"start":{"line":355,"column":1,"offset":8321},"end":{"line":355,"column":33,"offset":8353},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const { environment } = require('./standard-library');\nconst last = collection => collection[collection.length - 1];\n\nconst apply = node => {\n  const fn = environment[node.name];\n  const args = node.arguments.map(evaluate);\n  if (typeof fn !== 'function') {\n    throw new TypeError(`${node.name} is not a function`);\n  }\n  return fn(...args);\n};\n\nconst getIdentifier = node => {\n  if (environment[node.name]) return environment[node.name];\n  throw new ReferenceError(`${node.name} is not defined`);\n};\n\nconst define = node => {\n  environment[node.identifier.name] = node.assignment.value;\n};\n\nconst evaluate = node => {\n  if (node.type === 'VariableDeclaration') return define(node);\n  if (node.type === 'CallExpression') return apply(node);\n  if (node.type === 'Identifier') return getIdentifier(node);\n  if (node.value) return node.value;\n};\n\nmodule.exports = { evaluate };","position":{"start":{"line":357,"column":1,"offset":8355},"end":{"line":387,"column":4,"offset":9248},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Building the REPL","position":{"start":{"line":389,"column":5,"offset":9254},"end":{"line":389,"column":22,"offset":9271},"indent":[]}}],"position":{"start":{"line":389,"column":1,"offset":9250},"end":{"line":389,"column":22,"offset":9271},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can create a","position":{"start":{"line":391,"column":1,"offset":9273},"end":{"line":391,"column":16,"offset":9288},"indent":[]}},{"type":"inlineCode","value":"repl.js","position":{"start":{"line":391,"column":16,"offset":9288},"end":{"line":391,"column":25,"offset":9297},"indent":[]}},{"type":"text","value":" file to help run a REPL:","position":{"start":{"line":391,"column":25,"offset":9297},"end":{"line":391,"column":50,"offset":9322},"indent":[]}}],"position":{"start":{"line":391,"column":1,"offset":9273},"end":{"line":391,"column":50,"offset":9322},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const { prompt } = require('inquirer');\nconst chalk = require('chalk');\n\nconst { parseAndEvaluate } = require('./parse-and-evaluate');\n\nconst askQuestions = () => {\n  const questions = [\n    { name: 'COMMAND', type: 'input', message: chalk.blue('>') },\n  ];\n\n  return prompt(questions);\n};\n\nconst repl = async () => {\n  try {\n    const answers = await askQuestions();\n    const { COMMAND } = answers;\n\n    if (COMMAND.trim()) {\n      console.log(chalk.yellow(parseAndEvaluate(COMMAND)));\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  repl();\n};\n\nif (require.main === module) {\n  console.log(\n    chalk.red(\n      `Welcome to the ${chalk.bgYellow('Dropbear')} Programming Language`,\n    ),\n  );\n  repl();\n}\n\nmodule.exports = repl;","position":{"start":{"line":393,"column":1,"offset":9324},"end":{"line":432,"column":4,"offset":10084},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Generation","position":{"start":{"line":434,"column":4,"offset":10089},"end":{"line":434,"column":14,"offset":10099},"indent":[]}}],"position":{"start":{"line":434,"column":1,"offset":10086},"end":{"line":434,"column":14,"offset":10099},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Parsing, in reverse.","position":{"start":{"line":436,"column":3,"offset":10103},"end":{"line":436,"column":23,"offset":10123},"indent":[]}}],"position":{"start":{"line":436,"column":3,"offset":10103},"end":{"line":436,"column":23,"offset":10123},"indent":[]}}],"position":{"start":{"line":436,"column":1,"offset":10101},"end":{"line":436,"column":23,"offset":10123},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For generation, you have a few options:","position":{"start":{"line":438,"column":1,"offset":10125},"end":{"line":438,"column":40,"offset":10164},"indent":[]}}],"position":{"start":{"line":438,"column":1,"offset":10125},"end":{"line":438,"column":40,"offset":10164},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Write your own low-level CPU-instruction compiler (probably a bad idea).","position":{"start":{"line":440,"column":4,"offset":10169},"end":{"line":440,"column":76,"offset":10241},"indent":[]}}],"position":{"start":{"line":440,"column":4,"offset":10169},"end":{"line":440,"column":76,"offset":10241},"indent":[]}}],"position":{"start":{"line":440,"column":1,"offset":10166},"end":{"line":440,"column":76,"offset":10241},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Use a compiler framework like LLVM (Rust, Swift, Objective-C).","position":{"start":{"line":441,"column":4,"offset":10245},"end":{"line":441,"column":66,"offset":10307},"indent":[]}}],"position":{"start":{"line":441,"column":4,"offset":10245},"end":{"line":441,"column":66,"offset":10307},"indent":[]}}],"position":{"start":{"line":441,"column":1,"offset":10242},"end":{"line":441,"column":66,"offset":10307},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Target the JVM.","position":{"start":{"line":442,"column":4,"offset":10311},"end":{"line":442,"column":19,"offset":10326},"indent":[]}}],"position":{"start":{"line":442,"column":4,"offset":10311},"end":{"line":442,"column":19,"offset":10326},"indent":[]}}],"position":{"start":{"line":442,"column":1,"offset":10308},"end":{"line":442,"column":19,"offset":10326},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Transpile to another language.","position":{"start":{"line":443,"column":4,"offset":10330},"end":{"line":443,"column":34,"offset":10360},"indent":[]}}],"position":{"start":{"line":443,"column":4,"offset":10330},"end":{"line":443,"column":34,"offset":10360},"indent":[]}}],"position":{"start":{"line":443,"column":1,"offset":10327},"end":{"line":443,"column":34,"offset":10360},"indent":[]}}],"position":{"start":{"line":440,"column":1,"offset":10166},"end":{"line":443,"column":34,"offset":10360},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"If you can get yourself to a Babel-compliant AST, then you can use another tool off the shelf like Babel generator.","position":{"start":{"line":445,"column":1,"offset":10362},"end":{"line":445,"column":116,"offset":10477},"indent":[]}}],"position":{"start":{"line":445,"column":1,"offset":10362},"end":{"line":445,"column":116,"offset":10477},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import generate from '@babel/generator';\n\ngenerate(ast, options, code);","position":{"start":{"line":447,"column":1,"offset":10479},"end":{"line":451,"column":4,"offset":10568},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"We need to transform a AST that you currently have to one that Babel can understand.","position":{"start":{"line":453,"column":1,"offset":10570},"end":{"line":453,"column":85,"offset":10654},"indent":[]}}],"position":{"start":{"line":453,"column":1,"offset":10570},"end":{"line":453,"column":85,"offset":10654},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Visitor Pattern","position":{"start":{"line":455,"column":5,"offset":10660},"end":{"line":455,"column":20,"offset":10675},"indent":[]}}],"position":{"start":{"line":455,"column":1,"offset":10656},"end":{"line":455,"column":20,"offset":10675},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Basically a depth-first search through the tree. The Visitor Pattern allows us define different types of actions for each node visited as it walks the tree.","position":{"start":{"line":457,"column":1,"offset":10677},"end":{"line":457,"column":157,"offset":10833},"indent":[]}}],"position":{"start":{"line":457,"column":1,"offset":10677},"end":{"line":457,"column":157,"offset":10833},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"import traverse from '@babel/traverse';\n\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type === 'VariableDeclaration' && path.node.kind === 'var') {\n      path.node.kind = 'let';\n    }\n  },\n});","position":{"start":{"line":459,"column":1,"offset":10835},"end":{"line":469,"column":4,"offset":11050},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The traversal implementation that we put into the app:","position":{"start":{"line":471,"column":1,"offset":11052},"end":{"line":471,"column":55,"offset":11106},"indent":[]}}],"position":{"start":{"line":471,"column":1,"offset":11052},"end":{"line":471,"column":55,"offset":11106},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const traverseNode = ({ node, parent, visitor }) => {\n  const methods = visitor[node.type];\n\n  if (methods && methods.enter) {\n    methods.enter({ node, parent });\n  }\n\n  if (node.arguments) {\n    traverseArray({ array: node.arguments, parent: node, visitor });\n  }\n\n  if (methods && methods.exit) {\n    methods.exit({ node, parent });\n  }\n};\n\nconst traverseArray = ({ array, parent, visitor }) => {\n  array.forEach(node => {\n    traverseNode({ node, parent, visitor });\n  });\n};\n\nconst traverse = (node, visitor) => {\n  traverseNode({ node, visitor });\n};\n\nmodule.exports = { traverse };\n\n// during visitor implementation\n// const visitor = {\n//   VariableDeclaration: {\n//     enter({ node, parent }) {},\n//     exit() {}\n//   }\n// }","position":{"start":{"line":473,"column":1,"offset":11108},"end":{"line":509,"column":4,"offset":11861},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This is how we can implement this into JS:","position":{"start":{"line":511,"column":1,"offset":11863},"end":{"line":511,"column":43,"offset":11905},"indent":[]}}],"position":{"start":{"line":511,"column":1,"offset":11863},"end":{"line":511,"column":43,"offset":11905},"indent":[]}},{"type":"code","lang":"javascript","meta":null,"value":"const generate = require('@babel/generator').default;\nconst { traverse } = require('./traverse');\n\nconst babelVisitor = {\n  CallExpression: {\n    enter({ node }) {\n      node.callee = { type: 'Identifier', name: node.name };\n    },\n  },\n  VariableDeclaration: {\n    enter({ node }) {\n      node.kind = 'let';\n      node.declarations = [\n        {\n          type: 'VariableDeclarator',\n          id: node.identifier,\n          init: node.assignment,\n        },\n      ];\n    },\n  },\n};\n\nconst toJavaScript = ast => {\n  traverse(ast, babelVisitor);\n  return generate(ast).code;\n};\n\nmodule.exports = {\n  toJavaScript,\n};","position":{"start":{"line":513,"column":1,"offset":11907},"end":{"line":545,"column":4,"offset":12541},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Bonus Terms","position":{"start":{"line":547,"column":4,"offset":12546},"end":{"line":547,"column":15,"offset":12557},"indent":[]}}],"position":{"start":{"line":547,"column":1,"offset":12543},"end":{"line":547,"column":15,"offset":12557},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Homoiconicity: A language that can modify its own underlying data structure.","position":{"start":{"line":549,"column":3,"offset":12561},"end":{"line":549,"column":79,"offset":12637},"indent":[]}}],"position":{"start":{"line":549,"column":3,"offset":12561},"end":{"line":549,"column":79,"offset":12637},"indent":[]}}],"position":{"start":{"line":549,"column":1,"offset":12559},"end":{"line":549,"column":79,"offset":12637},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Self-Hosting: The language is written in the language itself.","position":{"start":{"line":550,"column":3,"offset":12640},"end":{"line":550,"column":64,"offset":12701},"indent":[]}}],"position":{"start":{"line":550,"column":3,"offset":12640},"end":{"line":550,"column":64,"offset":12701},"indent":[]}}],"position":{"start":{"line":550,"column":1,"offset":12638},"end":{"line":550,"column":64,"offset":12701},"indent":[]}}],"position":{"start":{"line":549,"column":1,"offset":12559},"end":{"line":550,"column":64,"offset":12701},"indent":[1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":553,"column":1,"offset":12704},"end":{"line":553,"column":31,"offset":12734},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":553,"column":31,"offset":12734}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"creating-your-own-language\"\n    }}>{`Creating Your Own Language`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/stevekinney/dropbear/\"\n        }}>{`Dropbear GitHub language`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"http://static.frontendmasters.com/resources/2019-05-31-build-your-own-programming-language/programming-language.pdf\"\n        }}>{`Slides`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"why-your-own-language\"\n    }}>{`Why your own language?`}</h2>\n    <p>{`There are elements that are super practical for production code.`}</p>\n    <h3 {...{\n      \"id\": \"use-cases\"\n    }}>{`Use Cases`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Domain-Specific Languages: Terraform, Gemfiles`}</li>\n      <li parentName=\"ol\">{`Templating languages: Handlebars, Pug`}</li>\n    </ol>\n    <h3 {...{\n      \"id\": \"usecases-at-sendgrid\"\n    }}>{`Usecases at SendGrid`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Drag + Drop editor takes HTML, parses it into an abstract syntax tree (AST) and manipulates it before serializing it back into HTML.`}</li>\n      <li parentName=\"ul\">{`Using it for own bespoke templating language for dynamic email templates.`}</li>\n      <li parentName=\"ul\">{`Sync position in side-by-side editor by breaking HTML into an AST and rewriting the elements with information about their position in the text editor.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"what-is-a-compiler\"\n    }}>{`What is a compiler?`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Something that turns a higher-level language into a lower-level langauge.`}</p>\n    </blockquote>\n    <p>{`In this particular example, we will follow the course that builds the language `}<inlineCode parentName=\"p\">{`Dropbear`}</inlineCode>{`.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Lisp-like language`}</li>\n      <li parentName=\"ul\">{`Leverage existing JavaScript run-time`}</li>\n    </ul>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`(add 1 2 (subtract 6 3))\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Source code is meant to be human-readable.`}</p>\n    </blockquote>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The beauty of Scheme is that the full language only needs\n5 keywords and 8 syntactic forms. In comparison, Python\nhas 33 keywords and 110 syntactic forms, and Java has 50\nkeywords and 133 syntactic forms. — Peter Norvig.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"inspiration-resources\"\n    }}>{`Inspiration Resources`}</h3>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://norvig.com/lispy.html\"\n        }}>{`https://norvig.com/lispy.html`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://eloquentjavascript.net/12_language.html\"\n        }}>{`https://eloquentjavascript.net/12_language.html`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/jamiebuilds/the-super-tiny-compiler\"\n        }}>{`https://github.com/jamiebuilds/the-super-tiny-compiler`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"stages-of-a-compiler\"\n    }}>{`Stages of a Compiler`}</h2>\n    <ol>\n      <li parentName=\"ol\">{`Parsing: Take source code and turn it into representation of that code.`}</li>\n      <li parentName=\"ol\">{`Transformation: Take source code and transforms it to do whatever the compiler wants it to do.`}</li>\n      <li parentName=\"ol\">{`Generation: Take the transformed representation and turns it into a new string of code.`}</li>\n    </ol>\n    <h2 {...{\n      \"id\": \"parsing\"\n    }}>{`Parsing`}</h2>\n    <p>{`Parsing consists of:`}</p>\n    <ol>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`Lexical analysis`}</inlineCode></li>\n      <li parentName=\"ol\"><inlineCode parentName=\"li\">{`Syntactic analysis`}</inlineCode></li>\n    </ol>\n    <p>{`Note: Lexing = Lexical analysis.`}</p>\n    <p>{`Basically: take big string of code and turn it into `}<inlineCode parentName=\"p\">{`tokens`}</inlineCode>{` where a `}<inlineCode parentName=\"p\">{`token`}</inlineCode>{` is a small unit of the language.`}</p>\n    <p>{`How might a lexer work?`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Accept input string of code`}</li>\n      <li parentName=\"ul\">{`Create var for tracking position (like cursor)`}</li>\n      <li parentName=\"ul\">{`Make an array of tokens`}</li>\n      <li parentName=\"ul\">{`Write a while loop that iterates through the source code input`}</li>\n      <li parentName=\"ul\">{`Check each token, see if matches type`}</li>\n      <li parentName=\"ul\">{`Add it to the array of token`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"using-helpers\"\n    }}>{`Using helpers`}</h3>\n    <p>{`This is an example of helpers, but it is worth writing them early and often.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const isWhitespace = character => /\\\\s/.test(character);\nconst isNumber = character => /[0-9]/.test(character);\nconst isOperator = character => /[\\\\+\\\\-\\\\*\\\\/]/.test(character);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"turning-strings-to-tokens\"\n    }}>{`Turning strings to tokens`}</h3>\n    <p>{`Note that based on our syntax, we may need to collect multiple characters into a single token ie `}<inlineCode parentName=\"p\">{`22 + 23`}</inlineCode>{` (which tokenizes as `}<inlineCode parentName=\"p\">{`['2','2','+','2','3']`}</inlineCode>{`)`}</p>\n    <p>{`We write a `}<inlineCode parentName=\"p\">{`tokenize`}</inlineCode>{` function that takes these helpers for us to tokenize the code that we are parsing.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isParenthesis,\n  isQuote,\n} = require('./identify');\n\nconst tokenize = input => {\n  const tokens = [];\n  let cursor = 0;\n\n  while (cursor < input.length) {\n    const character = input[cursor];\n\n    if (isParenthesis(character)) {\n      tokens.push({\n        type: 'Parenthesis',\n        value: character,\n      });\n      cursor++;\n      continue;\n    }\n\n    if (isWhitespace(character)) {\n      cursor++;\n      continue;\n    }\n\n    if (isNumber(character)) {\n      let number = character;\n\n      while (isNumber(input[++cursor])) {\n        number += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Number',\n        value: parseInt(number, 10),\n      });\n\n      continue;\n    }\n\n    if (isLetter(character)) {\n      let symbol = character;\n\n      while (isLetter(input[++cursor])) {\n        symbol += input[cursor];\n      }\n\n      tokens.push({\n        type: 'Name',\n        value: symbol,\n      });\n\n      continue;\n    }\n\n    if (isQuote(character)) {\n      let string = '';\n\n      while (!isQuote(input[++cursor])) {\n        string += input[cursor];\n      }\n\n      tokens.push({\n        type: 'String',\n        value: string,\n      });\n\n      cursor++;\n      continue;\n    }\n\n    throw new Error(\\`\\${character} is not valid\\`);\n  }\n\n  return tokens;\n};\n\nmodule.exports = { tokenize };\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`String traversal and string manipulation in JavaScript is really fast.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"building-an-ast\"\n    }}>{`Building an AST`}</h2>\n    <p>{`How could we build an AST?`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Iterate through the array of tokens.`}</li>\n      <li parentName=\"ol\">{`For each number, string, etc. add that token to same level of the tree.`}</li>\n      <li parentName=\"ol\">{`For each `}<inlineCode parentName=\"li\">{`CallExpression`}</inlineCode>{` (e.g. function) collect the parameters and then recurse down into the function body.`}</li>\n    </ol>\n    <p>{`Babel is kind of the de facto standard for the AST, so it is worth being able to parse our tokens into a format that Babel can handle.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`// identify.js\nconst LETTER = /[a-zA-Z]/;\nconst WHITESPACE = /\\\\s+/;\nconst NUMBER = /^[0-9]+$/;\nconst OPERATORS = ['+', '-', '*', '/', '%'];\n\nconst isLetter = character => LETTER.test(character);\n\nconst isWhitespace = character => WHITESPACE.test(character);\n\nconst isNumber = character => NUMBER.test(character);\n\nconst isOpeningParenthesis = character => character === '(';\n\nconst isClosingParenthesis = character => character === ')';\n\nconst isParenthesis = character =>\n  isOpeningParenthesis(character) || isClosingParenthesis(character);\n\nconst isQuote = character => character === '\"';\n\nconst isOperator = character => OPERATORS.includes(character);\n\nmodule.exports = {\n  isLetter,\n  isWhitespace,\n  isNumber,\n  isOpeningParenthesis,\n  isClosingParenthesis,\n  isParenthesis,\n  isQuote,\n  isOperator,\n};\n\n// utilities.js\nconst tap = require('lodash/tap');\n\nconst pipe = (...funcs) => value =>\n  funcs.reduce((value, func) => func(value), value);\n\nconst log = value => tap(value, console.log);\n\nconst peek = array => array[0];\nconst pop = array => array.shift();\n\nmodule.exports = {\n  pipe,\n  log,\n  peek,\n  pop,\n  tap,\n};\n\n// parse.js\nconst { isOpeningParenthesis, isClosingParenthesis } = require('./identify');\nconst { specialForms } = require('./special-forms');\nconst { peek, pop } = require('./utilities');\n\nconst parenthesize = tokens => {\n  const token = pop(tokens);\n\n  if (isOpeningParenthesis(token.value)) {\n    const expression = [];\n\n    while (!isClosingParenthesis(peek(tokens).value)) {\n      expression.push(parenthesize(tokens));\n    }\n\n    pop(tokens);\n    return expression;\n  }\n\n  return token;\n};\n\nconst parse = tokens => {\n  if (Array.isArray(tokens)) {\n    const [first, ...rest] = tokens;\n    return {\n      type: 'CallExpression',\n      name: first.value,\n      arguments: rest.map(parse),\n    };\n  }\n\n  const token = tokens;\n\n  if (token.type === 'Number') {\n    return {\n      type: 'NumericLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'String') {\n    return {\n      type: 'StringLiteral',\n      value: token.value,\n    };\n  }\n\n  if (token.type === 'Name') {\n    return {\n      type: 'Identifier',\n      name: token.value,\n    };\n  }\n};\n\nmodule.exports = { parse: tokens => parse(parenthesize(tokens)) };\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"repl\"\n    }}>{`REPL`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Read-Evaluation-Print-Loop`}</p>\n    </blockquote>\n    <p>{`We are going to build a REPL + CLI tool that you could expand.`}</p>\n    <p>{`Notes for this REPL:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`We're been using functions like add and subtract, but what do\nthose mean?`}</li>\n      <li parentName=\"ol\">{`Above and beyond having a syntax, most languages have some\namount of a standard library of built-in functions, objects, and\nmethods.`}</li>\n      <li parentName=\"ol\">{`We’re leveraging JavaScript’s built-in numbers and arrays, but\nwe’re going to need some functions too.`}</li>\n    </ol>\n    <p>{`Since JavaScript is our compile target, we’ll implement our\nbuilt-in functions as JavaScript functions.`}</p>\n    <p>{`We will add what we need to our `}<inlineCode parentName=\"p\">{`standard-library.js`}</inlineCode>{` code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const all = fn => (...list) => list.reduce(fn);\n\nconst add = all((a, b) => a + b);\nconst subtract = all((a, b) => a - b);\nconst multiply = all((a, b) => a * b);\nconst divide = all((a, b) => a / b);\nconst modulo = all((a, b) => a % b);\nconst log = console.log;\n\nconst environment = {\n  add,\n  subtract,\n  multiply,\n  divide,\n  modulo,\n  log,\n  pi: Math.PI,\n  max(...args) {\n    return Math.max(...args);\n  },\n};\n\nmodule.exports = { environment };\n`}</code></pre>\n    <p>{`Then for the REPL `}<inlineCode parentName=\"p\">{`evaluate.js`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const { environment } = require('./standard-library');\nconst last = collection => collection[collection.length - 1];\n\nconst apply = node => {\n  const fn = environment[node.name];\n  const args = node.arguments.map(evaluate);\n  if (typeof fn !== 'function') {\n    throw new TypeError(\\`\\${node.name} is not a function\\`);\n  }\n  return fn(...args);\n};\n\nconst getIdentifier = node => {\n  if (environment[node.name]) return environment[node.name];\n  throw new ReferenceError(\\`\\${node.name} is not defined\\`);\n};\n\nconst define = node => {\n  environment[node.identifier.name] = node.assignment.value;\n};\n\nconst evaluate = node => {\n  if (node.type === 'VariableDeclaration') return define(node);\n  if (node.type === 'CallExpression') return apply(node);\n  if (node.type === 'Identifier') return getIdentifier(node);\n  if (node.value) return node.value;\n};\n\nmodule.exports = { evaluate };\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"building-the-repl\"\n    }}>{`Building the REPL`}</h3>\n    <p>{`We can create a`}<inlineCode parentName=\"p\">{`repl.js`}</inlineCode>{` file to help run a REPL:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const { prompt } = require('inquirer');\nconst chalk = require('chalk');\n\nconst { parseAndEvaluate } = require('./parse-and-evaluate');\n\nconst askQuestions = () => {\n  const questions = [\n    { name: 'COMMAND', type: 'input', message: chalk.blue('>') },\n  ];\n\n  return prompt(questions);\n};\n\nconst repl = async () => {\n  try {\n    const answers = await askQuestions();\n    const { COMMAND } = answers;\n\n    if (COMMAND.trim()) {\n      console.log(chalk.yellow(parseAndEvaluate(COMMAND)));\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  repl();\n};\n\nif (require.main === module) {\n  console.log(\n    chalk.red(\n      \\`Welcome to the \\${chalk.bgYellow('Dropbear')} Programming Language\\`,\n    ),\n  );\n  repl();\n}\n\nmodule.exports = repl;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"generation\"\n    }}>{`Generation`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Parsing, in reverse.`}</p>\n    </blockquote>\n    <p>{`For generation, you have a few options:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Write your own low-level CPU-instruction compiler (probably a bad idea).`}</li>\n      <li parentName=\"ol\">{`Use a compiler framework like LLVM (Rust, Swift, Objective-C).`}</li>\n      <li parentName=\"ol\">{`Target the JVM.`}</li>\n      <li parentName=\"ol\">{`Transpile to another language.`}</li>\n    </ol>\n    <p>{`If you can get yourself to a Babel-compliant AST, then you can use another tool off the shelf like Babel generator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import generate from '@babel/generator';\n\ngenerate(ast, options, code);\n`}</code></pre>\n    <p>{`We need to transform a AST that you currently have to one that Babel can understand.`}</p>\n    <h3 {...{\n      \"id\": \"visitor-pattern\"\n    }}>{`Visitor Pattern`}</h3>\n    <p>{`Basically a depth-first search through the tree. The Visitor Pattern allows us define different types of actions for each node visited as it walks the tree.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import traverse from '@babel/traverse';\n\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type === 'VariableDeclaration' && path.node.kind === 'var') {\n      path.node.kind = 'let';\n    }\n  },\n});\n`}</code></pre>\n    <p>{`The traversal implementation that we put into the app:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const traverseNode = ({ node, parent, visitor }) => {\n  const methods = visitor[node.type];\n\n  if (methods && methods.enter) {\n    methods.enter({ node, parent });\n  }\n\n  if (node.arguments) {\n    traverseArray({ array: node.arguments, parent: node, visitor });\n  }\n\n  if (methods && methods.exit) {\n    methods.exit({ node, parent });\n  }\n};\n\nconst traverseArray = ({ array, parent, visitor }) => {\n  array.forEach(node => {\n    traverseNode({ node, parent, visitor });\n  });\n};\n\nconst traverse = (node, visitor) => {\n  traverseNode({ node, visitor });\n};\n\nmodule.exports = { traverse };\n\n// during visitor implementation\n// const visitor = {\n//   VariableDeclaration: {\n//     enter({ node, parent }) {},\n//     exit() {}\n//   }\n// }\n`}</code></pre>\n    <p>{`This is how we can implement this into JS:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const generate = require('@babel/generator').default;\nconst { traverse } = require('./traverse');\n\nconst babelVisitor = {\n  CallExpression: {\n    enter({ node }) {\n      node.callee = { type: 'Identifier', name: node.name };\n    },\n  },\n  VariableDeclaration: {\n    enter({ node }) {\n      node.kind = 'let';\n      node.declarations = [\n        {\n          type: 'VariableDeclarator',\n          id: node.identifier,\n          init: node.assignment,\n        },\n      ];\n    },\n  },\n};\n\nconst toJavaScript = ast => {\n  traverse(ast, babelVisitor);\n  return generate(ast).code;\n};\n\nmodule.exports = {\n  toJavaScript,\n};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bonus-terms\"\n    }}>{`Bonus Terms`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Homoiconicity: A language that can modify its own underlying data structure.`}</li>\n      <li parentName=\"ul\">{`Self-Hosting: The language is written in the language itself.`}</li>\n    </ul>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}