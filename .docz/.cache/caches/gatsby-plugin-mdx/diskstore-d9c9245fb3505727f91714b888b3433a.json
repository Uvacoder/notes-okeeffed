{"expireTime":9007200866986930000,"key":"gatsby-plugin-mdx-entire-payload-4f6610cc50c12e51ecfe37fad487f2c5-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"React Performance","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":20,"offset":186},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":20,"offset":186},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"React in general is fast. That being said, there are tools to help aid us when we need those tools to help optimize particular scenarios.","position":{"start":{"line":10,"column":1,"offset":188},"end":{"line":10,"column":138,"offset":325},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":188},"end":{"line":10,"column":138,"offset":325},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"What is important is to know what tool to grab at the appropriate time.","position":{"start":{"line":12,"column":1,"offset":327},"end":{"line":12,"column":72,"offset":398},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":327},"end":{"line":12,"column":72,"offset":398},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Code Splitting","position":{"start":{"line":14,"column":4,"offset":403},"end":{"line":14,"column":18,"offset":417},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":400},"end":{"line":14,"column":18,"offset":417},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The single, biggest impact you can have on your performance. It will help lazily load code when required.","position":{"start":{"line":16,"column":1,"offset":419},"end":{"line":16,"column":106,"offset":524},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":419},"end":{"line":16,"column":106,"offset":524},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this first example, we simple used ","position":{"start":{"line":18,"column":1,"offset":526},"end":{"line":18,"column":39,"offset":564},"indent":[]}},{"type":"inlineCode","value":"React.lazy","position":{"start":{"line":18,"column":39,"offset":564},"end":{"line":18,"column":51,"offset":576},"indent":[]}},{"type":"text","value":" to lazy import a file and then used the ","position":{"start":{"line":18,"column":51,"offset":576},"end":{"line":18,"column":92,"offset":617},"indent":[]}},{"type":"inlineCode","value":"Suspense","position":{"start":{"line":18,"column":92,"offset":617},"end":{"line":18,"column":102,"offset":627},"indent":[]}},{"type":"text","value":" library to handle the fallback.","position":{"start":{"line":18,"column":102,"offset":627},"end":{"line":18,"column":134,"offset":659},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":526},"end":{"line":18,"column":134,"offset":659},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"What is important to do to test and see the visual changes:","position":{"start":{"line":20,"column":1,"offset":661},"end":{"line":20,"column":60,"offset":720},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":661},"end":{"line":20,"column":60,"offset":720},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Check the network tab","position":{"start":{"line":22,"column":4,"offset":725},"end":{"line":22,"column":25,"offset":746},"indent":[]}}],"position":{"start":{"line":22,"column":4,"offset":725},"end":{"line":22,"column":25,"offset":746},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":722},"end":{"line":22,"column":25,"offset":746},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Check the coverage tab","position":{"start":{"line":23,"column":4,"offset":750},"end":{"line":23,"column":26,"offset":772},"indent":[]}}],"position":{"start":{"line":23,"column":4,"offset":750},"end":{"line":23,"column":26,"offset":772},"indent":[]}}],"position":{"start":{"line":23,"column":1,"offset":747},"end":{"line":23,"column":26,"offset":772},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":722},"end":{"line":23,"column":26,"offset":772},"indent":[1]}},{"type":"code","lang":"js","meta":null,"value":"// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// 💣 remove this import\n\n// 🐨 use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(() => import('../globe'));\n\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // 🐨 wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // 💰 try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// 🦉 Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;","position":{"start":{"line":25,"column":1,"offset":774},"end":{"line":78,"column":4,"offset":2306},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Eager Loading","position":{"start":{"line":80,"column":5,"offset":2312},"end":{"line":80,"column":18,"offset":2325},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":2308},"end":{"line":80,"column":18,"offset":2325},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Given a certain \"indication\" that a user may click, we can load earlier.","position":{"start":{"line":82,"column":1,"offset":2327},"end":{"line":82,"column":73,"offset":2399},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":2327},"end":{"line":82,"column":73,"offset":2399},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can enter a ","position":{"start":{"line":84,"column":1,"offset":2401},"end":{"line":84,"column":16,"offset":2416},"indent":[]}},{"type":"inlineCode","value":"onMouseEnter","position":{"start":{"line":84,"column":16,"offset":2416},"end":{"line":84,"column":30,"offset":2430},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":84,"column":30,"offset":2430},"end":{"line":84,"column":35,"offset":2435},"indent":[]}},{"type":"inlineCode","value":"onFocus","position":{"start":{"line":84,"column":35,"offset":2435},"end":{"line":84,"column":44,"offset":2444},"indent":[]}},{"type":"text","value":" to fire an eager import:","position":{"start":{"line":84,"column":44,"offset":2444},"end":{"line":84,"column":69,"offset":2469},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":2401},"end":{"line":84,"column":69,"offset":2469},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// 💣 remove this import\n\nconst loadGlobe = () => import('../globe');\n// 🐨 use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(loadGlobe);\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // 🐨 wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // 💰 try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n          onMouseEnter={loadGlobe}\n          onFocus={loadGlobe}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// 🦉 Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;","position":{"start":{"line":86,"column":1,"offset":2471},"end":{"line":141,"column":4,"offset":4096},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Webpack Magic Comments","position":{"start":{"line":143,"column":5,"offset":4102},"end":{"line":143,"column":27,"offset":4124},"indent":[]}}],"position":{"start":{"line":143,"column":1,"offset":4098},"end":{"line":143,"column":27,"offset":4124},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A comment like the following will allow you to start pre-fetching some other resources. Webpack has an API for you to hook into.","position":{"start":{"line":145,"column":1,"offset":4126},"end":{"line":145,"column":129,"offset":4254},"indent":[]}}],"position":{"start":{"line":145,"column":1,"offset":4126},"end":{"line":145,"column":129,"offset":4254},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"import(/* webpackPrefetch: true */ './some-module.js');","position":{"start":{"line":147,"column":1,"offset":4256},"end":{"line":149,"column":4,"offset":4321},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You can confirm this prefetch work based on what shows in the elements tab under the ","position":{"start":{"line":151,"column":1,"offset":4323},"end":{"line":151,"column":86,"offset":4408},"indent":[]}},{"type":"inlineCode","value":"head","position":{"start":{"line":151,"column":86,"offset":4408},"end":{"line":151,"column":92,"offset":4414},"indent":[]}},{"type":"text","value":" tag to see the prefetch links have been added.","position":{"start":{"line":151,"column":92,"offset":4414},"end":{"line":151,"column":139,"offset":4461},"indent":[]}}],"position":{"start":{"line":151,"column":1,"offset":4323},"end":{"line":151,"column":139,"offset":4461},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Suspense Position","position":{"start":{"line":153,"column":5,"offset":4467},"end":{"line":153,"column":22,"offset":4484},"indent":[]}}],"position":{"start":{"line":153,"column":1,"offset":4463},"end":{"line":153,"column":22,"offset":4484},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In future React, there will be some implications for React Suspense for when it is mounted as opposed to updated.","position":{"start":{"line":155,"column":1,"offset":4486},"end":{"line":155,"column":114,"offset":4599},"indent":[]}}],"position":{"start":{"line":155,"column":1,"offset":4486},"end":{"line":155,"column":114,"offset":4599},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It is also very important for the position of your Suspense tool to be correct.","position":{"start":{"line":157,"column":1,"offset":4601},"end":{"line":157,"column":80,"offset":4680},"indent":[]}}],"position":{"start":{"line":157,"column":1,"offset":4601},"end":{"line":157,"column":80,"offset":4680},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There is also the capability to click a button to \"suspend\" the component and see what is looks like from the React DevTools.","position":{"start":{"line":159,"column":1,"offset":4682},"end":{"line":159,"column":126,"offset":4807},"indent":[]}}],"position":{"start":{"line":159,"column":1,"offset":4682},"end":{"line":159,"column":126,"offset":4807},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Understanding the coverage report","position":{"start":{"line":161,"column":5,"offset":4813},"end":{"line":161,"column":38,"offset":4846},"indent":[]}}],"position":{"start":{"line":161,"column":1,"offset":4809},"end":{"line":161,"column":38,"offset":4846},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When you check the coverage of the before and after, you see there are less files in the after and a significant amount of savings.","position":{"start":{"line":163,"column":1,"offset":4848},"end":{"line":163,"column":132,"offset":4979},"indent":[]}}],"position":{"start":{"line":163,"column":1,"offset":4848},"end":{"line":163,"column":132,"offset":4979},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Clicking on the individual files also shows you chunks with lines that have and have not been used.","position":{"start":{"line":165,"column":1,"offset":4981},"end":{"line":165,"column":100,"offset":5080},"indent":[]}}],"position":{"start":{"line":165,"column":1,"offset":4981},"end":{"line":165,"column":100,"offset":5080},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"useMemo","position":{"start":{"line":167,"column":4,"offset":5085},"end":{"line":167,"column":11,"offset":5092},"indent":[]}}],"position":{"start":{"line":167,"column":1,"offset":5082},"end":{"line":167,"column":11,"offset":5092},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"useMemo","position":{"start":{"line":169,"column":1,"offset":5094},"end":{"line":169,"column":10,"offset":5103},"indent":[]}},{"type":"text","value":" is the hero you need for expensive calculations and how the API works.","position":{"start":{"line":169,"column":10,"offset":5103},"end":{"line":169,"column":81,"offset":5174},"indent":[]}}],"position":{"start":{"line":169,"column":1,"offset":5094},"end":{"line":169,"column":81,"offset":5174},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The example shows a massive list that should not recalculate with the same input value:","position":{"start":{"line":171,"column":1,"offset":5176},"end":{"line":171,"column":88,"offset":5263},"indent":[]}}],"position":{"start":{"line":171,"column":1,"offset":5176},"end":{"line":171,"column":88,"offset":5263},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// useMemo for expensive calculations\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../filter-cities';\nimport { useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  // 🐨 wrap getItems in a call to `React.useMemo`\n  const allItems = React.useMemo(() => getItems(inputValue), [inputValue]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":173,"column":1,"offset":5265},"end":{"line":286,"column":4,"offset":7937},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Using a Web Worker","position":{"start":{"line":288,"column":5,"offset":7943},"end":{"line":288,"column":23,"offset":7961},"indent":[]}}],"position":{"start":{"line":288,"column":1,"offset":7939},"end":{"line":288,"column":23,"offset":7961},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There is information about this more ","position":{"start":{"line":290,"column":1,"offset":7963},"end":{"line":290,"column":38,"offset":8000},"indent":[]}},{"type":"link","title":null,"url":"https://kentcdodds.com/blog/speed-up-your-app-with-web-workers","children":[{"type":"text","value":"on Kent's blog","position":{"start":{"line":290,"column":39,"offset":8001},"end":{"line":290,"column":53,"offset":8015},"indent":[]}}],"position":{"start":{"line":290,"column":38,"offset":8000},"end":{"line":290,"column":118,"offset":8080},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":290,"column":118,"offset":8080},"end":{"line":290,"column":119,"offset":8081},"indent":[]}}],"position":{"start":{"line":290,"column":1,"offset":7963},"end":{"line":290,"column":119,"offset":8081},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There is a ","position":{"start":{"line":292,"column":1,"offset":8083},"end":{"line":292,"column":12,"offset":8094},"indent":[]}},{"type":"inlineCode","value":"workerize","position":{"start":{"line":292,"column":12,"offset":8094},"end":{"line":292,"column":23,"offset":8105},"indent":[]}},{"type":"text","value":" Webpack loader that can be used with Webpack that helps this process.","position":{"start":{"line":292,"column":23,"offset":8105},"end":{"line":292,"column":93,"offset":8175},"indent":[]}}],"position":{"start":{"line":292,"column":1,"offset":8083},"end":{"line":292,"column":93,"offset":8175},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"React.memo","position":{"start":{"line":294,"column":4,"offset":8180},"end":{"line":294,"column":14,"offset":8190},"indent":[]}}],"position":{"start":{"line":294,"column":1,"offset":8177},"end":{"line":294,"column":14,"offset":8190},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The lifecycle of a React app goes ","position":{"start":{"line":296,"column":1,"offset":8192},"end":{"line":296,"column":35,"offset":8226},"indent":[]}},{"type":"inlineCode","value":"render -> reconciliation -> commit -> state change -> repeat","position":{"start":{"line":296,"column":35,"offset":8226},"end":{"line":296,"column":97,"offset":8288},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":296,"column":97,"offset":8288},"end":{"line":296,"column":98,"offset":8289},"indent":[]}}],"position":{"start":{"line":296,"column":1,"offset":8192},"end":{"line":296,"column":98,"offset":8289},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"React is fast at doing this, but sometimes it needs help for Performance.","position":{"start":{"line":298,"column":1,"offset":8291},"end":{"line":298,"column":74,"offset":8364},"indent":[]}}],"position":{"start":{"line":298,"column":1,"offset":8291},"end":{"line":298,"column":74,"offset":8364},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Note: you should fix slow renders before you fix re-renders.","position":{"start":{"line":300,"column":3,"offset":8368},"end":{"line":300,"column":63,"offset":8428},"indent":[]}}],"position":{"start":{"line":300,"column":3,"offset":8368},"end":{"line":300,"column":63,"offset":8428},"indent":[]}}],"position":{"start":{"line":300,"column":1,"offset":8366},"end":{"line":300,"column":63,"offset":8428},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the React DevTools profile, you can shift through each \"commit\" on the top \"bar chart\". We can rectify some of these issues using ","position":{"start":{"line":302,"column":1,"offset":8430},"end":{"line":302,"column":134,"offset":8563},"indent":[]}},{"type":"inlineCode","value":"pureComponent","position":{"start":{"line":302,"column":134,"offset":8563},"end":{"line":302,"column":149,"offset":8578},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":302,"column":149,"offset":8578},"end":{"line":302,"column":153,"offset":8582},"indent":[]}},{"type":"inlineCode","value":"memo","position":{"start":{"line":302,"column":153,"offset":8582},"end":{"line":302,"column":159,"offset":8588},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":302,"column":159,"offset":8588},"end":{"line":302,"column":160,"offset":8589},"indent":[]}}],"position":{"start":{"line":302,"column":1,"offset":8430},"end":{"line":302,"column":160,"offset":8589},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We seriously improved the experience with this:","position":{"start":{"line":304,"column":1,"offset":8591},"end":{"line":304,"column":48,"offset":8638},"indent":[]}}],"position":{"start":{"line":304,"column":1,"offset":8591},"end":{"line":304,"column":48,"offset":8638},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// 🐨 Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// 🐨 Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":306,"column":1,"offset":8640},"end":{"line":425,"column":4,"offset":11529},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Custom Comparator","position":{"start":{"line":427,"column":5,"offset":11535},"end":{"line":427,"column":22,"offset":11552},"indent":[]}}],"position":{"start":{"line":427,"column":1,"offset":11531},"end":{"line":427,"column":22,"offset":11552},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can create a custom comparator to define when we should re-render.","position":{"start":{"line":429,"column":1,"offset":11554},"end":{"line":429,"column":70,"offset":11623},"indent":[]}}],"position":{"start":{"line":429,"column":1,"offset":11554},"end":{"line":429,"column":70,"offset":11623},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the above, you may notice that highlighting a component is forcing all items to re-render.","position":{"start":{"line":431,"column":1,"offset":11625},"end":{"line":431,"column":94,"offset":11718},"indent":[]}}],"position":{"start":{"line":431,"column":1,"offset":11625},"end":{"line":431,"column":94,"offset":11718},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can get around this using a custom comparator in ","position":{"start":{"line":433,"column":1,"offset":11720},"end":{"line":433,"column":53,"offset":11772},"indent":[]}},{"type":"inlineCode","value":"React.memo","position":{"start":{"line":433,"column":53,"offset":11772},"end":{"line":433,"column":65,"offset":11784},"indent":[]}},{"type":"text","value":" as the second argument for the ","position":{"start":{"line":433,"column":65,"offset":11784},"end":{"line":433,"column":97,"offset":11816},"indent":[]}},{"type":"inlineCode","value":"ListItem","position":{"start":{"line":433,"column":97,"offset":11816},"end":{"line":433,"column":107,"offset":11826},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":433,"column":107,"offset":11826},"end":{"line":433,"column":108,"offset":11827},"indent":[]}}],"position":{"start":{"line":433,"column":1,"offset":11720},"end":{"line":433,"column":108,"offset":11827},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// 🐨 Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// 🐨 Memoize the ListItem here using React.memo and use Domain Specific Knowledge\n// to help React know when it should trigger a re-render.\nListItem = React.memo(ListItem, (prevProps, nextProps) => {\n  if (prevProps.getItemProps !== nextProps.getItemProps) return false;\n  if (prevProps.items !== nextProps.items) return false;\n  if (prevProps.index !== nextProps.index) return false;\n  if (prevProps.selectItem !== nextProps.selectItem) return false;\n\n  if (prevProps.highlightedIndex !== nextProps.highlightedIndex) {\n    const wasPrevHighlighed = prevProps.highlightedIndex === prevProps.index;\n    const isNowHighlighted = nextProps.highlightedIndex === nextProps.index;\n\n    return wasPrevHighlighed === isNowHighlighted;\n  }\n\n  return true;\n});\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":435,"column":1,"offset":11829},"end":{"line":569,"column":4,"offset":15388},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Primitive values","position":{"start":{"line":571,"column":5,"offset":15394},"end":{"line":571,"column":21,"offset":15410},"indent":[]}}],"position":{"start":{"line":571,"column":1,"offset":15390},"end":{"line":571,"column":21,"offset":15410},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here we want to reduce the size of the custom comparator by only passing primitive values.","position":{"start":{"line":573,"column":1,"offset":15412},"end":{"line":573,"column":91,"offset":15502},"indent":[]}}],"position":{"start":{"line":573,"column":1,"offset":15412},"end":{"line":573,"column":91,"offset":15502},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Now that we are passing primities, we don't need our custom comparator!","position":{"start":{"line":575,"column":1,"offset":15504},"end":{"line":575,"column":72,"offset":15575},"indent":[]}}],"position":{"start":{"line":575,"column":1,"offset":15504},"end":{"line":575,"column":72,"offset":15575},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          isSelected={selectedItem?.id === item.id}\n          isHighlighted={highlightedIndex === index}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// 🐨 Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isSelected,\n  isHighlighted,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// 🐨 Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":577,"column":1,"offset":15577},"end":{"line":694,"column":4,"offset":18379},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Window Large Lists with react-virtual","position":{"start":{"line":696,"column":4,"offset":18384},"end":{"line":696,"column":41,"offset":18421},"indent":[]}}],"position":{"start":{"line":696,"column":1,"offset":18381},"end":{"line":696,"column":41,"offset":18421},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This updates an incredibly large list to use react-virtual which can make a ","position":{"start":{"line":698,"column":1,"offset":18423},"end":{"line":698,"column":77,"offset":18499},"indent":[]}},{"type":"inlineCode","value":"ul","position":{"start":{"line":698,"column":77,"offset":18499},"end":{"line":698,"column":81,"offset":18503},"indent":[]}},{"type":"text","value":" absolute and then we use a custom styled ","position":{"start":{"line":698,"column":81,"offset":18503},"end":{"line":698,"column":123,"offset":18545},"indent":[]}},{"type":"inlineCode","value":"li","position":{"start":{"line":698,"column":123,"offset":18545},"end":{"line":698,"column":127,"offset":18549},"indent":[]}},{"type":"text","value":" in addition to the list item to provide the items:","position":{"start":{"line":698,"column":127,"offset":18549},"end":{"line":698,"column":178,"offset":18600},"indent":[]}}],"position":{"start":{"line":698,"column":1,"offset":18423},"end":{"line":698,"column":178,"offset":18600},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Window large lists with react-virtual\n// http://localhost:3000/isolated/exercise/04.js\n\nimport * as React from 'react';\n// 🐨 import the useVirtual hook from react-virtual\nimport { useVirtual } from 'react-virtual';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\n// 💰 I made this for you, you'll need it later:\nconst getVirtualRowStyles = ({ size, start }) => ({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: size,\n  transform: `translateY(${start}px)`,\n});\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n  // 🐨 accept listRef, virtualRows, totalHeight\n  listRef,\n  virtualRows,\n  totalHeight,\n}) {\n  return (\n    // 🐨 pass the listRef to the `getMenuProps` prop getter function below:\n    // 💰  getMenuProps({ref: listRef})\n    <ul {...getMenuProps({ ref: listRef })}>\n      {/* 🐨 add a li here with an inline style for the height set to the totalHeight */}\n      <li style={{ height: totalHeight }} />\n      {/*\n        🦉 this is to ensure that the scrollable area of the <ul /> is the\n        same height it would be if we were actually rendering everything\n      */}\n      {/* instead of mapping the \"items\" we're going to map over the virtualRows */}\n      {/* 🐨 swap `items` with `virtualRows` */}\n      {/*\n        💰 a virtual row is an object with the following properties:\n        - index: you can use this to get the `item` via `items[index]`\n        - size: set the \"height\" style to this value\n        - start: this is how many pixels from the scrollTop this item should be\n      */}\n      {virtualRows.map(({ index, size, start }) => {\n        const item = items[index];\n        return (\n          <ListItem\n            key={item.id}\n            getItemProps={getItemProps}\n            item={item}\n            index={index}\n            isSelected={selectedItem?.id === item.id}\n            isHighlighted={highlightedIndex === index}\n            // 🐨 pass a style prop, you can get the inline styles from getVirtualRowStyles()\n            // make sure to pass an object with the size (the height of the row)\n            // and start (where the row starts relative to the scrollTop of its container).\n            style={getVirtualRowStyles({ size, start })}\n          >\n            {item.name}\n          </ListItem>\n        );\n      })}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isHighlighted,\n  isSelected,\n  // 🐨 accept the style prop\n  style,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n          fontWeight: isSelected ? 'bold' : 'normal',\n          // 🐨 spread the incoming styles onto this inline style object\n          ...style,\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: items, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n\n  // 🐨 create a listRef with React.useRef\n  // which will be used for the parentRef option you pass to useVirtual\n  // and should be applied to the <ul /> for our menu. This is how react-virtual\n  // knows how to scroll our items as the user scrolls.\n  const listRef = React.useRef();\n\n  // 🐨 call useVirtual with the following configuration options:\n  // - size (the number of items)\n  // - parentRef (the listRef you created above)\n  // - estimateSize (a memoized callback function that returns the size for each item)\n  //   💰 in our case, every item has the same size, so this will do: React.useCallback(() => 20, [])\n  // - overscan (the number of additional rows to render outside the scrollable view)\n  //   💰 You can play around with that number, but you probably don't need more than 10.\n  // 🐨 you can set the return value of your useVirtual call to `rowVirtualizer`\n  const rowVirtualizer = useVirtual({\n    size: items.length,\n    parentRef: listRef,\n    estimateSize: React.useCallback(() => 20, []),\n    overscan: 10,\n  });\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n    // we want to override Downshift's scrollIntoView functionality because\n    // react-virtual will handle scrolling for us:\n    // 🐨 set scrollIntoView to a \"no-op\" function\n    // 💰 scrollIntoView: () => {},\n    scrollIntoView: () => {},\n    // 🐨 when the highlightedIndex changes, then tell react-virtual to scroll\n    // to that index.\n    // 💰 onHighlightedIndexChange: ({highlightedIndex}) => highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n    onHighlightedIndexChange: ({ highlightedIndex }) =>\n      highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n          // 🐨 pass the following props:\n          listRef={listRef}\n          virtualRows={rowVirtualizer.virtualItems}\n          totalHeight={rowVirtualizer.totalSize}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":700,"column":1,"offset":18602},"end":{"line":890,"column":4,"offset":24860},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Optimize Context Value","position":{"start":{"line":892,"column":4,"offset":24865},"end":{"line":892,"column":26,"offset":24887},"indent":[]}}],"position":{"start":{"line":892,"column":1,"offset":24862},"end":{"line":892,"column":26,"offset":24887},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this challenge, we are memoizing the value we are passing as the value to the Context Provider.","position":{"start":{"line":894,"column":1,"offset":24889},"end":{"line":894,"column":99,"offset":24987},"indent":[]}}],"position":{"start":{"line":894,"column":1,"offset":24889},"end":{"line":894,"column":99,"offset":24987},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"\"The way that context works is that whenever the provided value changes from one render to another, it triggers a re-render of all the consuming components (which will re-render whether or not they’re memoized).\"","position":{"start":{"line":896,"column":3,"offset":24991},"end":{"line":896,"column":215,"offset":25203},"indent":[]}}],"position":{"start":{"line":896,"column":3,"offset":24991},"end":{"line":896,"column":215,"offset":25203},"indent":[]}}],"position":{"start":{"line":896,"column":1,"offset":24989},"end":{"line":896,"column":215,"offset":25203},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A ","position":{"start":{"line":898,"column":1,"offset":25205},"end":{"line":898,"column":3,"offset":25207},"indent":[]}},{"type":"link","title":null,"url":"https://github.com/kentcdodds/kentcdodds.com/blob/319db97260078ea4c263e75166f05e2cea21ccd1/content/blog/how-to-optimize-your-context-value/index.md","children":[{"type":"text","value":"post from Kent","position":{"start":{"line":898,"column":4,"offset":25208},"end":{"line":898,"column":18,"offset":25222},"indent":[]}}],"position":{"start":{"line":898,"column":3,"offset":25207},"end":{"line":898,"column":168,"offset":25372},"indent":[]}},{"type":"text","value":" highlights when it is important to memoize the context value:","position":{"start":{"line":898,"column":168,"offset":25372},"end":{"line":898,"column":230,"offset":25434},"indent":[]}}],"position":{"start":{"line":898,"column":1,"offset":25205},"end":{"line":898,"column":230,"offset":25434},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Your context value changes frequently","position":{"start":{"line":900,"column":4,"offset":25439},"end":{"line":900,"column":41,"offset":25476},"indent":[]}}],"position":{"start":{"line":900,"column":4,"offset":25439},"end":{"line":900,"column":41,"offset":25476},"indent":[]}}],"position":{"start":{"line":900,"column":1,"offset":25436},"end":{"line":900,"column":41,"offset":25476},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Your context has many consumers","position":{"start":{"line":901,"column":4,"offset":25480},"end":{"line":901,"column":35,"offset":25511},"indent":[]}}],"position":{"start":{"line":901,"column":4,"offset":25480},"end":{"line":901,"column":35,"offset":25511},"indent":[]}}],"position":{"start":{"line":901,"column":1,"offset":25477},"end":{"line":901,"column":35,"offset":25511},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"You are bothering to use React.memo (because things are legit slow)","position":{"start":{"line":902,"column":4,"offset":25515},"end":{"line":902,"column":71,"offset":25582},"indent":[]}}],"position":{"start":{"line":902,"column":4,"offset":25515},"end":{"line":902,"column":71,"offset":25582},"indent":[]}}],"position":{"start":{"line":902,"column":1,"offset":25512},"end":{"line":902,"column":71,"offset":25582},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"You've actually measured things and you know it's slow and needs to be optimized","position":{"start":{"line":903,"column":4,"offset":25586},"end":{"line":903,"column":84,"offset":25666},"indent":[]}}],"position":{"start":{"line":903,"column":4,"offset":25586},"end":{"line":903,"column":84,"offset":25666},"indent":[]}}],"position":{"start":{"line":903,"column":1,"offset":25583},"end":{"line":903,"column":84,"offset":25666},"indent":[]}}],"position":{"start":{"line":900,"column":1,"offset":25436},"end":{"line":903,"column":84,"offset":25666},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"In the example given, we needed to ensure the provider was memoized so that the lower children were helped when ","position":{"start":{"line":905,"column":1,"offset":25668},"end":{"line":905,"column":113,"offset":25780},"indent":[]}},{"type":"inlineCode","value":"App","position":{"start":{"line":905,"column":113,"offset":25780},"end":{"line":905,"column":118,"offset":25785},"indent":[]}},{"type":"text","value":" was force re-rendered:","position":{"start":{"line":905,"column":118,"offset":25785},"end":{"line":905,"column":141,"offset":25808},"indent":[]}}],"position":{"start":{"line":905,"column":1,"offset":25668},"end":{"line":905,"column":141,"offset":25808},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n  // 🐨 memoize this value with React.useMemo\n  const value = React.useMemo(() => [state, dispatch], [state, dispatch]);\n  // const value = [state, dispatch]\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const [, dispatch] = useAppState();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const [state, dispatch] = useAppState();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":907,"column":1,"offset":25810},"end":{"line":1046,"column":4,"offset":29167},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The results can be seen in these screenshots:","position":{"start":{"line":1048,"column":1,"offset":29169},"end":{"line":1048,"column":46,"offset":29214},"indent":[]}}],"position":{"start":{"line":1048,"column":1,"offset":29169},"end":{"line":1048,"column":46,"offset":29214},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"./force-rerender-without-memoization.png","alt":"Force rerender without memoization","position":{"start":{"line":1050,"column":1,"offset":29216},"end":{"line":1050,"column":80,"offset":29295},"indent":[]}}],"position":{"start":{"line":1050,"column":1,"offset":29216},"end":{"line":1050,"column":80,"offset":29295},"indent":[]}},{"type":"paragraph","children":[{"type":"image","title":null,"url":"./force-rerender-with-memoization.png","alt":"Force rerender with memoization","position":{"start":{"line":1052,"column":1,"offset":29297},"end":{"line":1052,"column":74,"offset":29370},"indent":[]}}],"position":{"start":{"line":1052,"column":1,"offset":29297},"end":{"line":1052,"column":74,"offset":29370},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Separate the contexts","position":{"start":{"line":1054,"column":5,"offset":29376},"end":{"line":1054,"column":26,"offset":29397},"indent":[]}}],"position":{"start":{"line":1054,"column":1,"offset":29372},"end":{"line":1054,"column":26,"offset":29397},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Another issue we run into is that when we click on a grid item, our state is updating. Because the state \"did update\", we are getting a new array in the memoised ","position":{"start":{"line":1056,"column":1,"offset":29399},"end":{"line":1056,"column":163,"offset":29561},"indent":[]}},{"type":"inlineCode","value":"AppProvider","position":{"start":{"line":1056,"column":163,"offset":29561},"end":{"line":1056,"column":176,"offset":29574},"indent":[]}},{"type":"text","value":" and therefore this change is re-rendering everything that consumes the state (even though the ","position":{"start":{"line":1056,"column":176,"offset":29574},"end":{"line":1056,"column":271,"offset":29669},"indent":[]}},{"type":"inlineCode","value":"Grid","position":{"start":{"line":1056,"column":271,"offset":29669},"end":{"line":1056,"column":277,"offset":29675},"indent":[]}},{"type":"text","value":" only needs to consume the dispatch!)","position":{"start":{"line":1056,"column":277,"offset":29675},"end":{"line":1056,"column":314,"offset":29712},"indent":[]}}],"position":{"start":{"line":1056,"column":1,"offset":29399},"end":{"line":1056,"column":314,"offset":29712},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":1058,"column":1,"offset":29714},"end":{"line":1208,"column":4,"offset":33307},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Note: at the end of this challenge on production, we'll see that we didn't make ","position":{"start":{"line":1210,"column":3,"offset":33311},"end":{"line":1210,"column":83,"offset":33391},"indent":[]}},{"type":"emphasis","children":[{"type":"text","value":"huge changes","position":{"start":{"line":1210,"column":84,"offset":33392},"end":{"line":1210,"column":96,"offset":33404},"indent":[]}}],"position":{"start":{"line":1210,"column":83,"offset":33391},"end":{"line":1210,"column":97,"offset":33405},"indent":[]}},{"type":"text","value":" to the timing.","position":{"start":{"line":1210,"column":97,"offset":33405},"end":{"line":1210,"column":112,"offset":33420},"indent":[]}}],"position":{"start":{"line":1210,"column":3,"offset":33311},"end":{"line":1210,"column":112,"offset":33420},"indent":[]}}],"position":{"start":{"line":1210,"column":1,"offset":33309},"end":{"line":1210,"column":112,"offset":33420},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Fix Perf Deatch by a Thousand Cuts","position":{"start":{"line":1212,"column":4,"offset":33425},"end":{"line":1212,"column":38,"offset":33459},"indent":[]}}],"position":{"start":{"line":1212,"column":1,"offset":33422},"end":{"line":1212,"column":38,"offset":33459},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this example, we had to fix an input that was operating horrifically slow. The reason we come to find is related to a requirement of state colocation with the component.","position":{"start":{"line":1214,"column":1,"offset":33461},"end":{"line":1214,"column":173,"offset":33633},"indent":[]}}],"position":{"start":{"line":1214,"column":1,"offset":33461},"end":{"line":1214,"column":173,"offset":33633},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It is important NOT to just add everything to the state context willy nilly. There are a lot of Performance implications with this.","position":{"start":{"line":1216,"column":1,"offset":33635},"end":{"line":1216,"column":132,"offset":33766},"indent":[]}}],"position":{"start":{"line":1216,"column":1,"offset":33635},"end":{"line":1216,"column":132,"offset":33766},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Fix \"perf death by a thousand cuts\"\n// http://localhost:3000/isolated/exercise/06.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nAppStateContext.displayName = 'AppStateContext';\nconst AppDispatchContext = React.createContext();\nAppDispatchContext.displayName = 'AppDispatchContext';\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    // we're no longer managing the dogName state in our reducer\n    // 💣 remove this case\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // 🐨 replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [dogName, setDogName] = React.useState('');\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    setDogName(newDogName);\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":1218,"column":1,"offset":33768},"end":{"line":1369,"column":4,"offset":37603},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Separate Contexts","position":{"start":{"line":1371,"column":5,"offset":37609},"end":{"line":1371,"column":22,"offset":37626},"indent":[]}}],"position":{"start":{"line":1371,"column":1,"offset":37605},"end":{"line":1371,"column":22,"offset":37626},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This solution is about going for a different approach. The approach here is to handle when things are global. We can separate context out for different domains.","position":{"start":{"line":1373,"column":1,"offset":37628},"end":{"line":1373,"column":161,"offset":37788},"indent":[]}}],"position":{"start":{"line":1373,"column":1,"offset":37628},"end":{"line":1373,"column":161,"offset":37788},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"It is really important to also measure after to see if you've made serious Performance improvements and not just added complexity.","position":{"start":{"line":1375,"column":3,"offset":37792},"end":{"line":1375,"column":133,"offset":37922},"indent":[]}}],"position":{"start":{"line":1375,"column":3,"offset":37792},"end":{"line":1375,"column":133,"offset":37922},"indent":[]}}],"position":{"start":{"line":1375,"column":1,"offset":37790},"end":{"line":1375,"column":133,"offset":37922},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"import * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\nconst DogContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction dogReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction DogProvider(props) {\n  const [state, dispatch] = React.useReducer(dogReducer, {\n    dogName: '',\n  });\n\n  const value = [state, dispatch];\n\n  return <DogProvider value={value} {...props} />;\n}\n\nfunction useDogContext() {\n  const context = React.useContext(DogContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // 🐨 replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [state, dispatch] = useDogContext();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    // 🐨 change this to call your state setter that you get from useState\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogProvider>\n            <DogNameInput />\n          </DogProvider>\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":1377,"column":1,"offset":37924},"end":{"line":1552,"column":4,"offset":42253},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Note: Because the ","position":{"start":{"line":1554,"column":3,"offset":42257},"end":{"line":1554,"column":21,"offset":42275},"indent":[]}},{"type":"inlineCode","value":"AppProvider","position":{"start":{"line":1554,"column":21,"offset":42275},"end":{"line":1554,"column":34,"offset":42288},"indent":[]}},{"type":"text","value":" not longer impacts anything other than the grid, we can also change the Providers to focus more where is matters:","position":{"start":{"line":1554,"column":34,"offset":42288},"end":{"line":1554,"column":148,"offset":42402},"indent":[]}}],"position":{"start":{"line":1554,"column":3,"offset":42257},"end":{"line":1554,"column":148,"offset":42402},"indent":[]}}],"position":{"start":{"line":1554,"column":1,"offset":42255},"end":{"line":1554,"column":148,"offset":42402},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"function App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <DogProvider>\n          <DogNameInput />\n        </DogProvider>\n        <AppProvider>\n          <Grid />\n        </AppProvider>\n      </div>\n    </div>\n  );\n}","position":{"start":{"line":1556,"column":1,"offset":42404},"end":{"line":1573,"column":4,"offset":42757},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Consuming Components","position":{"start":{"line":1575,"column":5,"offset":42763},"end":{"line":1575,"column":25,"offset":42783},"indent":[]}}],"position":{"start":{"line":1575,"column":1,"offset":42759},"end":{"line":1575,"column":25,"offset":42783},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If we check our profiling after the changes that we made above, we will see that when we click a button, there are still all these smaller re-renderings that are happening.","position":{"start":{"line":1577,"column":1,"offset":42785},"end":{"line":1577,"column":173,"offset":42957},"indent":[]}}],"position":{"start":{"line":1577,"column":1,"offset":42785},"end":{"line":1577,"column":173,"offset":42957},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this particular scenario, it is the ","position":{"start":{"line":1579,"column":1,"offset":42959},"end":{"line":1579,"column":40,"offset":42998},"indent":[]}},{"type":"inlineCode","value":"const cell = state.grid[row][column]","position":{"start":{"line":1579,"column":40,"offset":42998},"end":{"line":1579,"column":78,"offset":43036},"indent":[]}},{"type":"text","value":" line that we want to take out from the cell and calculate prior.","position":{"start":{"line":1579,"column":78,"offset":43036},"end":{"line":1579,"column":143,"offset":43101},"indent":[]}}],"position":{"start":{"line":1579,"column":1,"offset":42959},"end":{"line":1579,"column":143,"offset":43101},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// This is like a \"man-in-middle\" that cares about state and can take that,\n// pass it down and then the rendering of the CellImpl can take advantage of memoisation\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  return <CellImpl cell={cell} row={row} column={column} />;\n}\nCell = React.memo(Cell);\n\nfunction CellImpl({ cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCellImpl = React.memo(CellImpl);","position":{"start":{"line":1581,"column":1,"offset":43103},"end":{"line":1608,"column":4,"offset":43917},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Slice of App State","position":{"start":{"line":1610,"column":5,"offset":43923},"end":{"line":1610,"column":23,"offset":43941},"indent":[]}}],"position":{"start":{"line":1610,"column":1,"offset":43919},"end":{"line":1610,"column":23,"offset":43941},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"\"I'm not super jazzed about making an intermediary component\". Instead, we can make a higher-order component to take care of it for us instead.","position":{"start":{"line":1612,"column":1,"offset":43943},"end":{"line":1612,"column":144,"offset":44086},"indent":[]}}],"position":{"start":{"line":1612,"column":1,"offset":43943},"end":{"line":1612,"column":144,"offset":44086},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"function withStateSlice(Comp, slice) {\n  const MemoComp = React.memo(Comp);\n  function Wrapper(props, ref) {\n    const state = useAppState();\n    return <MemoComp ref={ref} state={slice(state, props)} {...props} />;\n  }\n  Wrapper.displayName = `withStateSlice${Comp.dispayName || Comp.name}`;\n  return React.memo(React.forwardRef(Wrapper));\n}\n\nfunction Cell({ state: cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = withStateSlice(\n  Cell,\n  (state, { row, column }) => state.grid[row][column],\n);","position":{"start":{"line":1614,"column":1,"offset":44088},"end":{"line":1645,"column":4,"offset":44947},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Use Recoil","position":{"start":{"line":1647,"column":5,"offset":44953},"end":{"line":1647,"column":15,"offset":44963},"indent":[]}}],"position":{"start":{"line":1647,"column":1,"offset":44949},"end":{"line":1647,"column":15,"offset":44963},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"For the specific problem we have with the massive grid (if we want to use something like that), we can use Recoil to resolve the problems that we run into.","position":{"start":{"line":1649,"column":1,"offset":44965},"end":{"line":1649,"column":156,"offset":45120},"indent":[]}}],"position":{"start":{"line":1649,"column":1,"offset":44965},"end":{"line":1649,"column":156,"offset":45120},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It is worth noting that there is a complexity cost for using Recoil, but in our specific usecase, it is something that Recoil was built to solve:","position":{"start":{"line":1651,"column":1,"offset":45122},"end":{"line":1651,"column":146,"offset":45267},"indent":[]}}],"position":{"start":{"line":1651,"column":1,"offset":45122},"end":{"line":1651,"column":146,"offset":45267},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Starting point for the Recoil Extra Credit\n// 💯 use recoil (exercise)\n// http://localhost:3000/isolated/exercise/06.extra-4.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n// 🐨 you're gonna need these:\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilCallback,\n  atomFamily,\n} from 'recoil';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\n// 🐨 create an atomFamily called `cellAtoms` here where the\n// default callback function accepts an object with the\n// `row` and `column` and returns the value from the initialGrid\n// 💰 initialGrid[row][column]\nconst cellAtoms = atomFamily({\n  key: 'cells',\n  default: () => ({ row, column }) => initialGrid[row][column],\n});\n\n// 💰 I'm going to give this hook to you as it's mostly here for our contrived\n// example purposes. Just comment this in when you're ready to use it.\n// Here's how it's used:\n// const updateGrid = useUpdateGrid()\n// then later: updateGrid({rows, columns})\nfunction useUpdateGrid() {\n  return useRecoilCallback(({ set }) => ({ rows, columns }) => {\n    for (let row = 0; row < rows; row++) {\n      for (let column = 0; column < columns; column++) {\n        if (Math.random() > 0.7) {\n          set(cellAtoms({ row, column }), Math.random() * 100);\n        }\n      }\n    }\n  });\n}\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n  });\n  // 🦉 notice that we don't even need to bother memoizing this value\n  const value = [state, dispatch];\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  // 🐨 we're no longer storing the grid in our app state, so instead you\n  // want to get the updateGrid function from useUpdateGrid\n  const updateGrid = useUpdateGrid();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => updateGrid({ rows, columns });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\n\nfunction Cell({ row, column }) {\n  const [cell, setCell] = useRecoilState(cellAtoms({ row, column }));\n  const handleClick = () => setCell(Math.random() * 100);\n\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <RecoilRoot>\n        <AppProvider>\n          <div>\n            <DogNameInput />\n            <Grid />\n          </div>\n        </AppProvider>\n      </RecoilRoot>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":1653,"column":1,"offset":45269},"end":{"line":1819,"column":4,"offset":49529},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Read more on ","position":{"start":{"line":1821,"column":1,"offset":49531},"end":{"line":1821,"column":14,"offset":49544},"indent":[]}},{"type":"link","title":null,"url":"https://recoiljs.org/docs/introduction/motivation","children":[{"type":"text","value":"Recoil","position":{"start":{"line":1821,"column":15,"offset":49545},"end":{"line":1821,"column":21,"offset":49551},"indent":[]}}],"position":{"start":{"line":1821,"column":14,"offset":49544},"end":{"line":1821,"column":73,"offset":49603},"indent":[]}},{"type":"text","value":" from their docs.","position":{"start":{"line":1821,"column":73,"offset":49603},"end":{"line":1821,"column":90,"offset":49620},"indent":[]}}],"position":{"start":{"line":1821,"column":1,"offset":49531},"end":{"line":1821,"column":90,"offset":49620},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Production Performance Monitoring","position":{"start":{"line":1823,"column":4,"offset":49625},"end":{"line":1823,"column":37,"offset":49658},"indent":[]}}],"position":{"start":{"line":1823,"column":1,"offset":49622},"end":{"line":1823,"column":37,"offset":49658},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A great way to prevent changes from regressions, we can use production performance monitoring.","position":{"start":{"line":1825,"column":1,"offset":49660},"end":{"line":1825,"column":95,"offset":49754},"indent":[]}}],"position":{"start":{"line":1825,"column":1,"offset":49660},"end":{"line":1825,"column":95,"offset":49754},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Note: There is a small performance cost involved with profiling. Facebook A/B serves a version with profiling involved.","position":{"start":{"line":1827,"column":3,"offset":49758},"end":{"line":1827,"column":122,"offset":49877},"indent":[]}}],"position":{"start":{"line":1827,"column":3,"offset":49758},"end":{"line":1827,"column":122,"offset":49877},"indent":[]}}],"position":{"start":{"line":1827,"column":1,"offset":49756},"end":{"line":1827,"column":122,"offset":49877},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This exercise looks at using the ","position":{"start":{"line":1829,"column":1,"offset":49879},"end":{"line":1829,"column":34,"offset":49912},"indent":[]}},{"type":"link","title":null,"url":"https://reactjs.org/docs/profiler.html","children":[{"type":"text","value":"React Profiler API","position":{"start":{"line":1829,"column":35,"offset":49913},"end":{"line":1829,"column":53,"offset":49931},"indent":[]}}],"position":{"start":{"line":1829,"column":34,"offset":49912},"end":{"line":1829,"column":94,"offset":49972},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":1829,"column":94,"offset":49972},"end":{"line":1829,"column":95,"offset":49973},"indent":[]}}],"position":{"start":{"line":1829,"column":1,"offset":49879},"end":{"line":1829,"column":95,"offset":49973},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The usage and callback:","position":{"start":{"line":1831,"column":1,"offset":49975},"end":{"line":1831,"column":24,"offset":49998},"indent":[]}}],"position":{"start":{"line":1831,"column":1,"offset":49975},"end":{"line":1831,"column":24,"offset":49998},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"<App>\n  <Profiler id=\"Navigation\" onRender={onRenderCallback}>\n    <Navigation {...props} />\n  </Profiler>\n  <Main {...props} />\n</App>;\n\n// callback\nfunction onRenderCallback(\n  id, // the \"id\" prop of the Profiler tree that has just committed\n  phase, // either \"mount\" (if the tree just mounted) or \"update\" (if it re-rendered)\n  actualDuration, // time spent rendering the committed update\n  baseDuration, // estimated time to render the entire subtree without memoization\n  startTime, // when React began rendering this update\n  commitTime, // when React committed this update\n  interactions, // the Set of interactions belonging to this update\n) {\n  // Aggregate or log render timings...\n}","position":{"start":{"line":1833,"column":1,"offset":50000},"end":{"line":1853,"column":4,"offset":50705},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"\"It’s important to note that unless you build your app using react-dom/profiling and scheduler/tracing-profiling this component won’t do anything.\"","position":{"start":{"line":1855,"column":3,"offset":50709},"end":{"line":1855,"column":150,"offset":50856},"indent":[]}}],"position":{"start":{"line":1855,"column":3,"offset":50709},"end":{"line":1855,"column":150,"offset":50856},"indent":[]}}],"position":{"start":{"line":1855,"column":1,"offset":50707},"end":{"line":1855,"column":150,"offset":50856},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Kent also has a ","position":{"start":{"line":1857,"column":1,"offset":50858},"end":{"line":1857,"column":17,"offset":50874},"indent":[]}},{"type":"link","title":null,"url":"https://kentcdodds.com/blog/react-production-performance-monitoring/","children":[{"type":"text","value":"blog post","position":{"start":{"line":1857,"column":18,"offset":50875},"end":{"line":1857,"column":27,"offset":50884},"indent":[]}}],"position":{"start":{"line":1857,"column":17,"offset":50874},"end":{"line":1857,"column":98,"offset":50955},"indent":[]}},{"type":"text","value":" on the profiling.","position":{"start":{"line":1857,"column":98,"offset":50955},"end":{"line":1857,"column":116,"offset":50973},"indent":[]}}],"position":{"start":{"line":1857,"column":1,"offset":50858},"end":{"line":1857,"column":116,"offset":50973},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The solution to record one:","position":{"start":{"line":1859,"column":1,"offset":50975},"end":{"line":1859,"column":28,"offset":51002},"indent":[]}}],"position":{"start":{"line":1859,"column":1,"offset":50975},"end":{"line":1859,"column":28,"offset":51002},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"// Production performance monitoring\n// http://localhost:3000/isolated/exercise/07.js\n\nimport * as React from 'react';\n// 🐨 you're going to need the reportProfile function\n// 💰 here, let me help you with that..\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      🐨 Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":1861,"column":1,"offset":51004},"end":{"line":1899,"column":4,"offset":51918},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Tracing API","position":{"start":{"line":1901,"column":5,"offset":51924},"end":{"line":1901,"column":16,"offset":51935},"indent":[]}}],"position":{"start":{"line":1901,"column":1,"offset":51920},"end":{"line":1901,"column":16,"offset":51935},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"So we don't know \"why\" the user caused the rerendering so we can use an ","position":{"start":{"line":1903,"column":1,"offset":51937},"end":{"line":1903,"column":73,"offset":52009},"indent":[]}},{"type":"inlineCode","value":"unstable_trace","position":{"start":{"line":1903,"column":73,"offset":52009},"end":{"line":1903,"column":89,"offset":52025},"indent":[]}},{"type":"text","value":" to check.","position":{"start":{"line":1903,"column":89,"offset":52025},"end":{"line":1903,"column":99,"offset":52035},"indent":[]}}],"position":{"start":{"line":1903,"column":1,"offset":51937},"end":{"line":1903,"column":99,"offset":52035},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"import * as React from 'react';\nimport { unstable_trace as trace } from 'scheduler/tracing';\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  // We can wrap the setCount callback to use the trace API\n  const increment = trace('click', performance.now(), () =>\n    setCount(c => c + 1),\n  );\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      🐨 Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;","position":{"start":{"line":1905,"column":1,"offset":52037},"end":{"line":1942,"column":4,"offset":52934},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"That is it! Now when the user clicks, we can get more information thanks to the trace that comes under the ","position":{"start":{"line":1944,"column":1,"offset":52936},"end":{"line":1944,"column":108,"offset":53043},"indent":[]}},{"type":"inlineCode","value":"interactions","position":{"start":{"line":1944,"column":108,"offset":53043},"end":{"line":1944,"column":122,"offset":53057},"indent":[]}},{"type":"text","value":" value.","position":{"start":{"line":1944,"column":122,"offset":53057},"end":{"line":1944,"column":129,"offset":53064},"indent":[]}}],"position":{"start":{"line":1944,"column":1,"offset":52936},"end":{"line":1944,"column":129,"offset":53064},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"With the ","position":{"start":{"line":1946,"column":1,"offset":53066},"end":{"line":1946,"column":10,"offset":53075},"indent":[]}},{"type":"inlineCode","value":"trace","position":{"start":{"line":1946,"column":10,"offset":53075},"end":{"line":1946,"column":17,"offset":53082},"indent":[]}},{"type":"text","value":" API, we can also start to use the ","position":{"start":{"line":1946,"column":17,"offset":53082},"end":{"line":1946,"column":52,"offset":53117},"indent":[]}},{"type":"inlineCode","value":"user interactions","position":{"start":{"line":1946,"column":52,"offset":53117},"end":{"line":1946,"column":71,"offset":53136},"indent":[]}},{"type":"text","value":" section of the React profile!","position":{"start":{"line":1946,"column":71,"offset":53136},"end":{"line":1946,"column":101,"offset":53166},"indent":[]}}],"position":{"start":{"line":1946,"column":1,"offset":53066},"end":{"line":1946,"column":101,"offset":53166},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":1949,"column":1,"offset":53169},"end":{"line":1949,"column":31,"offset":53199},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":1949,"column":31,"offset":53199}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"react-performance\"\n    }}>{`React Performance`}</h1>\n    <p>{`React in general is fast. That being said, there are tools to help aid us when we need those tools to help optimize particular scenarios.`}</p>\n    <p>{`What is important is to know what tool to grab at the appropriate time.`}</p>\n    <h2 {...{\n      \"id\": \"code-splitting\"\n    }}>{`Code Splitting`}</h2>\n    <p>{`The single, biggest impact you can have on your performance. It will help lazily load code when required.`}</p>\n    <p>{`In this first example, we simple used `}<inlineCode parentName=\"p\">{`React.lazy`}</inlineCode>{` to lazy import a file and then used the `}<inlineCode parentName=\"p\">{`Suspense`}</inlineCode>{` library to handle the fallback.`}</p>\n    <p>{`What is important to do to test and see the visual changes:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Check the network tab`}</li>\n      <li parentName=\"ol\">{`Check the coverage tab`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// 💣 remove this import\n\n// 🐨 use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(() => import('../globe'));\n\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // 🐨 wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // 💰 try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// 🦉 Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"eager-loading\"\n    }}>{`Eager Loading`}</h3>\n    <p>{`Given a certain \"indication\" that a user may click, we can load earlier.`}</p>\n    <p>{`We can enter a `}<inlineCode parentName=\"p\">{`onMouseEnter`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`onFocus`}</inlineCode>{` to fire an eager import:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// 💣 remove this import\n\nconst loadGlobe = () => import('../globe');\n// 🐨 use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(loadGlobe);\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // 🐨 wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // 💰 try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n          onMouseEnter={loadGlobe}\n          onFocus={loadGlobe}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// 🦉 Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"webpack-magic-comments\"\n    }}>{`Webpack Magic Comments`}</h3>\n    <p>{`A comment like the following will allow you to start pre-fetching some other resources. Webpack has an API for you to hook into.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import(/* webpackPrefetch: true */ './some-module.js');\n`}</code></pre>\n    <p>{`You can confirm this prefetch work based on what shows in the elements tab under the `}<inlineCode parentName=\"p\">{`head`}</inlineCode>{` tag to see the prefetch links have been added.`}</p>\n    <h3 {...{\n      \"id\": \"suspense-position\"\n    }}>{`Suspense Position`}</h3>\n    <p>{`In future React, there will be some implications for React Suspense for when it is mounted as opposed to updated.`}</p>\n    <p>{`It is also very important for the position of your Suspense tool to be correct.`}</p>\n    <p>{`There is also the capability to click a button to \"suspend\" the component and see what is looks like from the React DevTools.`}</p>\n    <h3 {...{\n      \"id\": \"understanding-the-coverage-report\"\n    }}>{`Understanding the coverage report`}</h3>\n    <p>{`When you check the coverage of the before and after, you see there are less files in the after and a significant amount of savings.`}</p>\n    <p>{`Clicking on the individual files also shows you chunks with lines that have and have not been used.`}</p>\n    <h2 {...{\n      \"id\": \"usememo\"\n    }}>{`useMemo`}</h2>\n    <p><inlineCode parentName=\"p\">{`useMemo`}</inlineCode>{` is the hero you need for expensive calculations and how the API works.`}</p>\n    <p>{`The example shows a massive list that should not recalculate with the same input value:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// useMemo for expensive calculations\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../filter-cities';\nimport { useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  // 🐨 wrap getItems in a call to \\`React.useMemo\\`\n  const allItems = React.useMemo(() => getItems(inputValue), [inputValue]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"using-a-web-worker\"\n    }}>{`Using a Web Worker`}</h3>\n    <p>{`There is information about this more `}<a parentName=\"p\" {...{\n        \"href\": \"https://kentcdodds.com/blog/speed-up-your-app-with-web-workers\"\n      }}>{`on Kent's blog`}</a>{`.`}</p>\n    <p>{`There is a `}<inlineCode parentName=\"p\">{`workerize`}</inlineCode>{` Webpack loader that can be used with Webpack that helps this process.`}</p>\n    <h2 {...{\n      \"id\": \"reactmemo\"\n    }}>{`React.memo`}</h2>\n    <p>{`The lifecycle of a React app goes `}<inlineCode parentName=\"p\">{`render -> reconciliation -> commit -> state change -> repeat`}</inlineCode>{`.`}</p>\n    <p>{`React is fast at doing this, but sometimes it needs help for Performance.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: you should fix slow renders before you fix re-renders.`}</p>\n    </blockquote>\n    <p>{`In the React DevTools profile, you can shift through each \"commit\" on the top \"bar chart\". We can rectify some of these issues using `}<inlineCode parentName=\"p\">{`pureComponent`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`memo`}</inlineCode>{`.`}</p>\n    <p>{`We seriously improved the experience with this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// 🐨 Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// 🐨 Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"custom-comparator\"\n    }}>{`Custom Comparator`}</h3>\n    <p>{`We can create a custom comparator to define when we should re-render.`}</p>\n    <p>{`In the above, you may notice that highlighting a component is forcing all items to re-render.`}</p>\n    <p>{`We can get around this using a custom comparator in `}<inlineCode parentName=\"p\">{`React.memo`}</inlineCode>{` as the second argument for the `}<inlineCode parentName=\"p\">{`ListItem`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// 🐨 Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// 🐨 Memoize the ListItem here using React.memo and use Domain Specific Knowledge\n// to help React know when it should trigger a re-render.\nListItem = React.memo(ListItem, (prevProps, nextProps) => {\n  if (prevProps.getItemProps !== nextProps.getItemProps) return false;\n  if (prevProps.items !== nextProps.items) return false;\n  if (prevProps.index !== nextProps.index) return false;\n  if (prevProps.selectItem !== nextProps.selectItem) return false;\n\n  if (prevProps.highlightedIndex !== nextProps.highlightedIndex) {\n    const wasPrevHighlighed = prevProps.highlightedIndex === prevProps.index;\n    const isNowHighlighted = nextProps.highlightedIndex === nextProps.index;\n\n    return wasPrevHighlighed === isNowHighlighted;\n  }\n\n  return true;\n});\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"primitive-values\"\n    }}>{`Primitive values`}</h3>\n    <p>{`Here we want to reduce the size of the custom comparator by only passing primitive values.`}</p>\n    <p>{`Now that we are passing primities, we don't need our custom comparator!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          isSelected={selectedItem?.id === item.id}\n          isHighlighted={highlightedIndex === index}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// 🐨 Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isSelected,\n  isHighlighted,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// 🐨 Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"window-large-lists-with-react-virtual\"\n    }}>{`Window Large Lists with react-virtual`}</h2>\n    <p>{`This updates an incredibly large list to use react-virtual which can make a `}<inlineCode parentName=\"p\">{`ul`}</inlineCode>{` absolute and then we use a custom styled `}<inlineCode parentName=\"p\">{`li`}</inlineCode>{` in addition to the list item to provide the items:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Window large lists with react-virtual\n// http://localhost:3000/isolated/exercise/04.js\n\nimport * as React from 'react';\n// 🐨 import the useVirtual hook from react-virtual\nimport { useVirtual } from 'react-virtual';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\n// 💰 I made this for you, you'll need it later:\nconst getVirtualRowStyles = ({ size, start }) => ({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: size,\n  transform: \\`translateY(\\${start}px)\\`,\n});\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n  // 🐨 accept listRef, virtualRows, totalHeight\n  listRef,\n  virtualRows,\n  totalHeight,\n}) {\n  return (\n    // 🐨 pass the listRef to the \\`getMenuProps\\` prop getter function below:\n    // 💰  getMenuProps({ref: listRef})\n    <ul {...getMenuProps({ ref: listRef })}>\n      {/* 🐨 add a li here with an inline style for the height set to the totalHeight */}\n      <li style={{ height: totalHeight }} />\n      {/*\n        🦉 this is to ensure that the scrollable area of the <ul /> is the\n        same height it would be if we were actually rendering everything\n      */}\n      {/* instead of mapping the \"items\" we're going to map over the virtualRows */}\n      {/* 🐨 swap \\`items\\` with \\`virtualRows\\` */}\n      {/*\n        💰 a virtual row is an object with the following properties:\n        - index: you can use this to get the \\`item\\` via \\`items[index]\\`\n        - size: set the \"height\" style to this value\n        - start: this is how many pixels from the scrollTop this item should be\n      */}\n      {virtualRows.map(({ index, size, start }) => {\n        const item = items[index];\n        return (\n          <ListItem\n            key={item.id}\n            getItemProps={getItemProps}\n            item={item}\n            index={index}\n            isSelected={selectedItem?.id === item.id}\n            isHighlighted={highlightedIndex === index}\n            // 🐨 pass a style prop, you can get the inline styles from getVirtualRowStyles()\n            // make sure to pass an object with the size (the height of the row)\n            // and start (where the row starts relative to the scrollTop of its container).\n            style={getVirtualRowStyles({ size, start })}\n          >\n            {item.name}\n          </ListItem>\n        );\n      })}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isHighlighted,\n  isSelected,\n  // 🐨 accept the style prop\n  style,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n          fontWeight: isSelected ? 'bold' : 'normal',\n          // 🐨 spread the incoming styles onto this inline style object\n          ...style,\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: items, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n\n  // 🐨 create a listRef with React.useRef\n  // which will be used for the parentRef option you pass to useVirtual\n  // and should be applied to the <ul /> for our menu. This is how react-virtual\n  // knows how to scroll our items as the user scrolls.\n  const listRef = React.useRef();\n\n  // 🐨 call useVirtual with the following configuration options:\n  // - size (the number of items)\n  // - parentRef (the listRef you created above)\n  // - estimateSize (a memoized callback function that returns the size for each item)\n  //   💰 in our case, every item has the same size, so this will do: React.useCallback(() => 20, [])\n  // - overscan (the number of additional rows to render outside the scrollable view)\n  //   💰 You can play around with that number, but you probably don't need more than 10.\n  // 🐨 you can set the return value of your useVirtual call to \\`rowVirtualizer\\`\n  const rowVirtualizer = useVirtual({\n    size: items.length,\n    parentRef: listRef,\n    estimateSize: React.useCallback(() => 20, []),\n    overscan: 10,\n  });\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? \\`You selected \\${selectedItem.name}\\`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n    // we want to override Downshift's scrollIntoView functionality because\n    // react-virtual will handle scrolling for us:\n    // 🐨 set scrollIntoView to a \"no-op\" function\n    // 💰 scrollIntoView: () => {},\n    scrollIntoView: () => {},\n    // 🐨 when the highlightedIndex changes, then tell react-virtual to scroll\n    // to that index.\n    // 💰 onHighlightedIndexChange: ({highlightedIndex}) => highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n    onHighlightedIndexChange: ({ highlightedIndex }) =>\n      highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n          // 🐨 pass the following props:\n          listRef={listRef}\n          virtualRows={rowVirtualizer.virtualItems}\n          totalHeight={rowVirtualizer.totalSize}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"optimize-context-value\"\n    }}>{`Optimize Context Value`}</h2>\n    <p>{`In this challenge, we are memoizing the value we are passing as the value to the Context Provider.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`\"The way that context works is that whenever the provided value changes from one render to another, it triggers a re-render of all the consuming components (which will re-render whether or not they’re memoized).\"`}</p>\n    </blockquote>\n    <p>{`A `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/kentcdodds/kentcdodds.com/blob/319db97260078ea4c263e75166f05e2cea21ccd1/content/blog/how-to-optimize-your-context-value/index.md\"\n      }}>{`post from Kent`}</a>{` highlights when it is important to memoize the context value:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Your context value changes frequently`}</li>\n      <li parentName=\"ol\">{`Your context has many consumers`}</li>\n      <li parentName=\"ol\">{`You are bothering to use React.memo (because things are legit slow)`}</li>\n      <li parentName=\"ol\">{`You've actually measured things and you know it's slow and needs to be optimized`}</li>\n    </ol>\n    <p>{`In the example given, we needed to ensure the provider was memoized so that the lower children were helped when `}<inlineCode parentName=\"p\">{`App`}</inlineCode>{` was force re-rendered:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n  // 🐨 memoize this value with React.useMemo\n  const value = React.useMemo(() => [state, dispatch], [state, dispatch]);\n  // const value = [state, dispatch]\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const [, dispatch] = useAppState();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const [state, dispatch] = useAppState();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <p>{`The results can be seen in these screenshots:`}</p>\n    <p><img alt=\"Force rerender without memoization\" src={require(\"./force-rerender-without-memoization.png\")} /></p>\n    <p><img alt=\"Force rerender with memoization\" src={require(\"./force-rerender-with-memoization.png\")} /></p>\n    <h3 {...{\n      \"id\": \"separate-the-contexts\"\n    }}>{`Separate the contexts`}</h3>\n    <p>{`Another issue we run into is that when we click on a grid item, our state is updating. Because the state \"did update\", we are getting a new array in the memoised `}<inlineCode parentName=\"p\">{`AppProvider`}</inlineCode>{` and therefore this change is re-rendering everything that consumes the state (even though the `}<inlineCode parentName=\"p\">{`Grid`}</inlineCode>{` only needs to consume the dispatch!)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: at the end of this challenge on production, we'll see that we didn't make `}<em parentName=\"p\">{`huge changes`}</em>{` to the timing.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"fix-perf-deatch-by-a-thousand-cuts\"\n    }}>{`Fix Perf Deatch by a Thousand Cuts`}</h2>\n    <p>{`In this example, we had to fix an input that was operating horrifically slow. The reason we come to find is related to a requirement of state colocation with the component.`}</p>\n    <p>{`It is important NOT to just add everything to the state context willy nilly. There are a lot of Performance implications with this.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Fix \"perf death by a thousand cuts\"\n// http://localhost:3000/isolated/exercise/06.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nAppStateContext.displayName = 'AppStateContext';\nconst AppDispatchContext = React.createContext();\nAppDispatchContext.displayName = 'AppDispatchContext';\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    // we're no longer managing the dogName state in our reducer\n    // 💣 remove this case\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // 🐨 replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [dogName, setDogName] = React.useState('');\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    setDogName(newDogName);\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"separate-contexts\"\n    }}>{`Separate Contexts`}</h3>\n    <p>{`This solution is about going for a different approach. The approach here is to handle when things are global. We can separate context out for different domains.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`It is really important to also measure after to see if you've made serious Performance improvements and not just added complexity.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\nconst DogContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction dogReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction DogProvider(props) {\n  const [state, dispatch] = React.useReducer(dogReducer, {\n    dogName: '',\n  });\n\n  const value = [state, dispatch];\n\n  return <DogProvider value={value} {...props} />;\n}\n\nfunction useDogContext() {\n  const context = React.useContext(DogContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // 🐨 replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [state, dispatch] = useDogContext();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    // 🐨 change this to call your state setter that you get from useState\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogProvider>\n            <DogNameInput />\n          </DogProvider>\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: Because the `}<inlineCode parentName=\"p\">{`AppProvider`}</inlineCode>{` not longer impacts anything other than the grid, we can also change the Providers to focus more where is matters:`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <DogProvider>\n          <DogNameInput />\n        </DogProvider>\n        <AppProvider>\n          <Grid />\n        </AppProvider>\n      </div>\n    </div>\n  );\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"consuming-components\"\n    }}>{`Consuming Components`}</h3>\n    <p>{`If we check our profiling after the changes that we made above, we will see that when we click a button, there are still all these smaller re-renderings that are happening.`}</p>\n    <p>{`In this particular scenario, it is the `}<inlineCode parentName=\"p\">{`const cell = state.grid[row][column]`}</inlineCode>{` line that we want to take out from the cell and calculate prior.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// This is like a \"man-in-middle\" that cares about state and can take that,\n// pass it down and then the rendering of the CellImpl can take advantage of memoisation\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  return <CellImpl cell={cell} row={row} column={column} />;\n}\nCell = React.memo(Cell);\n\nfunction CellImpl({ cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCellImpl = React.memo(CellImpl);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"slice-of-app-state\"\n    }}>{`Slice of App State`}</h3>\n    <p>{`\"I'm not super jazzed about making an intermediary component\". Instead, we can make a higher-order component to take care of it for us instead.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`function withStateSlice(Comp, slice) {\n  const MemoComp = React.memo(Comp);\n  function Wrapper(props, ref) {\n    const state = useAppState();\n    return <MemoComp ref={ref} state={slice(state, props)} {...props} />;\n  }\n  Wrapper.displayName = \\`withStateSlice\\${Comp.dispayName || Comp.name}\\`;\n  return React.memo(React.forwardRef(Wrapper));\n}\n\nfunction Cell({ state: cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = withStateSlice(\n  Cell,\n  (state, { row, column }) => state.grid[row][column],\n);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"use-recoil\"\n    }}>{`Use Recoil`}</h3>\n    <p>{`For the specific problem we have with the massive grid (if we want to use something like that), we can use Recoil to resolve the problems that we run into.`}</p>\n    <p>{`It is worth noting that there is a complexity cost for using Recoil, but in our specific usecase, it is something that Recoil was built to solve:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Starting point for the Recoil Extra Credit\n// 💯 use recoil (exercise)\n// http://localhost:3000/isolated/exercise/06.extra-4.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n// 🐨 you're gonna need these:\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilCallback,\n  atomFamily,\n} from 'recoil';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\n// 🐨 create an atomFamily called \\`cellAtoms\\` here where the\n// default callback function accepts an object with the\n// \\`row\\` and \\`column\\` and returns the value from the initialGrid\n// 💰 initialGrid[row][column]\nconst cellAtoms = atomFamily({\n  key: 'cells',\n  default: () => ({ row, column }) => initialGrid[row][column],\n});\n\n// 💰 I'm going to give this hook to you as it's mostly here for our contrived\n// example purposes. Just comment this in when you're ready to use it.\n// Here's how it's used:\n// const updateGrid = useUpdateGrid()\n// then later: updateGrid({rows, columns})\nfunction useUpdateGrid() {\n  return useRecoilCallback(({ set }) => ({ rows, columns }) => {\n    for (let row = 0; row < rows; row++) {\n      for (let column = 0; column < columns; column++) {\n        if (Math.random() > 0.7) {\n          set(cellAtoms({ row, column }), Math.random() * 100);\n        }\n      }\n    }\n  });\n}\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(\\`Unhandled action type: \\${action.type}\\`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n  });\n  // 🦉 notice that we don't even need to bother memoizing this value\n  const value = [state, dispatch];\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  // 🐨 we're no longer storing the grid in our app state, so instead you\n  // want to get the updateGrid function from useUpdateGrid\n  const updateGrid = useUpdateGrid();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => updateGrid({ rows, columns });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\n\nfunction Cell({ row, column }) {\n  const [cell, setCell] = useRecoilState(cellAtoms({ row, column }));\n  const handleClick = () => setCell(Math.random() * 100);\n\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: \\`rgba(0, 0, 0, \\${cell / 100})\\`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <RecoilRoot>\n        <AppProvider>\n          <div>\n            <DogNameInput />\n            <Grid />\n          </div>\n        </AppProvider>\n      </RecoilRoot>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <p>{`Read more on `}<a parentName=\"p\" {...{\n        \"href\": \"https://recoiljs.org/docs/introduction/motivation\"\n      }}>{`Recoil`}</a>{` from their docs.`}</p>\n    <h2 {...{\n      \"id\": \"production-performance-monitoring\"\n    }}>{`Production Performance Monitoring`}</h2>\n    <p>{`A great way to prevent changes from regressions, we can use production performance monitoring.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Note: There is a small performance cost involved with profiling. Facebook A/B serves a version with profiling involved.`}</p>\n    </blockquote>\n    <p>{`This exercise looks at using the `}<a parentName=\"p\" {...{\n        \"href\": \"https://reactjs.org/docs/profiler.html\"\n      }}>{`React Profiler API`}</a>{`.`}</p>\n    <p>{`The usage and callback:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`<App>\n  <Profiler id=\"Navigation\" onRender={onRenderCallback}>\n    <Navigation {...props} />\n  </Profiler>\n  <Main {...props} />\n</App>;\n\n// callback\nfunction onRenderCallback(\n  id, // the \"id\" prop of the Profiler tree that has just committed\n  phase, // either \"mount\" (if the tree just mounted) or \"update\" (if it re-rendered)\n  actualDuration, // time spent rendering the committed update\n  baseDuration, // estimated time to render the entire subtree without memoization\n  startTime, // when React began rendering this update\n  commitTime, // when React committed this update\n  interactions, // the Set of interactions belonging to this update\n) {\n  // Aggregate or log render timings...\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`\"It’s important to note that unless you build your app using react-dom/profiling and scheduler/tracing-profiling this component won’t do anything.\"`}</p>\n    </blockquote>\n    <p>{`Kent also has a `}<a parentName=\"p\" {...{\n        \"href\": \"https://kentcdodds.com/blog/react-production-performance-monitoring/\"\n      }}>{`blog post`}</a>{` on the profiling.`}</p>\n    <p>{`The solution to record one:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// Production performance monitoring\n// http://localhost:3000/isolated/exercise/07.js\n\nimport * as React from 'react';\n// 🐨 you're going to need the reportProfile function\n// 💰 here, let me help you with that..\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      🐨 Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"tracing-api\"\n    }}>{`Tracing API`}</h3>\n    <p>{`So we don't know \"why\" the user caused the rerendering so we can use an `}<inlineCode parentName=\"p\">{`unstable_trace`}</inlineCode>{` to check.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`import * as React from 'react';\nimport { unstable_trace as trace } from 'scheduler/tracing';\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  // We can wrap the setCount callback to use the trace API\n  const increment = trace('click', performance.now(), () =>\n    setCount(c => c + 1),\n  );\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      🐨 Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n`}</code></pre>\n    <p>{`That is it! Now when the user clicks, we can get more information thanks to the trace that comes under the `}<inlineCode parentName=\"p\">{`interactions`}</inlineCode>{` value.`}</p>\n    <p>{`With the `}<inlineCode parentName=\"p\">{`trace`}</inlineCode>{` API, we can also start to use the `}<inlineCode parentName=\"p\">{`user interactions`}</inlineCode>{` section of the React profile!`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}