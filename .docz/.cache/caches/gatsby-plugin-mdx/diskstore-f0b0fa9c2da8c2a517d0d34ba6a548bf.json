{"expireTime":9007200867335953000,"key":"gatsby-plugin-mdx-entire-payload-2ecaf48bb5b043dbd656f4ccd2fa61ae-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Go Tour Channels","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":19,"offset":185},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":19,"offset":185},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Channels are a typed conduit through which you can send and receive values with the channel operator, <-.","position":{"start":{"line":10,"column":1,"offset":187},"end":{"line":10,"column":106,"offset":292},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":187},"end":{"line":10,"column":106,"offset":292},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"ch <- v    // Send v to channel ch.\nv := <-ch  // Receive from ch, and\n           // assign value to v.","position":{"start":{"line":12,"column":1,"offset":294},"end":{"line":16,"column":4,"offset":411},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"(The data flows in the direction of the arrow.)","position":{"start":{"line":18,"column":1,"offset":413},"end":{"line":18,"column":48,"offset":460},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":413},"end":{"line":18,"column":48,"offset":460},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Like maps and slices, channels must be created before use:","position":{"start":{"line":20,"column":1,"offset":462},"end":{"line":20,"column":59,"offset":520},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":462},"end":{"line":20,"column":59,"offset":520},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"ch := make(chan int)","position":{"start":{"line":22,"column":1,"offset":522},"end":{"line":24,"column":4,"offset":556},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.","position":{"start":{"line":26,"column":1,"offset":558},"end":{"line":26,"column":153,"offset":710},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":558},"end":{"line":26,"column":153,"offset":710},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.","position":{"start":{"line":28,"column":1,"offset":712},"end":{"line":28,"column":179,"offset":890},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":712},"end":{"line":28,"column":179,"offset":890},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Basic Example","position":{"start":{"line":30,"column":4,"offset":895},"end":{"line":30,"column":17,"offset":908},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":892},"end":{"line":30,"column":17,"offset":908},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n\tfmt.Println(\"%v\", s)\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum // send sum to c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := <-c, <-c // receive from c\n\n\tfmt.Println(x, y, x+y)\n}","position":{"start":{"line":32,"column":1,"offset":910},"end":{"line":56,"column":4,"offset":1262},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Prints:","position":{"start":{"line":58,"column":1,"offset":1264},"end":{"line":58,"column":8,"offset":1271},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":1264},"end":{"line":58,"column":8,"offset":1271},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"%v [-9 4 0]\n%v [7 2 8]\n-5 17 12","position":{"start":{"line":60,"column":1,"offset":1273},"end":{"line":64,"column":4,"offset":1317},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Buffered Channels","position":{"start":{"line":66,"column":4,"offset":1322},"end":{"line":66,"column":21,"offset":1339},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":1319},"end":{"line":66,"column":21,"offset":1339},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:","position":{"start":{"line":68,"column":1,"offset":1341},"end":{"line":68,"column":117,"offset":1457},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":1341},"end":{"line":68,"column":117,"offset":1457},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"ch := make(chan int, 100)","position":{"start":{"line":70,"column":1,"offset":1459},"end":{"line":72,"column":4,"offset":1498},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.","position":{"start":{"line":74,"column":1,"offset":1500},"end":{"line":74,"column":105,"offset":1604},"indent":[]}}],"position":{"start":{"line":74,"column":1,"offset":1500},"end":{"line":74,"column":105,"offset":1604},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If you overflow the buffer, you'll be hit with a ","position":{"start":{"line":76,"column":1,"offset":1606},"end":{"line":76,"column":50,"offset":1655},"indent":[]}},{"type":"inlineCode","value":"deadlock","position":{"start":{"line":76,"column":50,"offset":1655},"end":{"line":76,"column":60,"offset":1665},"indent":[]}},{"type":"text","value":" error.","position":{"start":{"line":76,"column":60,"offset":1665},"end":{"line":76,"column":67,"offset":1672},"indent":[]}}],"position":{"start":{"line":76,"column":1,"offset":1606},"end":{"line":76,"column":67,"offset":1672},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch <- 1\n\tch <- 2\n\tfmt.Println(<-ch)\n\tfmt.Println(<-ch)\n}","position":{"start":{"line":78,"column":1,"offset":1674},"end":{"line":90,"column":4,"offset":1812},"indent":[1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Range and Close","position":{"start":{"line":92,"column":4,"offset":1817},"end":{"line":92,"column":19,"offset":1832},"indent":[]}}],"position":{"start":{"line":92,"column":1,"offset":1814},"end":{"line":92,"column":19,"offset":1832},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after","position":{"start":{"line":94,"column":1,"offset":1834},"end":{"line":94,"column":193,"offset":2026},"indent":[]}}],"position":{"start":{"line":94,"column":1,"offset":1834},"end":{"line":94,"column":193,"offset":2026},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"v, ok := <-ch","position":{"start":{"line":96,"column":1,"offset":2028},"end":{"line":98,"column":4,"offset":2055},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"ok","position":{"start":{"line":100,"column":1,"offset":2057},"end":{"line":100,"column":5,"offset":2061},"indent":[]}},{"type":"text","value":" is false if there are no more values to receive and the channel is closed.","position":{"start":{"line":100,"column":5,"offset":2061},"end":{"line":100,"column":80,"offset":2136},"indent":[]}}],"position":{"start":{"line":100,"column":1,"offset":2057},"end":{"line":100,"column":80,"offset":2136},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The loop for ","position":{"start":{"line":102,"column":1,"offset":2138},"end":{"line":102,"column":14,"offset":2151},"indent":[]}},{"type":"inlineCode","value":"i := range c","position":{"start":{"line":102,"column":14,"offset":2151},"end":{"line":102,"column":28,"offset":2165},"indent":[]}},{"type":"text","value":" receives values from the channel repeatedly until it is closed.","position":{"start":{"line":102,"column":28,"offset":2165},"end":{"line":102,"column":92,"offset":2229},"indent":[]}}],"position":{"start":{"line":102,"column":1,"offset":2138},"end":{"line":102,"column":92,"offset":2229},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.","position":{"start":{"line":104,"column":1,"offset":2231},"end":{"line":104,"column":114,"offset":2344},"indent":[]}}],"position":{"start":{"line":104,"column":1,"offset":2231},"end":{"line":104,"column":114,"offset":2344},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.","position":{"start":{"line":106,"column":1,"offset":2346},"end":{"line":106,"column":205,"offset":2550},"indent":[]}}],"position":{"start":{"line":106,"column":1,"offset":2346},"end":{"line":106,"column":205,"offset":2550},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}","position":{"start":{"line":108,"column":1,"offset":2552},"end":{"line":131,"column":4,"offset":2821},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This prints:","position":{"start":{"line":133,"column":1,"offset":2823},"end":{"line":133,"column":13,"offset":2835},"indent":[]}}],"position":{"start":{"line":133,"column":1,"offset":2823},"end":{"line":133,"column":13,"offset":2835},"indent":[]}},{"type":"code","lang":"shell","meta":null,"value":"0\n1\n1\n2\n3\n5\n8\n13\n21\n34","position":{"start":{"line":135,"column":1,"offset":2837},"end":{"line":146,"column":4,"offset":2872},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Select","position":{"start":{"line":148,"column":4,"offset":2877},"end":{"line":148,"column":10,"offset":2883},"indent":[]}}],"position":{"start":{"line":148,"column":1,"offset":2874},"end":{"line":148,"column":10,"offset":2883},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The select statement lets a goroutine wait on multiple communication operations.","position":{"start":{"line":150,"column":1,"offset":2885},"end":{"line":150,"column":81,"offset":2965},"indent":[]}}],"position":{"start":{"line":150,"column":1,"offset":2885},"end":{"line":150,"column":81,"offset":2965},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.","position":{"start":{"line":152,"column":1,"offset":2967},"end":{"line":152,"column":124,"offset":3090},"indent":[]}}],"position":{"start":{"line":152,"column":1,"offset":2967},"end":{"line":152,"column":124,"offset":3090},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}","position":{"start":{"line":154,"column":1,"offset":3092},"end":{"line":183,"column":4,"offset":3453},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"After looping through in the IIFE ","position":{"start":{"line":185,"column":1,"offset":3455},"end":{"line":185,"column":35,"offset":3489},"indent":[]}},{"type":"inlineCode","value":"go func","position":{"start":{"line":185,"column":35,"offset":3489},"end":{"line":185,"column":44,"offset":3498},"indent":[]}},{"type":"text","value":", it will send a 0 to the ","position":{"start":{"line":185,"column":44,"offset":3498},"end":{"line":185,"column":70,"offset":3524},"indent":[]}},{"type":"inlineCode","value":"quit","position":{"start":{"line":185,"column":70,"offset":3524},"end":{"line":185,"column":76,"offset":3530},"indent":[]}},{"type":"text","value":" channel and ","position":{"start":{"line":185,"column":76,"offset":3530},"end":{"line":185,"column":89,"offset":3543},"indent":[]}},{"type":"inlineCode","value":"select","position":{"start":{"line":185,"column":89,"offset":3543},"end":{"line":185,"column":97,"offset":3551},"indent":[]}},{"type":"text","value":" will handle by printing \"quit\" and returning from the infinite ","position":{"start":{"line":185,"column":97,"offset":3551},"end":{"line":185,"column":161,"offset":3615},"indent":[]}},{"type":"inlineCode","value":"for","position":{"start":{"line":185,"column":161,"offset":3615},"end":{"line":185,"column":166,"offset":3620},"indent":[]}},{"type":"text","value":" loop.","position":{"start":{"line":185,"column":166,"offset":3620},"end":{"line":185,"column":172,"offset":3626},"indent":[]}}],"position":{"start":{"line":185,"column":1,"offset":3455},"end":{"line":185,"column":172,"offset":3626},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Default Selection","position":{"start":{"line":187,"column":4,"offset":3631},"end":{"line":187,"column":21,"offset":3648},"indent":[]}}],"position":{"start":{"line":187,"column":1,"offset":3628},"end":{"line":187,"column":21,"offset":3648},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The default case in a select is run if no other case is ready.","position":{"start":{"line":189,"column":1,"offset":3650},"end":{"line":189,"column":63,"offset":3712},"indent":[]}}],"position":{"start":{"line":189,"column":1,"offset":3650},"end":{"line":189,"column":63,"offset":3712},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Use a default case to try a send or receive without blocking:","position":{"start":{"line":191,"column":1,"offset":3714},"end":{"line":191,"column":62,"offset":3775},"indent":[]}}],"position":{"start":{"line":191,"column":1,"offset":3714},"end":{"line":191,"column":62,"offset":3775},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"select {\ncase i := <-c:\n    // use i\ndefault:\n    // receiving from c would block\n}","position":{"start":{"line":193,"column":1,"offset":3777},"end":{"line":200,"column":4,"offset":3874},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Example:","position":{"start":{"line":202,"column":1,"offset":3876},"end":{"line":202,"column":9,"offset":3884},"indent":[]}}],"position":{"start":{"line":202,"column":1,"offset":3876},"end":{"line":202,"column":9,"offset":3884},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase <-tick:\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase <-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}","position":{"start":{"line":204,"column":1,"offset":3886},"end":{"line":228,"column":4,"offset":4228},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Example: Equivalent Binary Trees","position":{"start":{"line":230,"column":4,"offset":4233},"end":{"line":230,"column":36,"offset":4265},"indent":[]}}],"position":{"start":{"line":230,"column":1,"offset":4230},"end":{"line":230,"column":36,"offset":4265},"indent":[]}},{"type":"code","lang":"golang","meta":null,"value":"package main\n\nimport (\n  \"golang.org/x/tour/tree\"\n  \"fmt\"\n)\n\n// Walk walks the tree t sending all values\n// from the tree to the channel ch.\nfunc Walk(t *tree.Tree, ch chan int) {\n\tdefer close(ch) // <- closes the channel when this function returns\n  var walk func(t *tree.Tree)\n  walk = func(t *tree.Tree) {\n      if t == nil {\n          return\n      }\n      walk(t.Left)\n      ch <- t.Value\n      walk(t.Right)\n  }\n  walk(t)\n}\n\n// Same determines whether the trees\n// t1 and t2 contain the same values.\nfunc Same(t1, t2 *tree.Tree) bool {\n\tdone := make (chan bool)\n\tdefer close(done)\n\n\tch1 := make(chan int)\n\tch2 := make(chan int)\n\tgo Walk(t1, ch1)\n\tgo Walk(t2, ch2)\n\n\tgo func() {\n\t\tfor i := range ch1 {\n\t\t\tj := <-ch2\n\t\t\tfmt.Println(\"i: %v\", i)\n\t\t\tfmt.Println(\"j: %v\", j)\n\n\t\t\tif i != j {\n\t\t\t\tdone <- false\n\t\t\t}\n\t\t}\n\t\tdone <- true\n\t}()\n\treturn <-done\n}\n\nfunc main() {\n\tch := make(chan int)\n\tgo Walk(tree.New(1), ch)\n\n\tfor i := 1; i <= 10; i++ {\n\t\tfmt.Println(<-ch)\n\t}\n\n\tt1 := tree.New(1)\n\tt2 := tree.New(2)\n\n\tres1 := Same(t1, t1)\n\tfmt.Println(\"Res 1: %v\", res1)\n\n\tres2 := Same(t1, t2)\n\tfmt.Println(\"Res 2: %v\", res2)\n}","position":{"start":{"line":232,"column":1,"offset":4267},"end":{"line":299,"column":4,"offset":5400},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":302,"column":1,"offset":5403},"end":{"line":302,"column":31,"offset":5433},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":302,"column":31,"offset":5433}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"go-tour-channels\"\n    }}>{`Go Tour Channels`}</h1>\n    <p>{`Channels are a typed conduit through which you can send and receive values with the channel operator, <-.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch <- v    // Send v to channel ch.\nv := <-ch  // Receive from ch, and\n           // assign value to v.\n`}</code></pre>\n    <p>{`(The data flows in the direction of the arrow.)`}</p>\n    <p>{`Like maps and slices, channels must be created before use:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int)\n`}</code></pre>\n    <p>{`By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.`}</p>\n    <p>{`The example code sums the numbers in a slice, distributing the work between two goroutines. Once both goroutines have completed their computation, it calculates the final result.`}</p>\n    <h2 {...{\n      \"id\": \"basic-example\"\n    }}>{`Basic Example`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n    fmt.Println(\"%v\", s)\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum // send sum to c\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n\n    c := make(chan int)\n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    x, y := <-c, <-c // receive from c\n\n    fmt.Println(x, y, x+y)\n}\n`}</code></pre>\n    <p>{`Prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`%v [-9 4 0]\n%v [7 2 8]\n-5 17 12\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"buffered-channels\"\n    }}>{`Buffered Channels`}</h2>\n    <p>{`Channels can be buffered. Provide the buffer length as the second argument to make to initialize a buffered channel:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`ch := make(chan int, 100)\n`}</code></pre>\n    <p>{`Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.`}</p>\n    <p>{`If you overflow the buffer, you'll be hit with a `}<inlineCode parentName=\"p\">{`deadlock`}</inlineCode>{` error.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan int, 2)\n    ch <- 1\n    ch <- 2\n    fmt.Println(<-ch)\n    fmt.Println(<-ch)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"range-and-close\"\n    }}>{`Range and Close`}</h2>\n    <p>{`A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`v, ok := <-ch\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`ok`}</inlineCode>{` is false if there are no more values to receive and the channel is closed.`}</p>\n    <p>{`The loop for `}<inlineCode parentName=\"p\">{`i := range c`}</inlineCode>{` receives values from the channel repeatedly until it is closed.`}</p>\n    <p>{`Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.`}</p>\n    <p>{`Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n    x, y := 0, 1\n    for i := 0; i < n; i++ {\n        c <- x\n        x, y = y, x+y\n    }\n    close(c)\n}\n\nfunc main() {\n    c := make(chan int, 10)\n    go fibonacci(cap(c), c)\n    for i := range c {\n        fmt.Println(i)\n    }\n}\n`}</code></pre>\n    <p>{`This prints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-shell\"\n      }}>{`0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"select\"\n    }}>{`Select`}</h2>\n    <p>{`The select statement lets a goroutine wait on multiple communication operations.`}</p>\n    <p>{`A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n        case c <- x:\n            x, y = y, x+y\n        case <-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i < 10; i++ {\n            fmt.Println(<-c)\n        }\n        quit <- 0\n    }()\n    fibonacci(c, quit)\n}\n`}</code></pre>\n    <p>{`After looping through in the IIFE `}<inlineCode parentName=\"p\">{`go func`}</inlineCode>{`, it will send a 0 to the `}<inlineCode parentName=\"p\">{`quit`}</inlineCode>{` channel and `}<inlineCode parentName=\"p\">{`select`}</inlineCode>{` will handle by printing \"quit\" and returning from the infinite `}<inlineCode parentName=\"p\">{`for`}</inlineCode>{` loop.`}</p>\n    <h2 {...{\n      \"id\": \"default-selection\"\n    }}>{`Default Selection`}</h2>\n    <p>{`The default case in a select is run if no other case is ready.`}</p>\n    <p>{`Use a default case to try a send or receive without blocking:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`select {\ncase i := <-c:\n    // use i\ndefault:\n    // receiving from c would block\n}\n`}</code></pre>\n    <p>{`Example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    tick := time.Tick(100 * time.Millisecond)\n    boom := time.After(500 * time.Millisecond)\n    for {\n        select {\n        case <-tick:\n            fmt.Println(\"tick.\")\n        case <-boom:\n            fmt.Println(\"BOOM!\")\n            return\n        default:\n            fmt.Println(\"    .\")\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"example-equivalent-binary-trees\"\n    }}>{`Example: Equivalent Binary Trees`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-golang\"\n      }}>{`package main\n\nimport (\n  \"golang.org/x/tour/tree\"\n  \"fmt\"\n)\n\n// Walk walks the tree t sending all values\n// from the tree to the channel ch.\nfunc Walk(t *tree.Tree, ch chan int) {\n    defer close(ch) // <- closes the channel when this function returns\n  var walk func(t *tree.Tree)\n  walk = func(t *tree.Tree) {\n      if t == nil {\n          return\n      }\n      walk(t.Left)\n      ch <- t.Value\n      walk(t.Right)\n  }\n  walk(t)\n}\n\n// Same determines whether the trees\n// t1 and t2 contain the same values.\nfunc Same(t1, t2 *tree.Tree) bool {\n    done := make (chan bool)\n    defer close(done)\n\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go Walk(t1, ch1)\n    go Walk(t2, ch2)\n\n    go func() {\n        for i := range ch1 {\n            j := <-ch2\n            fmt.Println(\"i: %v\", i)\n            fmt.Println(\"j: %v\", j)\n\n            if i != j {\n                done <- false\n            }\n        }\n        done <- true\n    }()\n    return <-done\n}\n\nfunc main() {\n    ch := make(chan int)\n    go Walk(tree.New(1), ch)\n\n    for i := 1; i <= 10; i++ {\n        fmt.Println(<-ch)\n    }\n\n    t1 := tree.New(1)\n    t2 := tree.New(2)\n\n    res1 := Same(t1, t1)\n    fmt.Println(\"Res 1: %v\", res1)\n\n    res2 := Same(t1, t2)\n    fmt.Println(\"Res 2: %v\", res2)\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}