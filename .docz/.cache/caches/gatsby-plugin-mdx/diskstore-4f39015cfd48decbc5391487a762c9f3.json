{"expireTime":9007200848610874000,"key":"gatsby-plugin-mdx-entire-payload-0432a3b605a19ef8f05da0d94ea12150-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Thread Pool Usage","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":20,"offset":186},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":20,"offset":186},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":10,"column":4,"offset":191},"end":{"line":10,"column":13,"offset":200},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":188},"end":{"line":10,"column":13,"offset":200},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://stackoverflow.com/questions/53751050/python-multiprocessing-understanding-logic-behind-chunksize","children":[{"type":"text","value":"Explanation behind chunksize","position":{"start":{"line":12,"column":5,"offset":206},"end":{"line":12,"column":33,"offset":234},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":205},"end":{"line":12,"column":140,"offset":341},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":205},"end":{"line":12,"column":140,"offset":341},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":202},"end":{"line":12,"column":140,"offset":341},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":202},"end":{"line":12,"column":140,"offset":341},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Example","position":{"start":{"line":14,"column":4,"offset":346},"end":{"line":14,"column":11,"offset":353},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":343},"end":{"line":14,"column":11,"offset":353},"indent":[]}},{"type":"code","lang":"python","meta":null,"value":"\"\"\"\nprocesses=os.cpu_count() enables us to to utilise all\nprocessing cores.\n\nchunksize=1 tells us to pass one element on each execution. If you roughly know the time expecation of each function execution, you can increase this to chunk the args into bigger pieces for one process to tackle.\n\"\"\"\nfrom multiprocessing import Pool\n\ndef square(number):\n  return number * number\n\ndata  = [1,2,3]\nchunksize = 1\nproc_count = os.cpu_count()\nwith Pool(processes=proc_count) as pool:\n  result = pool.map(square, data, chunksize)\n  # result returns [1, 4, 9]","position":{"start":{"line":16,"column":1,"offset":355},"end":{"line":34,"column":4,"offset":916},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":37,"column":1,"offset":919},"end":{"line":37,"column":31,"offset":949},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":37,"column":31,"offset":949}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"thread-pool-usage\"\n    }}>{`Thread Pool Usage`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://stackoverflow.com/questions/53751050/python-multiprocessing-understanding-logic-behind-chunksize\"\n        }}>{`Explanation behind chunksize`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"example\"\n    }}>{`Example`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`\"\"\"\nprocesses=os.cpu_count() enables us to to utilise all\nprocessing cores.\n\nchunksize=1 tells us to pass one element on each execution. If you roughly know the time expecation of each function execution, you can increase this to chunk the args into bigger pieces for one process to tackle.\n\"\"\"\nfrom multiprocessing import Pool\n\ndef square(number):\n  return number * number\n\ndata  = [1,2,3]\nchunksize = 1\nproc_count = os.cpu_count()\nwith Pool(processes=proc_count) as pool:\n  result = pool.map(square, data, chunksize)\n  # result returns [1, 4, 9]\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}