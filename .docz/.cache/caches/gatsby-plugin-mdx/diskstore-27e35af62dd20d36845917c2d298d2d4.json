{"expireTime":9007200848610926000,"key":"gatsby-plugin-mdx-entire-payload-cd0bea71d35437b7d85c3b30bde397ca-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Database Normalisaton","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":24,"offset":190},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":24,"offset":190},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":10,"column":4,"offset":195},"end":{"line":10,"column":13,"offset":204},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":192},"end":{"line":10,"column":13,"offset":204},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://en.wikipedia.org/wiki/Database_normalization","children":[{"type":"text","value":"Database Normalisation","position":{"start":{"line":12,"column":5,"offset":210},"end":{"line":12,"column":27,"offset":232},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":209},"end":{"line":12,"column":82,"offset":287},"indent":[]}}],"position":{"start":{"line":12,"column":4,"offset":209},"end":{"line":12,"column":82,"offset":287},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":206},"end":{"line":12,"column":82,"offset":287},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://en.wikipedia.org/wiki/Candidate_key","children":[{"type":"text","value":"Candidate Key","position":{"start":{"line":13,"column":5,"offset":292},"end":{"line":13,"column":18,"offset":305},"indent":[]}}],"position":{"start":{"line":13,"column":4,"offset":291},"end":{"line":13,"column":64,"offset":351},"indent":[]}}],"position":{"start":{"line":13,"column":4,"offset":291},"end":{"line":13,"column":64,"offset":351},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":288},"end":{"line":13,"column":64,"offset":351},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://en.wikipedia.org/wiki/Compound_key","children":[{"type":"text","value":"Compound Key","position":{"start":{"line":14,"column":5,"offset":356},"end":{"line":14,"column":17,"offset":368},"indent":[]}}],"position":{"start":{"line":14,"column":4,"offset":355},"end":{"line":14,"column":62,"offset":413},"indent":[]}}],"position":{"start":{"line":14,"column":4,"offset":355},"end":{"line":14,"column":62,"offset":413},"indent":[]}}],"position":{"start":{"line":14,"column":1,"offset":352},"end":{"line":14,"column":62,"offset":413},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://pediaa.com/what-is-the-difference-between-candidate-key-and-composite-key/","children":[{"type":"text","value":"Candidate vs Composite Keys","position":{"start":{"line":15,"column":5,"offset":418},"end":{"line":15,"column":32,"offset":445},"indent":[]}}],"position":{"start":{"line":15,"column":4,"offset":417},"end":{"line":15,"column":117,"offset":530},"indent":[]}}],"position":{"start":{"line":15,"column":4,"offset":417},"end":{"line":15,"column":117,"offset":530},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":414},"end":{"line":15,"column":117,"offset":530},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://en.wikipedia.org/wiki/Superkey","children":[{"type":"text","value":"Super Key","position":{"start":{"line":16,"column":5,"offset":535},"end":{"line":16,"column":14,"offset":544},"indent":[]}}],"position":{"start":{"line":16,"column":4,"offset":534},"end":{"line":16,"column":55,"offset":585},"indent":[]}}],"position":{"start":{"line":16,"column":4,"offset":534},"end":{"line":16,"column":55,"offset":585},"indent":[]}}],"position":{"start":{"line":16,"column":1,"offset":531},"end":{"line":16,"column":55,"offset":585},"indent":[]}}],"position":{"start":{"line":12,"column":1,"offset":206},"end":{"line":16,"column":55,"offset":585},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"What is it?","position":{"start":{"line":18,"column":4,"offset":590},"end":{"line":18,"column":15,"offset":601},"indent":[]}}],"position":{"start":{"line":18,"column":1,"offset":587},"end":{"line":18,"column":15,"offset":601},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Database normalization is the process of structuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity. It was first proposed by Edgar F. Codd as part of his relational model.","position":{"start":{"line":20,"column":3,"offset":605},"end":{"line":20,"column":266,"offset":868},"indent":[]}}],"position":{"start":{"line":20,"column":3,"offset":605},"end":{"line":20,"column":266,"offset":868},"indent":[]}}],"position":{"start":{"line":20,"column":1,"offset":603},"end":{"line":20,"column":266,"offset":868},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Normalization organises the columns (attributes) and tables (relations) of a database to ensure that their dependencies are properly enforced by database integrity constraints.","position":{"start":{"line":22,"column":1,"offset":870},"end":{"line":22,"column":177,"offset":1046},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":870},"end":{"line":22,"column":177,"offset":1046},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"It is accomplished by applying some formal rules either by a process of synthesis (creating a new database design) or decomposition (improving an existing database design).","position":{"start":{"line":24,"column":1,"offset":1048},"end":{"line":24,"column":173,"offset":1220},"indent":[]}}],"position":{"start":{"line":24,"column":1,"offset":1048},"end":{"line":24,"column":173,"offset":1220},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Denormalisation Objectives","position":{"start":{"line":26,"column":4,"offset":1225},"end":{"line":26,"column":30,"offset":1251},"indent":[]}}],"position":{"start":{"line":26,"column":1,"offset":1222},"end":{"line":26,"column":30,"offset":1251},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The objectives beyond the first normal form (1NF):","position":{"start":{"line":28,"column":1,"offset":1253},"end":{"line":28,"column":51,"offset":1303},"indent":[]}}],"position":{"start":{"line":28,"column":1,"offset":1253},"end":{"line":28,"column":51,"offset":1303},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Free the collection of relations from undesirable insertion, update and deletion dependencies.","position":{"start":{"line":30,"column":4,"offset":1308},"end":{"line":30,"column":98,"offset":1402},"indent":[]}}],"position":{"start":{"line":30,"column":4,"offset":1308},"end":{"line":30,"column":98,"offset":1402},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1305},"end":{"line":30,"column":98,"offset":1402},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Reduce the need for restructuring the collection of relatons, as new types of data are introduced, and thus increase the life span of application programs.","position":{"start":{"line":31,"column":4,"offset":1406},"end":{"line":31,"column":159,"offset":1561},"indent":[]}}],"position":{"start":{"line":31,"column":4,"offset":1406},"end":{"line":31,"column":159,"offset":1561},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":1403},"end":{"line":31,"column":159,"offset":1561},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Make the relational model more informative to users.","position":{"start":{"line":32,"column":4,"offset":1565},"end":{"line":32,"column":56,"offset":1617},"indent":[]}}],"position":{"start":{"line":32,"column":4,"offset":1565},"end":{"line":32,"column":56,"offset":1617},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1562},"end":{"line":32,"column":56,"offset":1617},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Make the collection of relations neutral to query statistics, where these statistics are liable to change as time goes by.","position":{"start":{"line":33,"column":4,"offset":1621},"end":{"line":33,"column":126,"offset":1743},"indent":[]}}],"position":{"start":{"line":33,"column":4,"offset":1621},"end":{"line":33,"column":126,"offset":1743},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":1618},"end":{"line":33,"column":126,"offset":1743},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1305},"end":{"line":33,"column":126,"offset":1743},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Undesireable Side-Effects","position":{"start":{"line":35,"column":4,"offset":1748},"end":{"line":35,"column":29,"offset":1773},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":1745},"end":{"line":35,"column":29,"offset":1773},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The following may be undesirable from unnormalisaed databases:","position":{"start":{"line":37,"column":1,"offset":1775},"end":{"line":37,"column":63,"offset":1837},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":1775},"end":{"line":37,"column":63,"offset":1837},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Update anomaly: The same info can be expressed in multiple rows, therefore updates to the relation may result in logical inconsistencies.","position":{"start":{"line":39,"column":4,"offset":1842},"end":{"line":39,"column":141,"offset":1979},"indent":[]}}],"position":{"start":{"line":39,"column":4,"offset":1842},"end":{"line":39,"column":141,"offset":1979},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":1839},"end":{"line":39,"column":141,"offset":1979},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Insertion anomaly: Circumstances where certain facts cannot be recorded at all. For example, each record in a \"Faculty and Their Courses\" relation might contain a Faculty ID, Faculty Name, Faculty Hire Date, and Course Code. Therefore, we can record the details of any faculty member who teaches at least one course, but we cannot record a newly hired faculty member who has not yet been assigned to teach any courses, except by setting the Course Code to null. This phenomenon is known as an insertion anomaly.","position":{"start":{"line":40,"column":4,"offset":1983},"end":{"line":40,"column":515,"offset":2494},"indent":[]}}],"position":{"start":{"line":40,"column":4,"offset":1983},"end":{"line":40,"column":515,"offset":2494},"indent":[]}}],"position":{"start":{"line":40,"column":1,"offset":1980},"end":{"line":40,"column":515,"offset":2494},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Deletion anomaly: Under particular circumstances, deletion of data representing certain facts necessitates deletion of data representing completely different facts. The \"Faculty and Their Courses\" relation described in the previous example suffers from this type of anomaly, for if a faculty member temporarily ceases to be assigned to any courses, we must delete the last of the records on which that faculty member appears, effectively also deleting the faculty member, unless we set the Course Code to null. This phenomenon is known as a deletion anomaly.","position":{"start":{"line":41,"column":4,"offset":2498},"end":{"line":41,"column":562,"offset":3056},"indent":[]}}],"position":{"start":{"line":41,"column":4,"offset":2498},"end":{"line":41,"column":562,"offset":3056},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":2495},"end":{"line":41,"column":562,"offset":3056},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":1839},"end":{"line":41,"column":562,"offset":3056},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Terms","position":{"start":{"line":43,"column":4,"offset":3061},"end":{"line":43,"column":9,"offset":3066},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":3058},"end":{"line":43,"column":9,"offset":3066},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Candidate Key","position":{"start":{"line":45,"column":5,"offset":3072},"end":{"line":45,"column":18,"offset":3085},"indent":[]}}],"position":{"start":{"line":45,"column":1,"offset":3068},"end":{"line":45,"column":18,"offset":3085},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"(from Wikipedia)","position":{"start":{"line":47,"column":1,"offset":3087},"end":{"line":47,"column":17,"offset":3103},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":3087},"end":{"line":47,"column":17,"offset":3103},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the relational model of databases, a candidate key of a relation is a minimal superkey for that relation; that is, a set of attributes such that:","position":{"start":{"line":49,"column":1,"offset":3105},"end":{"line":49,"column":149,"offset":3253},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":3105},"end":{"line":49,"column":149,"offset":3253},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"the relation does not have two distinct tuples (i.e. rows or records in common database language) with the same values for these attributes (which means that the set of attributes is a superkey)","position":{"start":{"line":51,"column":4,"offset":3258},"end":{"line":51,"column":198,"offset":3452},"indent":[]}}],"position":{"start":{"line":51,"column":4,"offset":3258},"end":{"line":51,"column":198,"offset":3452},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":3255},"end":{"line":51,"column":198,"offset":3452},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"there is no proper subset of these attributes for which (1) holds (which means that the set is minimal).","position":{"start":{"line":52,"column":4,"offset":3456},"end":{"line":52,"column":108,"offset":3560},"indent":[]}}],"position":{"start":{"line":52,"column":4,"offset":3456},"end":{"line":52,"column":108,"offset":3560},"indent":[]}}],"position":{"start":{"line":52,"column":1,"offset":3453},"end":{"line":52,"column":108,"offset":3560},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":3255},"end":{"line":52,"column":108,"offset":3560},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"Candidate keys are also variously referred to as primary keys, secondary keys or alternate keys.","position":{"start":{"line":54,"column":1,"offset":3562},"end":{"line":54,"column":97,"offset":3658},"indent":[]}}],"position":{"start":{"line":54,"column":1,"offset":3562},"end":{"line":54,"column":97,"offset":3658},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The constituent attributes are called prime attributes. Conversely, an attribute that does not occur in ANY candidate key is called a non-prime attribute.","position":{"start":{"line":56,"column":1,"offset":3660},"end":{"line":56,"column":155,"offset":3814},"indent":[]}}],"position":{"start":{"line":56,"column":1,"offset":3660},"end":{"line":56,"column":155,"offset":3814},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Since a relation contains no duplicate tuples, the set of all its attributes is a superkey if NULL values are not used. It follows that every relation will have at least one candidate key.","position":{"start":{"line":58,"column":1,"offset":3816},"end":{"line":58,"column":189,"offset":4004},"indent":[]}}],"position":{"start":{"line":58,"column":1,"offset":3816},"end":{"line":58,"column":189,"offset":4004},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The candidate keys of a relation tell us all the possible ways we can identify its tuples. As such they are an important concept for the design of database schema.","position":{"start":{"line":60,"column":1,"offset":4006},"end":{"line":60,"column":164,"offset":4169},"indent":[]}}],"position":{"start":{"line":60,"column":1,"offset":4006},"end":{"line":60,"column":164,"offset":4169},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Candidate vs Composite","position":{"start":{"line":62,"column":5,"offset":4175},"end":{"line":62,"column":27,"offset":4197},"indent":[]}}],"position":{"start":{"line":62,"column":1,"offset":4171},"end":{"line":62,"column":27,"offset":4197},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A candidate key is a super key with no redundant attributes, while a composite key is a key that consists of two or more attributes that uniquely identify any row in the table. Thus, this is the main difference between candidate key and composite key.","position":{"start":{"line":64,"column":1,"offset":4199},"end":{"line":64,"column":252,"offset":4450},"indent":[]}}],"position":{"start":{"line":64,"column":1,"offset":4199},"end":{"line":64,"column":252,"offset":4450},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In brief, the programmer can use various keys to connect the tables of a database. Two types of keys are candidate key and composite key. The main difference between candidate key and composite key is that candidate key is a super key with no redundant attributes, while the composite key is a key with two or many attributes to identify the rows of the table.","position":{"start":{"line":66,"column":1,"offset":4452},"end":{"line":66,"column":361,"offset":4812},"indent":[]}}],"position":{"start":{"line":66,"column":1,"offset":4452},"end":{"line":66,"column":361,"offset":4812},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Compound Key","position":{"start":{"line":68,"column":5,"offset":4818},"end":{"line":68,"column":17,"offset":4830},"indent":[]}}],"position":{"start":{"line":68,"column":1,"offset":4814},"end":{"line":68,"column":17,"offset":4830},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"(from Wikipedia)","position":{"start":{"line":70,"column":1,"offset":4832},"end":{"line":70,"column":17,"offset":4848},"indent":[]}}],"position":{"start":{"line":70,"column":1,"offset":4832},"end":{"line":70,"column":17,"offset":4848},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In database design, a composite key is a candidate key that consists of two or more attributes (table columns) that together uniquely identify an entity occurrence (table row). A compound key is a composite key for which each attribute that makes up the key is a simple (foreign) key in its own right.","position":{"start":{"line":72,"column":1,"offset":4850},"end":{"line":72,"column":302,"offset":5151},"indent":[]}}],"position":{"start":{"line":72,"column":1,"offset":4850},"end":{"line":72,"column":302,"offset":5151},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Super Key","position":{"start":{"line":74,"column":5,"offset":5157},"end":{"line":74,"column":14,"offset":5166},"indent":[]}}],"position":{"start":{"line":74,"column":1,"offset":5153},"end":{"line":74,"column":14,"offset":5166},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"(from Wikipedia)","position":{"start":{"line":76,"column":1,"offset":5168},"end":{"line":76,"column":17,"offset":5184},"indent":[]}}],"position":{"start":{"line":76,"column":1,"offset":5168},"end":{"line":76,"column":17,"offset":5184},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A superkey or super-key is defined in the relational model of database organization as a set of attributes of a relation variable for which it holds that in all relations assigned to that variable, there are no two distinct tuples (rows) that have the same values for the attributes in this set.","position":{"start":{"line":78,"column":1,"offset":5186},"end":{"line":78,"column":296,"offset":5481},"indent":[]}},{"type":"linkReference","identifier":"1","label":"1","referenceType":"shortcut","children":[{"type":"text","value":"1","position":{"start":{"line":78,"column":297,"offset":5482},"end":{"line":78,"column":298,"offset":5483},"indent":[]}}],"position":{"start":{"line":78,"column":296,"offset":5481},"end":{"line":78,"column":299,"offset":5484},"indent":[]}},{"type":"text","value":" It can be defined as a set of attributes of a relation schema upon which all attributes of the schema are functionally dependent.","position":{"start":{"line":78,"column":299,"offset":5484},"end":{"line":78,"column":429,"offset":5614},"indent":[]}}],"position":{"start":{"line":78,"column":1,"offset":5186},"end":{"line":78,"column":429,"offset":5614},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The set of all attributes is a trivial superkey, because in relational algebra duplicate rows are not permitted: rows are a set (no duplicates), not a multiset (duplicates allowed). The superkey is also known as superset key.","position":{"start":{"line":80,"column":1,"offset":5616},"end":{"line":80,"column":226,"offset":5841},"indent":[]}}],"position":{"start":{"line":80,"column":1,"offset":5616},"end":{"line":80,"column":226,"offset":5841},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"If attribute set K is a superkey of relation R, then at all times it is the case that the projection of R over K has the same cardinality as R itself.","position":{"start":{"line":82,"column":1,"offset":5843},"end":{"line":82,"column":151,"offset":5993},"indent":[]}}],"position":{"start":{"line":82,"column":1,"offset":5843},"end":{"line":82,"column":151,"offset":5993},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A superkey is a set of attributes within a table whose values can be used to uniquely identify a tuple. A candidate key is a minimal set of attributes necessary to identify a tuple; this is also called a minimal superkey. Given an employee schema consisting of the attributes employeeID, name, job, and departmentID, where no value in the employeeID attribute is ever repeated, we could use the employeeID in combination with any or all other attributes of this table to uniquely identify a tuple in the table. Examples of superkeys in this schema would be {employeeID, Name}, {employeeID, Name, job}, and {employeeID, Name, job, departmentID}. The last example is known as trivial superkey, because it uses all attributes of this table to identify the tuple.","position":{"start":{"line":84,"column":1,"offset":5995},"end":{"line":84,"column":760,"offset":6754},"indent":[]}}],"position":{"start":{"line":84,"column":1,"offset":5995},"end":{"line":84,"column":760,"offset":6754},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":87,"column":1,"offset":6757},"end":{"line":87,"column":31,"offset":6787},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":87,"column":31,"offset":6787}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"database-normalisaton\"\n    }}>{`Database Normalisaton`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://en.wikipedia.org/wiki/Database_normalization\"\n        }}>{`Database Normalisation`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://en.wikipedia.org/wiki/Candidate_key\"\n        }}>{`Candidate Key`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://en.wikipedia.org/wiki/Compound_key\"\n        }}>{`Compound Key`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://pediaa.com/what-is-the-difference-between-candidate-key-and-composite-key/\"\n        }}>{`Candidate vs Composite Keys`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://en.wikipedia.org/wiki/Superkey\"\n        }}>{`Super Key`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"what-is-it\"\n    }}>{`What is it?`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Database normalization is the process of structuring a relational database in accordance with a series of so-called normal forms in order to reduce data redundancy and improve data integrity. It was first proposed by Edgar F. Codd as part of his relational model.`}</p>\n    </blockquote>\n    <p>{`Normalization organises the columns (attributes) and tables (relations) of a database to ensure that their dependencies are properly enforced by database integrity constraints.`}</p>\n    <p>{`It is accomplished by applying some formal rules either by a process of synthesis (creating a new database design) or decomposition (improving an existing database design).`}</p>\n    <h2 {...{\n      \"id\": \"denormalisation-objectives\"\n    }}>{`Denormalisation Objectives`}</h2>\n    <p>{`The objectives beyond the first normal form (1NF):`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Free the collection of relations from undesirable insertion, update and deletion dependencies.`}</li>\n      <li parentName=\"ol\">{`Reduce the need for restructuring the collection of relatons, as new types of data are introduced, and thus increase the life span of application programs.`}</li>\n      <li parentName=\"ol\">{`Make the relational model more informative to users.`}</li>\n      <li parentName=\"ol\">{`Make the collection of relations neutral to query statistics, where these statistics are liable to change as time goes by.`}</li>\n    </ol>\n    <h2 {...{\n      \"id\": \"undesireable-side-effects\"\n    }}>{`Undesireable Side-Effects`}</h2>\n    <p>{`The following may be undesirable from unnormalisaed databases:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Update anomaly: The same info can be expressed in multiple rows, therefore updates to the relation may result in logical inconsistencies.`}</li>\n      <li parentName=\"ol\">{`Insertion anomaly: Circumstances where certain facts cannot be recorded at all. For example, each record in a \"Faculty and Their Courses\" relation might contain a Faculty ID, Faculty Name, Faculty Hire Date, and Course Code. Therefore, we can record the details of any faculty member who teaches at least one course, but we cannot record a newly hired faculty member who has not yet been assigned to teach any courses, except by setting the Course Code to null. This phenomenon is known as an insertion anomaly.`}</li>\n      <li parentName=\"ol\">{`Deletion anomaly: Under particular circumstances, deletion of data representing certain facts necessitates deletion of data representing completely different facts. The \"Faculty and Their Courses\" relation described in the previous example suffers from this type of anomaly, for if a faculty member temporarily ceases to be assigned to any courses, we must delete the last of the records on which that faculty member appears, effectively also deleting the faculty member, unless we set the Course Code to null. This phenomenon is known as a deletion anomaly.`}</li>\n    </ol>\n    <h2 {...{\n      \"id\": \"terms\"\n    }}>{`Terms`}</h2>\n    <h3 {...{\n      \"id\": \"candidate-key\"\n    }}>{`Candidate Key`}</h3>\n    <p>{`(from Wikipedia)`}</p>\n    <p>{`In the relational model of databases, a candidate key of a relation is a minimal superkey for that relation; that is, a set of attributes such that:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`the relation does not have two distinct tuples (i.e. rows or records in common database language) with the same values for these attributes (which means that the set of attributes is a superkey)`}</li>\n      <li parentName=\"ol\">{`there is no proper subset of these attributes for which (1) holds (which means that the set is minimal).`}</li>\n    </ol>\n    <p>{`Candidate keys are also variously referred to as primary keys, secondary keys or alternate keys.`}</p>\n    <p>{`The constituent attributes are called prime attributes. Conversely, an attribute that does not occur in ANY candidate key is called a non-prime attribute.`}</p>\n    <p>{`Since a relation contains no duplicate tuples, the set of all its attributes is a superkey if NULL values are not used. It follows that every relation will have at least one candidate key.`}</p>\n    <p>{`The candidate keys of a relation tell us all the possible ways we can identify its tuples. As such they are an important concept for the design of database schema.`}</p>\n    <h3 {...{\n      \"id\": \"candidate-vs-composite\"\n    }}>{`Candidate vs Composite`}</h3>\n    <p>{`A candidate key is a super key with no redundant attributes, while a composite key is a key that consists of two or more attributes that uniquely identify any row in the table. Thus, this is the main difference between candidate key and composite key.`}</p>\n    <p>{`In brief, the programmer can use various keys to connect the tables of a database. Two types of keys are candidate key and composite key. The main difference between candidate key and composite key is that candidate key is a super key with no redundant attributes, while the composite key is a key with two or many attributes to identify the rows of the table.`}</p>\n    <h3 {...{\n      \"id\": \"compound-key\"\n    }}>{`Compound Key`}</h3>\n    <p>{`(from Wikipedia)`}</p>\n    <p>{`In database design, a composite key is a candidate key that consists of two or more attributes (table columns) that together uniquely identify an entity occurrence (table row). A compound key is a composite key for which each attribute that makes up the key is a simple (foreign) key in its own right.`}</p>\n    <h3 {...{\n      \"id\": \"super-key\"\n    }}>{`Super Key`}</h3>\n    <p>{`(from Wikipedia)`}</p>\n    <p>{`A superkey or super-key is defined in the relational model of database organization as a set of attributes of a relation variable for which it holds that in all relations assigned to that variable, there are no two distinct tuples (rows) that have the same values for the attributes in this set.`}{`[1]`}{` It can be defined as a set of attributes of a relation schema upon which all attributes of the schema are functionally dependent.`}</p>\n    <p>{`The set of all attributes is a trivial superkey, because in relational algebra duplicate rows are not permitted: rows are a set (no duplicates), not a multiset (duplicates allowed). The superkey is also known as superset key.`}</p>\n    <p>{`If attribute set K is a superkey of relation R, then at all times it is the case that the projection of R over K has the same cardinality as R itself.`}</p>\n    <p>{`A superkey is a set of attributes within a table whose values can be used to uniquely identify a tuple. A candidate key is a minimal set of attributes necessary to identify a tuple; this is also called a minimal superkey. Given an employee schema consisting of the attributes employeeID, name, job, and departmentID, where no value in the employeeID attribute is ever repeated, we could use the employeeID in combination with any or all other attributes of this table to uniquely identify a tuple in the table. Examples of superkeys in this schema would be {employeeID, Name}, {employeeID, Name, job}, and {employeeID, Name, job, departmentID}. The last example is known as trivial superkey, because it uses all attributes of this table to identify the tuple.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}