{"expireTime":9007200852878430000,"key":"gatsby-plugin-mdx-entire-payload-0efef1d42e8d12a55692500cb239e94a-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"","position":{"start":{"line":3,"column":1,"offset":2},"end":{"line":3,"column":133,"offset":134},"indent":[]}},{"type":"export","default":true,"value":"export default DefaultLayout","position":{"start":{"line":5,"column":1,"offset":136},"end":{"line":5,"column":29,"offset":164},"indent":[]}},{"type":"heading","depth":1,"children":[{"type":"text","value":"Haskell From First Principles","position":{"start":{"line":8,"column":3,"offset":169},"end":{"line":8,"column":32,"offset":198},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":167},"end":{"line":8,"column":32,"offset":198},"indent":[]}},{"type":"import","value":"import 'katex/dist/katex.min.css';\nimport { BlockMath } from 'react-katex';","position":{"start":{"line":10,"column":1,"offset":200},"end":{"line":11,"column":41,"offset":275},"indent":[1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Resources","position":{"start":{"line":13,"column":4,"offset":280},"end":{"line":13,"column":13,"offset":289},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":277},"end":{"line":13,"column":13,"offset":289},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"link","title":null,"url":"https://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf","children":[{"type":"text","value":"A Tutorial Intro to Lambda Calculus","position":{"start":{"line":15,"column":5,"offset":295},"end":{"line":15,"column":40,"offset":330},"indent":[]}}],"position":{"start":{"line":15,"column":4,"offset":294},"end":{"line":15,"column":98,"offset":388},"indent":[]}}],"position":{"start":{"line":15,"column":4,"offset":294},"end":{"line":15,"column":98,"offset":388},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":291},"end":{"line":15,"column":98,"offset":388},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":291},"end":{"line":15,"column":98,"offset":388},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"What is a function","position":{"start":{"line":17,"column":4,"offset":393},"end":{"line":17,"column":22,"offset":411},"indent":[]}}],"position":{"start":{"line":17,"column":1,"offset":390},"end":{"line":17,"column":22,"offset":411},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"A set of possible inputs and a set of possible outputs","position":{"start":{"line":19,"column":3,"offset":415},"end":{"line":19,"column":57,"offset":469},"indent":[]}}],"position":{"start":{"line":19,"column":3,"offset":415},"end":{"line":19,"column":57,"offset":469},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":413},"end":{"line":19,"column":57,"offset":469},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"f(1) = A\" />\n<BlockMath math=\"f(2) = B\" />\n<BlockMath math=\"f(3) = C\" />","position":{"start":{"line":21,"column":1,"offset":471},"end":{"line":23,"column":30,"offset":560},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The input set (domain) is ","position":{"start":{"line":25,"column":1,"offset":562},"end":{"line":25,"column":27,"offset":588},"indent":[]}},{"type":"inlineCode","value":"{1,2,3}","position":{"start":{"line":25,"column":27,"offset":588},"end":{"line":25,"column":36,"offset":597},"indent":[]}},{"type":"text","value":" and the output set (codomain) is ","position":{"start":{"line":25,"column":36,"offset":597},"end":{"line":25,"column":70,"offset":631},"indent":[]}},{"type":"inlineCode","value":"{A,B,C}","position":{"start":{"line":25,"column":70,"offset":631},"end":{"line":25,"column":79,"offset":640},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":25,"column":79,"offset":640},"end":{"line":25,"column":80,"offset":641},"indent":[]}}],"position":{"start":{"line":25,"column":1,"offset":562},"end":{"line":25,"column":80,"offset":641},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In our function, an input of ","position":{"start":{"line":27,"column":1,"offset":643},"end":{"line":27,"column":30,"offset":672},"indent":[]}},{"type":"inlineCode","value":"1","position":{"start":{"line":27,"column":30,"offset":672},"end":{"line":27,"column":33,"offset":675},"indent":[]}},{"type":"text","value":" will ALWAYS return ","position":{"start":{"line":27,"column":33,"offset":675},"end":{"line":27,"column":53,"offset":695},"indent":[]}},{"type":"inlineCode","value":"A","position":{"start":{"line":27,"column":53,"offset":695},"end":{"line":27,"column":56,"offset":698},"indent":[]}},{"type":"text","value":", no exceptions.","position":{"start":{"line":27,"column":56,"offset":698},"end":{"line":27,"column":72,"offset":714},"indent":[]}}],"position":{"start":{"line":27,"column":1,"offset":643},"end":{"line":27,"column":72,"offset":714},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Lambda termd","position":{"start":{"line":29,"column":4,"offset":719},"end":{"line":29,"column":16,"offset":731},"indent":[]}}],"position":{"start":{"line":29,"column":1,"offset":716},"end":{"line":29,"column":16,"offset":731},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Lambda calculus has three basic components:","position":{"start":{"line":31,"column":1,"offset":733},"end":{"line":31,"column":44,"offset":776},"indent":[]}}],"position":{"start":{"line":31,"column":1,"offset":733},"end":{"line":31,"column":44,"offset":776},"indent":[]}},{"type":"list","ordered":true,"start":1,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Expressions","position":{"start":{"line":33,"column":4,"offset":781},"end":{"line":33,"column":15,"offset":792},"indent":[]}}],"position":{"start":{"line":33,"column":4,"offset":781},"end":{"line":33,"column":15,"offset":792},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":778},"end":{"line":33,"column":15,"offset":792},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Variables","position":{"start":{"line":34,"column":4,"offset":796},"end":{"line":34,"column":13,"offset":805},"indent":[]}}],"position":{"start":{"line":34,"column":4,"offset":796},"end":{"line":34,"column":13,"offset":805},"indent":[]}}],"position":{"start":{"line":34,"column":1,"offset":793},"end":{"line":34,"column":13,"offset":805},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Abstractions","position":{"start":{"line":35,"column":4,"offset":809},"end":{"line":35,"column":16,"offset":821},"indent":[]}}],"position":{"start":{"line":35,"column":4,"offset":809},"end":{"line":35,"column":16,"offset":821},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":806},"end":{"line":35,"column":16,"offset":821},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":778},"end":{"line":35,"column":16,"offset":821},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The word ","position":{"start":{"line":37,"column":1,"offset":823},"end":{"line":37,"column":10,"offset":832},"indent":[]}},{"type":"inlineCode","value":"expression","position":{"start":{"line":37,"column":10,"offset":832},"end":{"line":37,"column":22,"offset":844},"indent":[]}},{"type":"text","value":" refers to a superset of those things. It can be a variable name, an abstraction or a combination of those things.","position":{"start":{"line":37,"column":22,"offset":844},"end":{"line":37,"column":136,"offset":958},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":823},"end":{"line":37,"column":136,"offset":958},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"An ","position":{"start":{"line":39,"column":1,"offset":960},"end":{"line":39,"column":4,"offset":963},"indent":[]}},{"type":"inlineCode","value":"abstraction","position":{"start":{"line":39,"column":4,"offset":963},"end":{"line":39,"column":17,"offset":976},"indent":[]}},{"type":"text","value":" is a function. It is a lambda term that has a head (a lambda) and a body and is applied to an argument. An ","position":{"start":{"line":39,"column":17,"offset":976},"end":{"line":39,"column":125,"offset":1084},"indent":[]}},{"type":"inlineCode","value":"argument","position":{"start":{"line":39,"column":125,"offset":1084},"end":{"line":39,"column":135,"offset":1094},"indent":[]}},{"type":"text","value":" is an input value.","position":{"start":{"line":39,"column":135,"offset":1094},"end":{"line":39,"column":154,"offset":1113},"indent":[]}}],"position":{"start":{"line":39,"column":1,"offset":960},"end":{"line":39,"column":154,"offset":1113},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Abstractions consist of the ","position":{"start":{"line":41,"column":1,"offset":1115},"end":{"line":41,"column":29,"offset":1143},"indent":[]}},{"type":"inlineCode","value":"head","position":{"start":{"line":41,"column":29,"offset":1143},"end":{"line":41,"column":35,"offset":1149},"indent":[]}},{"type":"text","value":" and the ","position":{"start":{"line":41,"column":35,"offset":1149},"end":{"line":41,"column":44,"offset":1158},"indent":[]}},{"type":"inlineCode","value":"body","position":{"start":{"line":41,"column":44,"offset":1158},"end":{"line":41,"column":50,"offset":1164},"indent":[]}},{"type":"text","value":". The head of the function is a lambda followed by a variable name. The body of the function is another expression.","position":{"start":{"line":41,"column":50,"offset":1164},"end":{"line":41,"column":165,"offset":1279},"indent":[]}}],"position":{"start":{"line":41,"column":1,"offset":1115},"end":{"line":41,"column":165,"offset":1279},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A simple function might look like this:","position":{"start":{"line":43,"column":1,"offset":1281},"end":{"line":43,"column":40,"offset":1320},"indent":[]}}],"position":{"start":{"line":43,"column":1,"offset":1281},"end":{"line":43,"column":40,"offset":1320},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.x\" />","position":{"start":{"line":45,"column":1,"offset":1322},"end":{"line":45,"column":33,"offset":1354},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The variable named in the head is the ","position":{"start":{"line":47,"column":1,"offset":1356},"end":{"line":47,"column":39,"offset":1394},"indent":[]}},{"type":"inlineCode","value":"parameter","position":{"start":{"line":47,"column":39,"offset":1394},"end":{"line":47,"column":50,"offset":1405},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":47,"column":50,"offset":1405},"end":{"line":47,"column":55,"offset":1410},"indent":[]}},{"type":"inlineCode","value":"binds","position":{"start":{"line":47,"column":55,"offset":1410},"end":{"line":47,"column":62,"offset":1417},"indent":[]}},{"type":"text","value":" all instances of that same variable in the body of the function. In laymen terms, when we apply this function to an argument, each ","position":{"start":{"line":47,"column":62,"offset":1417},"end":{"line":47,"column":194,"offset":1549},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":47,"column":194,"offset":1549},"end":{"line":47,"column":197,"offset":1552},"indent":[]}},{"type":"text","value":" in the body of the function will have the value of that argument.","position":{"start":{"line":47,"column":197,"offset":1552},"end":{"line":47,"column":263,"offset":1618},"indent":[]}}],"position":{"start":{"line":47,"column":1,"offset":1356},"end":{"line":47,"column":263,"offset":1618},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the above, we were reference functions called ","position":{"start":{"line":49,"column":1,"offset":1620},"end":{"line":49,"column":50,"offset":1669},"indent":[]}},{"type":"inlineCode","value":"f","position":{"start":{"line":49,"column":50,"offset":1669},"end":{"line":49,"column":53,"offset":1672},"indent":[]}},{"type":"text","value":", but in the previous section the lambda astraction has no name and is an ","position":{"start":{"line":49,"column":53,"offset":1672},"end":{"line":49,"column":127,"offset":1746},"indent":[]}},{"type":"inlineCode","value":"anonymous function","position":{"start":{"line":49,"column":127,"offset":1746},"end":{"line":49,"column":147,"offset":1766},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":49,"column":147,"offset":1766},"end":{"line":49,"column":148,"offset":1767},"indent":[]}}],"position":{"start":{"line":49,"column":1,"offset":1620},"end":{"line":49,"column":148,"offset":1767},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A named function can be called by name by another function, a lambda cannot.","position":{"start":{"line":51,"column":1,"offset":1769},"end":{"line":51,"column":77,"offset":1845},"indent":[]}}],"position":{"start":{"line":51,"column":1,"offset":1769},"end":{"line":51,"column":77,"offset":1845},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Breakdown of the lambda","position":{"start":{"line":53,"column":5,"offset":1851},"end":{"line":53,"column":28,"offset":1874},"indent":[]}}],"position":{"start":{"line":53,"column":1,"offset":1847},"end":{"line":53,"column":28,"offset":1874},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The extent of the lambda:","position":{"start":{"line":55,"column":1,"offset":1876},"end":{"line":55,"column":26,"offset":1901},"indent":[]}}],"position":{"start":{"line":55,"column":1,"offset":1876},"end":{"line":55,"column":26,"offset":1901},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.\" />","position":{"start":{"line":57,"column":1,"offset":1903},"end":{"line":57,"column":32,"offset":1934},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The first ","position":{"start":{"line":59,"column":1,"offset":1936},"end":{"line":59,"column":11,"offset":1946},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":59,"column":11,"offset":1946},"end":{"line":59,"column":14,"offset":1949},"indent":[]}},{"type":"text","value":" is the single parameter of the function. This binds an variables:","position":{"start":{"line":59,"column":14,"offset":1949},"end":{"line":59,"column":80,"offset":2015},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":1936},"end":{"line":59,"column":80,"offset":2015},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The second ","position":{"start":{"line":61,"column":1,"offset":2017},"end":{"line":61,"column":12,"offset":2028},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":61,"column":12,"offset":2028},"end":{"line":61,"column":15,"offset":2031},"indent":[]}},{"type":"text","value":" is part of the body, the expression the lambda returns when applied. This is a bound variable.","position":{"start":{"line":61,"column":15,"offset":2031},"end":{"line":61,"column":110,"offset":2126},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":2017},"end":{"line":61,"column":110,"offset":2126},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The ","position":{"start":{"line":63,"column":1,"offset":2128},"end":{"line":63,"column":5,"offset":2132},"indent":[]}},{"type":"inlineCode","value":".","position":{"start":{"line":63,"column":5,"offset":2132},"end":{"line":63,"column":8,"offset":2135},"indent":[]}},{"type":"text","value":" separates the parameters of the lambda from the function body.","position":{"start":{"line":63,"column":8,"offset":2135},"end":{"line":63,"column":71,"offset":2198},"indent":[]}}],"position":{"start":{"line":63,"column":1,"offset":2128},"end":{"line":63,"column":71,"offset":2198},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Alpha Equivalence","position":{"start":{"line":65,"column":4,"offset":2203},"end":{"line":65,"column":21,"offset":2220},"indent":[]}}],"position":{"start":{"line":65,"column":1,"offset":2200},"end":{"line":65,"column":21,"offset":2220},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.x\" />","position":{"start":{"line":67,"column":1,"offset":2222},"end":{"line":67,"column":33,"offset":2254},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In the above expression, the variable ","position":{"start":{"line":69,"column":1,"offset":2256},"end":{"line":69,"column":39,"offset":2294},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":69,"column":39,"offset":2294},"end":{"line":69,"column":42,"offset":2297},"indent":[]}},{"type":"text","value":" is not semantically meaningful except in its role in that single expression. Because of this, there's a form of equivalence between lambda terms called ","position":{"start":{"line":69,"column":42,"offset":2297},"end":{"line":69,"column":195,"offset":2450},"indent":[]}},{"type":"inlineCode","value":"alpha equivalence","position":{"start":{"line":69,"column":195,"offset":2450},"end":{"line":69,"column":214,"offset":2469},"indent":[]}},{"type":"text","value":". This is a way of saying:","position":{"start":{"line":69,"column":214,"offset":2469},"end":{"line":69,"column":240,"offset":2495},"indent":[]}}],"position":{"start":{"line":69,"column":1,"offset":2256},"end":{"line":69,"column":240,"offset":2495},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.x = \\lambda d.d = \\lambda z.z\" />","position":{"start":{"line":71,"column":1,"offset":2497},"end":{"line":71,"column":61,"offset":2557},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Beta reduction","position":{"start":{"line":73,"column":4,"offset":2562},"end":{"line":73,"column":18,"offset":2576},"indent":[]}}],"position":{"start":{"line":73,"column":1,"offset":2559},"end":{"line":73,"column":18,"offset":2576},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When we apply a function to an argument, we substitute the input expression for all instances of the bound variables within the body of the abstraction. You also eliminate the head of the abstraction, since its only purpose was to bind the variable. This is called ","position":{"start":{"line":75,"column":1,"offset":2578},"end":{"line":75,"column":266,"offset":2843},"indent":[]}},{"type":"inlineCode","value":"beta reduction","position":{"start":{"line":75,"column":266,"offset":2843},"end":{"line":75,"column":282,"offset":2859},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":75,"column":282,"offset":2859},"end":{"line":75,"column":283,"offset":2860},"indent":[]}}],"position":{"start":{"line":75,"column":1,"offset":2578},"end":{"line":75,"column":283,"offset":2860},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can do one using a number. We apply the function above to ","position":{"start":{"line":77,"column":1,"offset":2862},"end":{"line":77,"column":62,"offset":2923},"indent":[]}},{"type":"inlineCode","value":"2","position":{"start":{"line":77,"column":62,"offset":2923},"end":{"line":77,"column":65,"offset":2926},"indent":[]}},{"type":"text","value":", substitude ","position":{"start":{"line":77,"column":65,"offset":2926},"end":{"line":77,"column":78,"offset":2939},"indent":[]}},{"type":"inlineCode","value":"2","position":{"start":{"line":77,"column":78,"offset":2939},"end":{"line":77,"column":81,"offset":2942},"indent":[]}},{"type":"text","value":" for each bound variable in the body of the function and eliminate the head:","position":{"start":{"line":77,"column":81,"offset":2942},"end":{"line":77,"column":157,"offset":3018},"indent":[]}}],"position":{"start":{"line":77,"column":1,"offset":2862},"end":{"line":77,"column":157,"offset":3018},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"( \\lambda x.x ) 2 = 2\" />","position":{"start":{"line":79,"column":1,"offset":3020},"end":{"line":79,"column":43,"offset":3062},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The only bound variable is a single ","position":{"start":{"line":81,"column":1,"offset":3064},"end":{"line":81,"column":37,"offset":3100},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":81,"column":37,"offset":3100},"end":{"line":81,"column":40,"offset":3103},"indent":[]}},{"type":"text","value":", so applying this function to 2 returns 2. This function is the ","position":{"start":{"line":81,"column":40,"offset":3103},"end":{"line":81,"column":105,"offset":3168},"indent":[]}},{"type":"inlineCode","value":"identity","position":{"start":{"line":81,"column":105,"offset":3168},"end":{"line":81,"column":115,"offset":3178},"indent":[]}},{"type":"text","value":" function.","position":{"start":{"line":81,"column":115,"offset":3178},"end":{"line":81,"column":125,"offset":3188},"indent":[]}}],"position":{"start":{"line":81,"column":1,"offset":3064},"end":{"line":81,"column":125,"offset":3188},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Free variables","position":{"start":{"line":83,"column":4,"offset":3193},"end":{"line":83,"column":18,"offset":3207},"indent":[]}}],"position":{"start":{"line":83,"column":1,"offset":3190},"end":{"line":83,"column":18,"offset":3207},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"\\lambda x.xy\" />","position":{"start":{"line":85,"column":1,"offset":3209},"end":{"line":85,"column":34,"offset":3242},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"In this example, ","position":{"start":{"line":87,"column":1,"offset":3244},"end":{"line":87,"column":18,"offset":3261},"indent":[]}},{"type":"inlineCode","value":"x","position":{"start":{"line":87,"column":18,"offset":3261},"end":{"line":87,"column":21,"offset":3264},"indent":[]}},{"type":"text","value":" is a bound variable, ","position":{"start":{"line":87,"column":21,"offset":3264},"end":{"line":87,"column":43,"offset":3286},"indent":[]}},{"type":"inlineCode","value":"y","position":{"start":{"line":87,"column":43,"offset":3286},"end":{"line":87,"column":46,"offset":3289},"indent":[]}},{"type":"text","value":" is a free variable.","position":{"start":{"line":87,"column":46,"offset":3289},"end":{"line":87,"column":66,"offset":3309},"indent":[]}}],"position":{"start":{"line":87,"column":1,"offset":3244},"end":{"line":87,"column":66,"offset":3309},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Multiple arguments","position":{"start":{"line":89,"column":4,"offset":3314},"end":{"line":89,"column":22,"offset":3332},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":3311},"end":{"line":89,"column":22,"offset":3332},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Each lambda can only bind one parameter and can only accept one argument. Functions that require multiple arguments have multiple, nested heads. When you apply it once and eliminate the first (leftmost) head, the next is applied and so on. It is know as ","position":{"start":{"line":91,"column":3,"offset":3336},"end":{"line":91,"column":257,"offset":3590},"indent":[]}},{"type":"inlineCode","value":"currying","position":{"start":{"line":91,"column":257,"offset":3590},"end":{"line":91,"column":267,"offset":3600},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":91,"column":267,"offset":3600},"end":{"line":91,"column":268,"offset":3601},"indent":[]}}],"position":{"start":{"line":91,"column":3,"offset":3336},"end":{"line":91,"column":268,"offset":3601},"indent":[]}}],"position":{"start":{"line":91,"column":1,"offset":3334},"end":{"line":91,"column":268,"offset":3601},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Evaluation is simplication","position":{"start":{"line":93,"column":4,"offset":3606},"end":{"line":93,"column":30,"offset":3632},"indent":[]}}],"position":{"start":{"line":93,"column":1,"offset":3603},"end":{"line":93,"column":30,"offset":3632},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"There are multiple normal forms in lambda calculus, but here when we refer to normal form we mean ","position":{"start":{"line":95,"column":1,"offset":3634},"end":{"line":95,"column":99,"offset":3732},"indent":[]}},{"type":"inlineCode","value":"beta normal form","position":{"start":{"line":95,"column":99,"offset":3732},"end":{"line":95,"column":117,"offset":3750},"indent":[]}},{"type":"text","value":". This corresponds to a fully evaluated expression (or a fully executed program). For example, do you say ","position":{"start":{"line":95,"column":117,"offset":3750},"end":{"line":95,"column":223,"offset":3856},"indent":[]}},{"type":"inlineCode","value":"2000/1000","position":{"start":{"line":95,"column":223,"offset":3856},"end":{"line":95,"column":234,"offset":3867},"indent":[]}},{"type":"text","value":" or do you say 2? You say 2. The normal form of the evaluated expression is therefore 2.","position":{"start":{"line":95,"column":234,"offset":3867},"end":{"line":95,"column":322,"offset":3955},"indent":[]}}],"position":{"start":{"line":95,"column":1,"offset":3634},"end":{"line":95,"column":322,"offset":3955},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Note: if we had function ","position":{"start":{"line":97,"column":1,"offset":3957},"end":{"line":97,"column":26,"offset":3982},"indent":[]}},{"type":"inlineCode","value":"(x,y) => x/y","position":{"start":{"line":97,"column":26,"offset":3982},"end":{"line":97,"column":40,"offset":3996},"indent":[]}},{"type":"text","value":" and apply ","position":{"start":{"line":97,"column":40,"offset":3996},"end":{"line":97,"column":51,"offset":4007},"indent":[]}},{"type":"inlineCode","value":"x = 2000","position":{"start":{"line":97,"column":51,"offset":4007},"end":{"line":97,"column":61,"offset":4017},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":97,"column":61,"offset":4017},"end":{"line":97,"column":66,"offset":4022},"indent":[]}},{"type":"inlineCode","value":"y = 1000","position":{"start":{"line":97,"column":66,"offset":4022},"end":{"line":97,"column":76,"offset":4032},"indent":[]}},{"type":"text","value":", we call the the body with all arguments applied ","position":{"start":{"line":97,"column":76,"offset":4032},"end":{"line":97,"column":126,"offset":4082},"indent":[]}},{"type":"inlineCode","value":"saturated","position":{"start":{"line":97,"column":126,"offset":4082},"end":{"line":97,"column":137,"offset":4093},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":97,"column":137,"offset":4093},"end":{"line":97,"column":138,"offset":4094},"indent":[]}}],"position":{"start":{"line":97,"column":1,"offset":3957},"end":{"line":97,"column":138,"offset":4094},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Combinators","position":{"start":{"line":99,"column":4,"offset":4099},"end":{"line":99,"column":15,"offset":4110},"indent":[]}}],"position":{"start":{"line":99,"column":1,"offset":4096},"end":{"line":99,"column":15,"offset":4110},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"A ","position":{"start":{"line":101,"column":1,"offset":4112},"end":{"line":101,"column":3,"offset":4114},"indent":[]}},{"type":"inlineCode","value":"combinator","position":{"start":{"line":101,"column":3,"offset":4114},"end":{"line":101,"column":15,"offset":4126},"indent":[]}},{"type":"text","value":" is a lambda term with no free variables. Combinators, as the name suggests, serve only to ","position":{"start":{"line":101,"column":15,"offset":4126},"end":{"line":101,"column":106,"offset":4217},"indent":[]}},{"type":"inlineCode","value":"combine","position":{"start":{"line":101,"column":106,"offset":4217},"end":{"line":101,"column":115,"offset":4226},"indent":[]}},{"type":"text","value":" the arguments that they are given.","position":{"start":{"line":101,"column":115,"offset":4226},"end":{"line":101,"column":150,"offset":4261},"indent":[]}}],"position":{"start":{"line":101,"column":1,"offset":4112},"end":{"line":101,"column":150,"offset":4261},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Divergence","position":{"start":{"line":103,"column":4,"offset":4266},"end":{"line":103,"column":14,"offset":4276},"indent":[]}}],"position":{"start":{"line":103,"column":1,"offset":4263},"end":{"line":103,"column":14,"offset":4276},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Not all reducible lambda terms reduce neatly to a beta normal form. Reducing the following repeats itself:","position":{"start":{"line":105,"column":1,"offset":4278},"end":{"line":105,"column":107,"offset":4384},"indent":[]}}],"position":{"start":{"line":105,"column":1,"offset":4278},"end":{"line":105,"column":107,"offset":4384},"indent":[]}},{"type":"jsx","value":"<BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" />\n<BlockMath math=\"(x := \\lambda x.xx|xx)\" />\n<BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" />","position":{"start":{"line":107,"column":1,"offset":4386},"end":{"line":109,"column":50,"offset":4529},"indent":[1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Hello, Haskell!","position":{"start":{"line":111,"column":4,"offset":4534},"end":{"line":111,"column":19,"offset":4549},"indent":[]}}],"position":{"start":{"line":111,"column":1,"offset":4531},"end":{"line":111,"column":19,"offset":4549},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- Say Hello\nsayHello :: String -> IO ()\nsayHello x =\n  putStrLn (\"Hello, \" ++ x ++ \"!\")","position":{"start":{"line":113,"column":1,"offset":4551},"end":{"line":118,"column":4,"offset":4654},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"If in the ","position":{"start":{"line":120,"column":1,"offset":4656},"end":{"line":120,"column":11,"offset":4666},"indent":[]}},{"type":"inlineCode","value":"stack ghci","position":{"start":{"line":120,"column":11,"offset":4666},"end":{"line":120,"column":23,"offset":4678},"indent":[]}},{"type":"text","value":" REPL, you can unload the file using ","position":{"start":{"line":120,"column":23,"offset":4678},"end":{"line":120,"column":60,"offset":4715},"indent":[]}},{"type":"inlineCode","value":":m","position":{"start":{"line":120,"column":60,"offset":4715},"end":{"line":120,"column":64,"offset":4719},"indent":[]}},{"type":"text","value":" and reload updated files using ","position":{"start":{"line":120,"column":64,"offset":4719},"end":{"line":120,"column":96,"offset":4751},"indent":[]}},{"type":"inlineCode","value":":r","position":{"start":{"line":120,"column":96,"offset":4751},"end":{"line":120,"column":100,"offset":4755},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":120,"column":100,"offset":4755},"end":{"line":120,"column":101,"offset":4756},"indent":[]}}],"position":{"start":{"line":120,"column":1,"offset":4656},"end":{"line":120,"column":101,"offset":4756},"indent":[]}},{"type":"heading","depth":3,"children":[{"type":"text","value":"Normal Form Reminder","position":{"start":{"line":122,"column":5,"offset":4762},"end":{"line":122,"column":25,"offset":4782},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":4758},"end":{"line":122,"column":25,"offset":4782},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Haskell reduces until we reach the normal form. Remember, ","position":{"start":{"line":124,"column":1,"offset":4784},"end":{"line":124,"column":59,"offset":4842},"indent":[]}},{"type":"inlineCode","value":"1 + 1","position":{"start":{"line":124,"column":59,"offset":4842},"end":{"line":124,"column":66,"offset":4849},"indent":[]}},{"type":"text","value":" can be evaluated to ","position":{"start":{"line":124,"column":66,"offset":4849},"end":{"line":124,"column":87,"offset":4870},"indent":[]}},{"type":"inlineCode","value":"2","position":{"start":{"line":124,"column":87,"offset":4870},"end":{"line":124,"column":90,"offset":4873},"indent":[]}},{"type":"text","value":", thus Haskell returns the normal form.","position":{"start":{"line":124,"column":90,"offset":4873},"end":{"line":124,"column":129,"offset":4912},"indent":[]}}],"position":{"start":{"line":124,"column":1,"offset":4784},"end":{"line":124,"column":129,"offset":4912},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Redexes","position":{"start":{"line":126,"column":4,"offset":4917},"end":{"line":126,"column":11,"offset":4924},"indent":[]}}],"position":{"start":{"line":126,"column":1,"offset":4914},"end":{"line":126,"column":11,"offset":4924},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Reducibles expressions such as ","position":{"start":{"line":128,"column":1,"offset":4926},"end":{"line":128,"column":32,"offset":4957},"indent":[]}},{"type":"inlineCode","value":"1 + 1","position":{"start":{"line":128,"column":32,"offset":4957},"end":{"line":128,"column":39,"offset":4964},"indent":[]}},{"type":"text","value":" are also known as ","position":{"start":{"line":128,"column":39,"offset":4964},"end":{"line":128,"column":58,"offset":4983},"indent":[]}},{"type":"inlineCode","value":"redexes","position":{"start":{"line":128,"column":58,"offset":4983},"end":{"line":128,"column":67,"offset":4992},"indent":[]}},{"type":"text","value":". While we generally refer to this process as evaluation or reduction, you may also hear of it as ","position":{"start":{"line":128,"column":67,"offset":4992},"end":{"line":128,"column":165,"offset":5090},"indent":[]}},{"type":"inlineCode","value":"normalizing","position":{"start":{"line":128,"column":165,"offset":5090},"end":{"line":128,"column":178,"offset":5103},"indent":[]}},{"type":"text","value":" or ","position":{"start":{"line":128,"column":178,"offset":5103},"end":{"line":128,"column":182,"offset":5107},"indent":[]}},{"type":"inlineCode","value":"executing","position":{"start":{"line":128,"column":182,"offset":5107},"end":{"line":128,"column":193,"offset":5118},"indent":[]}},{"type":"text","value":" an expression (though somewhat imprecise).","position":{"start":{"line":128,"column":193,"offset":5118},"end":{"line":128,"column":236,"offset":5161},"indent":[]}}],"position":{"start":{"line":128,"column":1,"offset":4926},"end":{"line":128,"column":236,"offset":5161},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Functions","position":{"start":{"line":130,"column":4,"offset":5166},"end":{"line":130,"column":13,"offset":5175},"indent":[]}}],"position":{"start":{"line":130,"column":1,"offset":5163},"end":{"line":130,"column":13,"offset":5175},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Functions are a specific type of expression. Functions in Haskell relate to functions in mathematics - they map an input or set of inputs to an output.","position":{"start":{"line":132,"column":1,"offset":5177},"end":{"line":132,"column":152,"offset":5328},"indent":[]}}],"position":{"start":{"line":132,"column":1,"offset":5177},"end":{"line":132,"column":152,"offset":5328},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Because they are built purely of expressions, they will always evaluate to the same result when given the same values.","position":{"start":{"line":134,"column":1,"offset":5330},"end":{"line":134,"column":119,"offset":5448},"indent":[]}}],"position":{"start":{"line":134,"column":1,"offset":5330},"end":{"line":134,"column":119,"offset":5448},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"As with Lambda Calculus, all functions in Haskell take one argument and return one result. Even when it seems we are passing multiple arguments, we are actually applying a series of nested functions (each to one argument). This is called ","position":{"start":{"line":136,"column":3,"offset":5452},"end":{"line":136,"column":241,"offset":5690},"indent":[]}},{"type":"inlineCode","value":"currying","position":{"start":{"line":136,"column":241,"offset":5690},"end":{"line":136,"column":251,"offset":5700},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":136,"column":251,"offset":5700},"end":{"line":136,"column":252,"offset":5701},"indent":[]}}],"position":{"start":{"line":136,"column":3,"offset":5452},"end":{"line":136,"column":252,"offset":5701},"indent":[]}}],"position":{"start":{"line":136,"column":1,"offset":5450},"end":{"line":136,"column":252,"offset":5701},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- in GHCi REPL\nlet triple x = x * 3\n-- in source file\ntriple :: Number -> Number\ntriple x = x * 3","position":{"start":{"line":138,"column":1,"offset":5703},"end":{"line":144,"column":4,"offset":5816},"indent":[1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Evaluation","position":{"start":{"line":146,"column":4,"offset":5821},"end":{"line":146,"column":14,"offset":5831},"indent":[]}}],"position":{"start":{"line":146,"column":1,"offset":5818},"end":{"line":146,"column":14,"offset":5831},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When we talk about evaluating an expression, we're talking about reducing the terms until it is in the simplest form. We say it is ","position":{"start":{"line":148,"column":1,"offset":5833},"end":{"line":148,"column":132,"offset":5964},"indent":[]}},{"type":"inlineCode","value":"irreducible","position":{"start":{"line":148,"column":132,"offset":5964},"end":{"line":148,"column":145,"offset":5977},"indent":[]}},{"type":"text","value":" or finished evaluating.","position":{"start":{"line":148,"column":145,"offset":5977},"end":{"line":148,"column":169,"offset":6001},"indent":[]}}],"position":{"start":{"line":148,"column":1,"offset":5833},"end":{"line":148,"column":169,"offset":6001},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Haskell uses ","position":{"start":{"line":150,"column":1,"offset":6003},"end":{"line":150,"column":14,"offset":6016},"indent":[]}},{"type":"inlineCode","value":"nonstrict evaluation","position":{"start":{"line":150,"column":14,"offset":6016},"end":{"line":150,"column":36,"offset":6038},"indent":[]}},{"type":"text","value":" (sometimes called ","position":{"start":{"line":150,"column":36,"offset":6038},"end":{"line":150,"column":55,"offset":6057},"indent":[]}},{"type":"inlineCode","value":"lazy evaluation","position":{"start":{"line":150,"column":55,"offset":6057},"end":{"line":150,"column":72,"offset":6074},"indent":[]}},{"type":"text","value":") stategy which defers evaluations of terms until they're forced by other terms referring so them.","position":{"start":{"line":150,"column":72,"offset":6074},"end":{"line":150,"column":170,"offset":6172},"indent":[]}}],"position":{"start":{"line":150,"column":1,"offset":6003},"end":{"line":150,"column":170,"offset":6172},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Here is the reduction of our ","position":{"start":{"line":152,"column":1,"offset":6174},"end":{"line":152,"column":30,"offset":6203},"indent":[]}},{"type":"inlineCode","value":"triple","position":{"start":{"line":152,"column":30,"offset":6203},"end":{"line":152,"column":38,"offset":6211},"indent":[]}},{"type":"text","value":" function:","position":{"start":{"line":152,"column":38,"offset":6211},"end":{"line":152,"column":48,"offset":6221},"indent":[]}}],"position":{"start":{"line":152,"column":1,"offset":6174},"end":{"line":152,"column":48,"offset":6221},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"triple 2\n-- [triple x = x * 3; x:= 2]\n2 * 3\n6","position":{"start":{"line":154,"column":1,"offset":6223},"end":{"line":159,"column":4,"offset":6283},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The above is reduced to its normal form, however Haskell only evalutes is weak head normal form (WHNF) but default. This means things are not always reduced to its irreducible form straight away.","position":{"start":{"line":161,"column":1,"offset":6285},"end":{"line":161,"column":196,"offset":6480},"indent":[]}}],"position":{"start":{"line":161,"column":1,"offset":6285},"end":{"line":161,"column":196,"offset":6480},"indent":[]}},{"type":"paragraph","children":[{"type":"inlineCode","value":"(\\f -> (1, 2 + f)) 2","position":{"start":{"line":163,"column":1,"offset":6482},"end":{"line":163,"column":23,"offset":6504},"indent":[]}},{"type":"text","value":" reduces to the following in WHNF ","position":{"start":{"line":163,"column":23,"offset":6504},"end":{"line":163,"column":57,"offset":6538},"indent":[]}},{"type":"inlineCode","value":"(1, 2 + 2)","position":{"start":{"line":163,"column":57,"offset":6538},"end":{"line":163,"column":69,"offset":6550},"indent":[]}},{"type":"text","value":" before it is evaluated further.","position":{"start":{"line":163,"column":69,"offset":6550},"end":{"line":163,"column":101,"offset":6582},"indent":[]}}],"position":{"start":{"line":163,"column":1,"offset":6482},"end":{"line":163,"column":101,"offset":6582},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Infix Operators","position":{"start":{"line":165,"column":4,"offset":6587},"end":{"line":165,"column":19,"offset":6602},"indent":[]}}],"position":{"start":{"line":165,"column":1,"offset":6584},"end":{"line":165,"column":19,"offset":6602},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Functions in Haskell default to prefix syntax (like the ","position":{"start":{"line":167,"column":1,"offset":6604},"end":{"line":167,"column":57,"offset":6660},"indent":[]}},{"type":"inlineCode","value":"triple","position":{"start":{"line":167,"column":57,"offset":6660},"end":{"line":167,"column":65,"offset":6668},"indent":[]}},{"type":"text","value":" func above).","position":{"start":{"line":167,"column":65,"offset":6668},"end":{"line":167,"column":78,"offset":6681},"indent":[]}}],"position":{"start":{"line":167,"column":1,"offset":6604},"end":{"line":167,"column":78,"offset":6681},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Operators for example are functions that can be used in the infix style.","position":{"start":{"line":169,"column":1,"offset":6683},"end":{"line":169,"column":73,"offset":6755},"indent":[]}}],"position":{"start":{"line":169,"column":1,"offset":6683},"end":{"line":169,"column":73,"offset":6755},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"You can sometimes use functions infix style with a small change in syntax:","position":{"start":{"line":171,"column":1,"offset":6757},"end":{"line":171,"column":75,"offset":6831},"indent":[]}}],"position":{"start":{"line":171,"column":1,"offset":6757},"end":{"line":171,"column":75,"offset":6831},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"10 `div` 4\ndiv 10 4\n(/) 10 4\n2.5","position":{"start":{"line":173,"column":1,"offset":6833},"end":{"line":178,"column":4,"offset":6880},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"If the function is alphanumeric, it is prefix by default. If it is a symbol, it is infix by default.","position":{"start":{"line":180,"column":1,"offset":6882},"end":{"line":180,"column":101,"offset":6982},"indent":[]}}],"position":{"start":{"line":180,"column":1,"offset":6882},"end":{"line":180,"column":101,"offset":6982},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Associativity and precedence","position":{"start":{"line":182,"column":4,"offset":6987},"end":{"line":182,"column":32,"offset":7015},"indent":[]}}],"position":{"start":{"line":182,"column":1,"offset":6984},"end":{"line":182,"column":32,"offset":7015},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This BODMAS (from Mathematics) for precedence.","position":{"start":{"line":184,"column":1,"offset":7017},"end":{"line":184,"column":47,"offset":7063},"indent":[]}}],"position":{"start":{"line":184,"column":1,"offset":7017},"end":{"line":184,"column":47,"offset":7063},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can use ","position":{"start":{"line":186,"column":1,"offset":7065},"end":{"line":186,"column":12,"offset":7076},"indent":[]}},{"type":"inlineCode","value":":info","position":{"start":{"line":186,"column":12,"offset":7076},"end":{"line":186,"column":19,"offset":7083},"indent":[]}},{"type":"text","value":" to get more info about an operator.","position":{"start":{"line":186,"column":19,"offset":7083},"end":{"line":186,"column":55,"offset":7119},"indent":[]}}],"position":{"start":{"line":186,"column":1,"offset":7065},"end":{"line":186,"column":55,"offset":7119},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"Prelude> :i (/) (+) (-)\nclass Num a => Fractional a where\n  (/) :: a -> a -> a\n  ...\n        -- Defined in ‘GHC.Real’\ninfixl 7 /\nclass Num a where\n  (+) :: a -> a -> a\n  ...\n        -- Defined in ‘GHC.Num’\ninfixl 6 +\nclass Num a where\n  ...\n  (-) :: a -> a -> a\n  ...\n        -- Defined in ‘GHC.Num’\ninfixl 6 -","position":{"start":{"line":188,"column":1,"offset":7121},"end":{"line":206,"column":4,"offset":7446},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"infixl","position":{"start":{"line":208,"column":3,"offset":7450},"end":{"line":208,"column":11,"offset":7458},"indent":[]}},{"type":"text","value":" means infix operator and left associative","position":{"start":{"line":208,"column":11,"offset":7458},"end":{"line":208,"column":53,"offset":7500},"indent":[]}}],"position":{"start":{"line":208,"column":3,"offset":7450},"end":{"line":208,"column":53,"offset":7500},"indent":[]}}],"position":{"start":{"line":208,"column":1,"offset":7448},"end":{"line":208,"column":53,"offset":7500},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"7|6","position":{"start":{"line":209,"column":3,"offset":7503},"end":{"line":209,"column":8,"offset":7508},"indent":[]}},{"type":"text","value":" is the precendence - higher is applied first","position":{"start":{"line":209,"column":8,"offset":7508},"end":{"line":209,"column":53,"offset":7553},"indent":[]}}],"position":{"start":{"line":209,"column":3,"offset":7503},"end":{"line":209,"column":53,"offset":7553},"indent":[]}}],"position":{"start":{"line":209,"column":1,"offset":7501},"end":{"line":209,"column":53,"offset":7553},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"The last part is the function name (in this case the ","position":{"start":{"line":210,"column":3,"offset":7556},"end":{"line":210,"column":56,"offset":7609},"indent":[]}},{"type":"inlineCode","value":"/","position":{"start":{"line":210,"column":56,"offset":7609},"end":{"line":210,"column":59,"offset":7612},"indent":[]}},{"type":"text","value":", ","position":{"start":{"line":210,"column":59,"offset":7612},"end":{"line":210,"column":61,"offset":7614},"indent":[]}},{"type":"inlineCode","value":"+","position":{"start":{"line":210,"column":61,"offset":7614},"end":{"line":210,"column":64,"offset":7617},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":210,"column":64,"offset":7617},"end":{"line":210,"column":69,"offset":7622},"indent":[]}},{"type":"inlineCode","value":"-","position":{"start":{"line":210,"column":69,"offset":7622},"end":{"line":210,"column":72,"offset":7625},"indent":[]}},{"type":"text","value":")","position":{"start":{"line":210,"column":72,"offset":7625},"end":{"line":210,"column":73,"offset":7626},"indent":[]}}],"position":{"start":{"line":210,"column":3,"offset":7556},"end":{"line":210,"column":73,"offset":7626},"indent":[]}}],"position":{"start":{"line":210,"column":1,"offset":7554},"end":{"line":210,"column":73,"offset":7626},"indent":[]}}],"position":{"start":{"line":208,"column":1,"offset":7448},"end":{"line":210,"column":73,"offset":7626},"indent":[1,1]}},{"type":"paragraph","children":[{"type":"text","value":"An example of a right-associative infix operator is the power operator ","position":{"start":{"line":212,"column":1,"offset":7628},"end":{"line":212,"column":72,"offset":7699},"indent":[]}},{"type":"inlineCode","value":"^","position":{"start":{"line":212,"column":72,"offset":7699},"end":{"line":212,"column":75,"offset":7702},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":212,"column":75,"offset":7702},"end":{"line":212,"column":76,"offset":7703},"indent":[]}}],"position":{"start":{"line":212,"column":1,"offset":7628},"end":{"line":212,"column":76,"offset":7703},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Declaring values","position":{"start":{"line":214,"column":4,"offset":7708},"end":{"line":214,"column":20,"offset":7724},"indent":[]}}],"position":{"start":{"line":214,"column":1,"offset":7705},"end":{"line":214,"column":20,"offset":7724},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- in the REPL\nPrelude> let y = 10\nPrelude> let x = 10 * 5 + y\nPrelude> let myResult = x * 5\n-- in a file\n-- learn.hs\nmodule Learn where\nx = 10 * 5 + y\nmyResult = x * 5\ny = 10","position":{"start":{"line":216,"column":1,"offset":7726},"end":{"line":227,"column":4,"offset":7916},"indent":[1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"\\$ Operator","position":{"start":{"line":229,"column":4,"offset":7921},"end":{"line":229,"column":15,"offset":7932},"indent":[]}}],"position":{"start":{"line":229,"column":1,"offset":7918},"end":{"line":229,"column":15,"offset":7932},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The (\\$) operator is a convenience for when you want to express something with fewer pairs of parentheses:","position":{"start":{"line":231,"column":1,"offset":7934},"end":{"line":231,"column":107,"offset":8040},"indent":[]}}],"position":{"start":{"line":231,"column":1,"offset":7934},"end":{"line":231,"column":107,"offset":8040},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":" -- Remember ($)'s definition\nf $ a = f a\n-- in use\nPrelude> (2^) (2 + 2)\n16\n-- can replace those parentheses\n Prelude> (2^) $ 2 + 2\n16\n-- without either parentheses or $\n Prelude> (2^) 2 + 2\n 6","position":{"start":{"line":233,"column":1,"offset":8042},"end":{"line":245,"column":4,"offset":8251},"indent":[1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The (\\$) will allow everything to the right of it to be evaluated first and can be used to delay function application.","position":{"start":{"line":247,"column":1,"offset":8253},"end":{"line":247,"column":119,"offset":8371},"indent":[]}}],"position":{"start":{"line":247,"column":1,"offset":8253},"end":{"line":247,"column":119,"offset":8371},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Let and where","position":{"start":{"line":249,"column":4,"offset":8376},"end":{"line":249,"column":17,"offset":8389},"indent":[]}}],"position":{"start":{"line":249,"column":1,"offset":8373},"end":{"line":249,"column":17,"offset":8389},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The contrast here is that let introduces an expression, so it can be used wherever you can have an expression, but where is a declaration and is bound to a surrounding syntactic construct.","position":{"start":{"line":251,"column":1,"offset":8391},"end":{"line":251,"column":189,"offset":8579},"indent":[]}}],"position":{"start":{"line":251,"column":1,"offset":8391},"end":{"line":251,"column":189,"offset":8579},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- FunctionWithWhere.hs\nmodule FunctionWithWhere where\n\nprintInc n = print plusTwo\n  where plusTwo = n + 2\n\n\nprintInc2 n = let plusTwo = n + 2\n  in print plusTwo","position":{"start":{"line":253,"column":1,"offset":8581},"end":{"line":263,"column":4,"offset":8757},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Strings","position":{"start":{"line":265,"column":4,"offset":8762},"end":{"line":265,"column":11,"offset":8769},"indent":[]}}],"position":{"start":{"line":265,"column":1,"offset":8759},"end":{"line":265,"column":11,"offset":8769},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"Prelude> :type 'a'\n'a' :: Char\nPrelude> :type \"Hello!\"\n\"Hello!\" :: [Char]","position":{"start":{"line":267,"column":1,"offset":8771},"end":{"line":272,"column":4,"offset":8859},"indent":[1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"To print strings we can use ","position":{"start":{"line":274,"column":1,"offset":8861},"end":{"line":274,"column":29,"offset":8889},"indent":[]}},{"type":"inlineCode","value":"print","position":{"start":{"line":274,"column":29,"offset":8889},"end":{"line":274,"column":36,"offset":8896},"indent":[]}},{"type":"text","value":" in the REPL or ","position":{"start":{"line":274,"column":36,"offset":8896},"end":{"line":274,"column":52,"offset":8912},"indent":[]}},{"type":"inlineCode","value":"putStrLn","position":{"start":{"line":274,"column":52,"offset":8912},"end":{"line":274,"column":62,"offset":8922},"indent":[]}},{"type":"text","value":" and ","position":{"start":{"line":274,"column":62,"offset":8922},"end":{"line":274,"column":67,"offset":8927},"indent":[]}},{"type":"inlineCode","value":"putStr","position":{"start":{"line":274,"column":67,"offset":8927},"end":{"line":274,"column":75,"offset":8935},"indent":[]}},{"type":"text","value":" for our Haskell modules.","position":{"start":{"line":274,"column":75,"offset":8935},"end":{"line":274,"column":100,"offset":8960},"indent":[]}}],"position":{"start":{"line":274,"column":1,"offset":8861},"end":{"line":274,"column":100,"offset":8960},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Mutliline \"do\" can be done like so:","position":{"start":{"line":276,"column":1,"offset":8962},"end":{"line":276,"column":36,"offset":8997},"indent":[]}}],"position":{"start":{"line":276,"column":1,"offset":8962},"end":{"line":276,"column":36,"offset":8997},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- print2.hs\nmodule Print2 where\nmain :: IO () main = do\n  putStrLn \"Count to four for me:\"\n  putStr   \"one, two\"\n  putStr   \", three, and\"\n  putStrLn \" four!\"","position":{"start":{"line":278,"column":1,"offset":8999},"end":{"line":286,"column":4,"offset":9173},"indent":[1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"String concatenation:","position":{"start":{"line":288,"column":1,"offset":9175},"end":{"line":288,"column":22,"offset":9196},"indent":[]}}],"position":{"start":{"line":288,"column":1,"offset":9175},"end":{"line":288,"column":22,"offset":9196},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"-- print3.hs\nmodule Print3 where\n\nmyGreeting :: String\nmyGreeting = \"hello\" ++ \" world!\" hello :: String\n\nhello = \"hello\" world :: String\nworld = \"world!\"\n\nmain :: IO () main = do\n  putStrLn myGreeting\n  putStrLn secondGreeting\n  where secondGreeting =\n    concat [hello, \" \", world]","position":{"start":{"line":290,"column":1,"offset":9198},"end":{"line":305,"column":4,"offset":9496},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Top-level versus local definitions","position":{"start":{"line":307,"column":4,"offset":9501},"end":{"line":307,"column":38,"offset":9535},"indent":[]}}],"position":{"start":{"line":307,"column":1,"offset":9498},"end":{"line":307,"column":38,"offset":9535},"indent":[]}},{"type":"code","lang":"haskell","meta":null,"value":"module TopOrLocal where\n\ntopLevelFunction :: Integer -> Integer topLevelFunction x =\n  x + woot + topLevelValue\n  where woot :: Integer\n        woot = 10\n\ntopLevelValue :: Integer\ntopLevelValue = 5","position":{"start":{"line":309,"column":1,"offset":9537},"end":{"line":319,"column":4,"offset":9749},"indent":[1,1,1,1,1,1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Basic Datatypes","position":{"start":{"line":321,"column":4,"offset":9754},"end":{"line":321,"column":19,"offset":9769},"indent":[]}}],"position":{"start":{"line":321,"column":1,"offset":9751},"end":{"line":321,"column":19,"offset":9769},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"The type constructor is the name of the type and is capitalized. When you are reading or writing type signatures (the type level of your code), the type names or type constructors are what you use.","position":{"start":{"line":323,"column":1,"offset":9771},"end":{"line":323,"column":198,"offset":9968},"indent":[]}}],"position":{"start":{"line":323,"column":1,"offset":9771},"end":{"line":323,"column":198,"offset":9968},"indent":[]}},{"type":"export","value":"export const _frontmatter = {}","position":{"start":{"line":326,"column":1,"offset":9971},"end":{"line":326,"column":31,"offset":10001},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":326,"column":31,"offset":10001}}},"scopeImports":[],"scopeIdentifiers":[],"rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\"\nimport 'katex/dist/katex.min.css';\nimport { BlockMath } from 'react-katex';\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"haskell-from-first-principles\"\n    }}>{`Haskell From First Principles`}</h1>\n\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf\"\n        }}>{`A Tutorial Intro to Lambda Calculus`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"what-is-a-function\"\n    }}>{`What is a function`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`A set of possible inputs and a set of possible outputs`}</p>\n    </blockquote>\n    <BlockMath math=\"f(1) = A\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"f(2) = B\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"f(3) = C\" mdxType=\"BlockMath\" />\n    <p>{`The input set (domain) is `}<inlineCode parentName=\"p\">{`{1,2,3}`}</inlineCode>{` and the output set (codomain) is `}<inlineCode parentName=\"p\">{`{A,B,C}`}</inlineCode>{`.`}</p>\n    <p>{`In our function, an input of `}<inlineCode parentName=\"p\">{`1`}</inlineCode>{` will ALWAYS return `}<inlineCode parentName=\"p\">{`A`}</inlineCode>{`, no exceptions.`}</p>\n    <h2 {...{\n      \"id\": \"lambda-termd\"\n    }}>{`Lambda termd`}</h2>\n    <p>{`Lambda calculus has three basic components:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Expressions`}</li>\n      <li parentName=\"ol\">{`Variables`}</li>\n      <li parentName=\"ol\">{`Abstractions`}</li>\n    </ol>\n    <p>{`The word `}<inlineCode parentName=\"p\">{`expression`}</inlineCode>{` refers to a superset of those things. It can be a variable name, an abstraction or a combination of those things.`}</p>\n    <p>{`An `}<inlineCode parentName=\"p\">{`abstraction`}</inlineCode>{` is a function. It is a lambda term that has a head (a lambda) and a body and is applied to an argument. An `}<inlineCode parentName=\"p\">{`argument`}</inlineCode>{` is an input value.`}</p>\n    <p>{`Abstractions consist of the `}<inlineCode parentName=\"p\">{`head`}</inlineCode>{` and the `}<inlineCode parentName=\"p\">{`body`}</inlineCode>{`. The head of the function is a lambda followed by a variable name. The body of the function is another expression.`}</p>\n    <p>{`A simple function might look like this:`}</p>\n    <BlockMath math=\"\\lambda x.x\" mdxType=\"BlockMath\" />\n    <p>{`The variable named in the head is the `}<inlineCode parentName=\"p\">{`parameter`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`binds`}</inlineCode>{` all instances of that same variable in the body of the function. In laymen terms, when we apply this function to an argument, each `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` in the body of the function will have the value of that argument.`}</p>\n    <p>{`In the above, we were reference functions called `}<inlineCode parentName=\"p\">{`f`}</inlineCode>{`, but in the previous section the lambda astraction has no name and is an `}<inlineCode parentName=\"p\">{`anonymous function`}</inlineCode>{`.`}</p>\n    <p>{`A named function can be called by name by another function, a lambda cannot.`}</p>\n    <h3 {...{\n      \"id\": \"breakdown-of-the-lambda\"\n    }}>{`Breakdown of the lambda`}</h3>\n    <p>{`The extent of the lambda:`}</p>\n    <BlockMath math=\"\\lambda x.\" mdxType=\"BlockMath\" />\n    <p>{`The first `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is the single parameter of the function. This binds an variables:`}</p>\n    <p>{`The second `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is part of the body, the expression the lambda returns when applied. This is a bound variable.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`.`}</inlineCode>{` separates the parameters of the lambda from the function body.`}</p>\n    <h2 {...{\n      \"id\": \"alpha-equivalence\"\n    }}>{`Alpha Equivalence`}</h2>\n    <BlockMath math=\"\\lambda x.x\" mdxType=\"BlockMath\" />\n    <p>{`In the above expression, the variable `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is not semantically meaningful except in its role in that single expression. Because of this, there's a form of equivalence between lambda terms called `}<inlineCode parentName=\"p\">{`alpha equivalence`}</inlineCode>{`. This is a way of saying:`}</p>\n    <BlockMath math=\"\\lambda x.x = \\lambda d.d = \\lambda z.z\" mdxType=\"BlockMath\" />\n    <h2 {...{\n      \"id\": \"beta-reduction\"\n    }}>{`Beta reduction`}</h2>\n    <p>{`When we apply a function to an argument, we substitute the input expression for all instances of the bound variables within the body of the abstraction. You also eliminate the head of the abstraction, since its only purpose was to bind the variable. This is called `}<inlineCode parentName=\"p\">{`beta reduction`}</inlineCode>{`.`}</p>\n    <p>{`We can do one using a number. We apply the function above to `}<inlineCode parentName=\"p\">{`2`}</inlineCode>{`, substitude `}<inlineCode parentName=\"p\">{`2`}</inlineCode>{` for each bound variable in the body of the function and eliminate the head:`}</p>\n    <BlockMath math=\"( \\lambda x.x ) 2 = 2\" mdxType=\"BlockMath\" />\n    <p>{`The only bound variable is a single `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{`, so applying this function to 2 returns 2. This function is the `}<inlineCode parentName=\"p\">{`identity`}</inlineCode>{` function.`}</p>\n    <h2 {...{\n      \"id\": \"free-variables\"\n    }}>{`Free variables`}</h2>\n    <BlockMath math=\"\\lambda x.xy\" mdxType=\"BlockMath\" />\n    <p>{`In this example, `}<inlineCode parentName=\"p\">{`x`}</inlineCode>{` is a bound variable, `}<inlineCode parentName=\"p\">{`y`}</inlineCode>{` is a free variable.`}</p>\n    <h2 {...{\n      \"id\": \"multiple-arguments\"\n    }}>{`Multiple arguments`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Each lambda can only bind one parameter and can only accept one argument. Functions that require multiple arguments have multiple, nested heads. When you apply it once and eliminate the first (leftmost) head, the next is applied and so on. It is know as `}<inlineCode parentName=\"p\">{`currying`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"evaluation-is-simplication\"\n    }}>{`Evaluation is simplication`}</h2>\n    <p>{`There are multiple normal forms in lambda calculus, but here when we refer to normal form we mean `}<inlineCode parentName=\"p\">{`beta normal form`}</inlineCode>{`. This corresponds to a fully evaluated expression (or a fully executed program). For example, do you say `}<inlineCode parentName=\"p\">{`2000/1000`}</inlineCode>{` or do you say 2? You say 2. The normal form of the evaluated expression is therefore 2.`}</p>\n    <p>{`Note: if we had function `}<inlineCode parentName=\"p\">{`(x,y) => x/y`}</inlineCode>{` and apply `}<inlineCode parentName=\"p\">{`x = 2000`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`y = 1000`}</inlineCode>{`, we call the the body with all arguments applied `}<inlineCode parentName=\"p\">{`saturated`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"combinators\"\n    }}>{`Combinators`}</h2>\n    <p>{`A `}<inlineCode parentName=\"p\">{`combinator`}</inlineCode>{` is a lambda term with no free variables. Combinators, as the name suggests, serve only to `}<inlineCode parentName=\"p\">{`combine`}</inlineCode>{` the arguments that they are given.`}</p>\n    <h2 {...{\n      \"id\": \"divergence\"\n    }}>{`Divergence`}</h2>\n    <p>{`Not all reducible lambda terms reduce neatly to a beta normal form. Reducing the following repeats itself:`}</p>\n    <BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"(x := \\lambda x.xx|xx)\" mdxType=\"BlockMath\" />\n    <BlockMath math=\"(\\lambda x.xx)(\\lambda x.xx)\" mdxType=\"BlockMath\" />\n    <h2 {...{\n      \"id\": \"hello-haskell\"\n    }}>{`Hello, Haskell!`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- Say Hello\nsayHello :: String -> IO ()\nsayHello x =\n  putStrLn (\"Hello, \" ++ x ++ \"!\")\n`}</code></pre>\n    <p>{`If in the `}<inlineCode parentName=\"p\">{`stack ghci`}</inlineCode>{` REPL, you can unload the file using `}<inlineCode parentName=\"p\">{`:m`}</inlineCode>{` and reload updated files using `}<inlineCode parentName=\"p\">{`:r`}</inlineCode>{`.`}</p>\n    <h3 {...{\n      \"id\": \"normal-form-reminder\"\n    }}>{`Normal Form Reminder`}</h3>\n    <p>{`Haskell reduces until we reach the normal form. Remember, `}<inlineCode parentName=\"p\">{`1 + 1`}</inlineCode>{` can be evaluated to `}<inlineCode parentName=\"p\">{`2`}</inlineCode>{`, thus Haskell returns the normal form.`}</p>\n    <h2 {...{\n      \"id\": \"redexes\"\n    }}>{`Redexes`}</h2>\n    <p>{`Reducibles expressions such as `}<inlineCode parentName=\"p\">{`1 + 1`}</inlineCode>{` are also known as `}<inlineCode parentName=\"p\">{`redexes`}</inlineCode>{`. While we generally refer to this process as evaluation or reduction, you may also hear of it as `}<inlineCode parentName=\"p\">{`normalizing`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`executing`}</inlineCode>{` an expression (though somewhat imprecise).`}</p>\n    <h2 {...{\n      \"id\": \"functions\"\n    }}>{`Functions`}</h2>\n    <p>{`Functions are a specific type of expression. Functions in Haskell relate to functions in mathematics - they map an input or set of inputs to an output.`}</p>\n    <p>{`Because they are built purely of expressions, they will always evaluate to the same result when given the same values.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`As with Lambda Calculus, all functions in Haskell take one argument and return one result. Even when it seems we are passing multiple arguments, we are actually applying a series of nested functions (each to one argument). This is called `}<inlineCode parentName=\"p\">{`currying`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- in GHCi REPL\nlet triple x = x * 3\n-- in source file\ntriple :: Number -> Number\ntriple x = x * 3\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"evaluation\"\n    }}>{`Evaluation`}</h2>\n    <p>{`When we talk about evaluating an expression, we're talking about reducing the terms until it is in the simplest form. We say it is `}<inlineCode parentName=\"p\">{`irreducible`}</inlineCode>{` or finished evaluating.`}</p>\n    <p>{`Haskell uses `}<inlineCode parentName=\"p\">{`nonstrict evaluation`}</inlineCode>{` (sometimes called `}<inlineCode parentName=\"p\">{`lazy evaluation`}</inlineCode>{`) stategy which defers evaluations of terms until they're forced by other terms referring so them.`}</p>\n    <p>{`Here is the reduction of our `}<inlineCode parentName=\"p\">{`triple`}</inlineCode>{` function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`triple 2\n-- [triple x = x * 3; x:= 2]\n2 * 3\n6\n`}</code></pre>\n    <p>{`The above is reduced to its normal form, however Haskell only evalutes is weak head normal form (WHNF) but default. This means things are not always reduced to its irreducible form straight away.`}</p>\n    <p><inlineCode parentName=\"p\">{`(\\\\f -> (1, 2 + f)) 2`}</inlineCode>{` reduces to the following in WHNF `}<inlineCode parentName=\"p\">{`(1, 2 + 2)`}</inlineCode>{` before it is evaluated further.`}</p>\n    <h2 {...{\n      \"id\": \"infix-operators\"\n    }}>{`Infix Operators`}</h2>\n    <p>{`Functions in Haskell default to prefix syntax (like the `}<inlineCode parentName=\"p\">{`triple`}</inlineCode>{` func above).`}</p>\n    <p>{`Operators for example are functions that can be used in the infix style.`}</p>\n    <p>{`You can sometimes use functions infix style with a small change in syntax:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`10 \\`div\\` 4\ndiv 10 4\n(/) 10 4\n2.5\n`}</code></pre>\n    <p>{`If the function is alphanumeric, it is prefix by default. If it is a symbol, it is infix by default.`}</p>\n    <h2 {...{\n      \"id\": \"associativity-and-precedence\"\n    }}>{`Associativity and precedence`}</h2>\n    <p>{`This BODMAS (from Mathematics) for precedence.`}</p>\n    <p>{`We can use `}<inlineCode parentName=\"p\">{`:info`}</inlineCode>{` to get more info about an operator.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`Prelude> :i (/) (+) (-)\nclass Num a => Fractional a where\n  (/) :: a -> a -> a\n  ...\n        -- Defined in ‘GHC.Real’\ninfixl 7 /\nclass Num a where\n  (+) :: a -> a -> a\n  ...\n        -- Defined in ‘GHC.Num’\ninfixl 6 +\nclass Num a where\n  ...\n  (-) :: a -> a -> a\n  ...\n        -- Defined in ‘GHC.Num’\ninfixl 6 -\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`infixl`}</inlineCode>{` means infix operator and left associative`}</li>\n      <li parentName=\"ul\"><inlineCode parentName=\"li\">{`7|6`}</inlineCode>{` is the precendence - higher is applied first`}</li>\n      <li parentName=\"ul\">{`The last part is the function name (in this case the `}<inlineCode parentName=\"li\">{`/`}</inlineCode>{`, `}<inlineCode parentName=\"li\">{`+`}</inlineCode>{` and `}<inlineCode parentName=\"li\">{`-`}</inlineCode>{`)`}</li>\n    </ul>\n    <p>{`An example of a right-associative infix operator is the power operator `}<inlineCode parentName=\"p\">{`^`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"declaring-values\"\n    }}>{`Declaring values`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- in the REPL\nPrelude> let y = 10\nPrelude> let x = 10 * 5 + y\nPrelude> let myResult = x * 5\n-- in a file\n-- learn.hs\nmodule Learn where\nx = 10 * 5 + y\nmyResult = x * 5\ny = 10\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"-operator\"\n    }}>{`\\$ Operator`}</h2>\n    <p>{`The (\\$) operator is a convenience for when you want to express something with fewer pairs of parentheses:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{` -- Remember ($)'s definition\nf $ a = f a\n-- in use\nPrelude> (2^) (2 + 2)\n16\n-- can replace those parentheses\n Prelude> (2^) $ 2 + 2\n16\n-- without either parentheses or $\n Prelude> (2^) 2 + 2\n 6\n`}</code></pre>\n    <p>{`The (\\$) will allow everything to the right of it to be evaluated first and can be used to delay function application.`}</p>\n    <h2 {...{\n      \"id\": \"let-and-where\"\n    }}>{`Let and where`}</h2>\n    <p>{`The contrast here is that let introduces an expression, so it can be used wherever you can have an expression, but where is a declaration and is bound to a surrounding syntactic construct.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- FunctionWithWhere.hs\nmodule FunctionWithWhere where\n\nprintInc n = print plusTwo\n  where plusTwo = n + 2\n\n\nprintInc2 n = let plusTwo = n + 2\n  in print plusTwo\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"strings\"\n    }}>{`Strings`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`Prelude> :type 'a'\n'a' :: Char\nPrelude> :type \"Hello!\"\n\"Hello!\" :: [Char]\n`}</code></pre>\n    <p>{`To print strings we can use `}<inlineCode parentName=\"p\">{`print`}</inlineCode>{` in the REPL or `}<inlineCode parentName=\"p\">{`putStrLn`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`putStr`}</inlineCode>{` for our Haskell modules.`}</p>\n    <p>{`Mutliline \"do\" can be done like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- print2.hs\nmodule Print2 where\nmain :: IO () main = do\n  putStrLn \"Count to four for me:\"\n  putStr   \"one, two\"\n  putStr   \", three, and\"\n  putStrLn \" four!\"\n`}</code></pre>\n    <p>{`String concatenation:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`-- print3.hs\nmodule Print3 where\n\nmyGreeting :: String\nmyGreeting = \"hello\" ++ \" world!\" hello :: String\n\nhello = \"hello\" world :: String\nworld = \"world!\"\n\nmain :: IO () main = do\n  putStrLn myGreeting\n  putStrLn secondGreeting\n  where secondGreeting =\n    concat [hello, \" \", world]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"top-level-versus-local-definitions\"\n    }}>{`Top-level versus local definitions`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-haskell\"\n      }}>{`module TopOrLocal where\n\ntopLevelFunction :: Integer -> Integer topLevelFunction x =\n  x + woot + topLevelValue\n  where woot :: Integer\n        woot = 10\n\ntopLevelValue :: Integer\ntopLevelValue = 5\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"basic-datatypes\"\n    }}>{`Basic Datatypes`}</h2>\n    <p>{`The type constructor is the name of the type and is capitalized. When you are reading or writing type signatures (the type level of your code), the type names or type constructors are what you use.`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}