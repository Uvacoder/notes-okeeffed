{"version":3,"sources":["webpack:///../manual/Nodejs/Microservices-With-NodeJS-React.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ofAMO,IAAMA,EAAe,Q,kOAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,6BADR,6BAGA,iBAAQ,CACN,GAAM,aADR,aAGA,sBACE,kBAAIC,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,8CADQ,sBAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,mEADQ,iBAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,gDADQ,mBAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,+CADQ,oBAItB,iBAAQ,CACN,GAAM,+BADR,+BAGA,sBACE,kBAAIA,WAAW,MAAf,sDACA,kBAAIA,WAAW,MAAf,iCACA,kBAAIA,WAAW,MAAf,wEAEF,4HACA,iBAAQ,CACN,GAAM,qCADR,qCAGA,4EACA,oHACA,8BACE,iBAAGA,WAAW,cAAd,2EAEF,iBAAQ,CACN,GAAM,qCADR,qCAGA,kHACA,iBAAQ,CACN,GAAM,uCADR,uCAGA,8FACA,qHACA,iJACA,uKACA,8MACA,iBAAQ,CACN,GAAM,mBADR,mBAGA,iBAAQ,CACN,GAAM,WADR,WAGA,wDACA,uCACA,sBACE,kBAAIA,WAAW,MAAf,qBACA,kBAAIA,WAAW,MAAf,gBAAqC,0BAAYA,WAAW,MAAvB,cAArC,oCACA,kBAAIA,WAAW,MAAf,+HAEF,iBAAQ,CACN,GAAM,QADR,QAGA,mEACA,2HACA,8DACA,2JACA,uEACA,6EACA,kKACA,iBAAQ,CACN,GAAM,UADR,UAGA,iBAAQ,CACN,GAAM,kBADR,kBAGA,qCAAoB,0BAAYA,WAAW,KAAvB,kBAApB,sIACA,iEACA,wFACA,iBAAQ,CACN,GAAM,oBADR,oBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,yNAWL,+LACA,iBAAQ,CACN,GAAM,uBADR,uBAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,kUAkBL,iBAAQ,CACN,GAAM,mBADR,mBAGA,oMACA,iBAAQ,CACN,GAAM,gBADR,gBAGA,yCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wL,yNAmBTJ,EAAWK,gBAAiB","file":"component---manual-nodejs-microservices-with-node-js-react-md-4365dce74959e49fb464.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"microservices-with-nodejs\"\n    }}>{`Microservices with NodeJS`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://express-validator.github.io/docs/\"\n        }}>{`Express validator`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://udemy.com/course/microservices-with-node-js-and-react/\"\n        }}>{`Udemy Course`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/expressjs/cookie-session\"\n        }}>{`Cookie Session`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/auth0/node-jsonwebtoken\"\n        }}>{`JSON Web Token`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"fundamental-auth-strategies\"\n    }}>{`Fundamental Auth Strategies`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`User auth in microservices is an unsolved problem.`}</li>\n      <li parentName=\"ul\">{`There are many ways to do it.`}</li>\n      <li parentName=\"ul\">{`Outline a few approaches, but use one that works but has downsides.`}</li>\n    </ul>\n    <p>{`In the body of a request, a user needs to prove their auth with a JWT, Cookie or something similar.`}</p>\n    <h3 {...{\n      \"id\": \"approaches-to-auth---strategy-one\"\n    }}>{`Approaches to Auth - Strategy One`}</h3>\n    <p>{`Individual services rely on a central auth service.`}</p>\n    <p>{`A microservice after receiving a request will need to check with an authentication service.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Sync Request in microservices is a request directly to a auth service.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"approaches-to-auth---strategy-two\"\n    }}>{`Approaches to Auth - Strategy Two`}</h3>\n    <p>{`Similar to the first, however the authentication service comes through a central gateway.`}</p>\n    <h3 {...{\n      \"id\": \"approaches-to-auth---strategy-three\"\n    }}>{`Approaches to Auth - Strategy Three`}</h3>\n    <p>{`You teach each service how to decide whether a user is authenticated.`}</p>\n    <p>{`You teach the service how to inspect the JWT/Cookie and decide if the user is authenticated.`}</p>\n    <p>{`The downside to this method is that authentication method is that communicating between microservices becomes difficult.`}</p>\n    <p>{`The issue would be how to let individual services that handle their own auth known when auth tokens (JWTs, Cookies, etc.) are no longer valid.`}</p>\n    <p>{`You can get around this by only ensure that a JWT is only good for however minutes. You can use an event bus to head around to all of services to ensure their access is short-lived.`}</p>\n    <h2 {...{\n      \"id\": \"cookies-vs-jwts\"\n    }}>{`Cookies vs JWTs`}</h2>\n    <h3 {...{\n      \"id\": \"cookies\"\n    }}>{`Cookies`}</h3>\n    <p>{`They are a transport mechanism.`}</p>\n    <p>{`The flow goes:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Request to server`}</li>\n      <li parentName=\"ol\">{`Response has `}<inlineCode parentName=\"li\">{`Set-Cookie`}</inlineCode>{` header with a particular value.`}</li>\n      <li parentName=\"ol\">{`The browser will make sure it always appends following requests with this cookie. It is an arbitrary piece of information.`}</li>\n    </ol>\n    <h3 {...{\n      \"id\": \"jwts\"\n    }}>{`JWTs`}</h3>\n    <p>{`An authentication/authorization mechanism.`}</p>\n    <p>{`We take an arbitrary piece of information (payload) and apply it through a JWT creation algorithm.`}</p>\n    <p>{`This can be both encoded and decoded.`}</p>\n    <p>{`This JWT can now have that JWT through a few methods: as a Authorization header, a token in the body, or still set it as a Cookie.`}</p>\n    <p>{`JWTs don't require some kind of backing store.`}</p>\n    <p>{`There are some issues that pop up with JWTs and SSR.`}</p>\n    <p>{`When you are doing SSR, you must use a Cookie to communicate during the initial page load. You can work around this with service workers.`}</p>\n    <h2 {...{\n      \"id\": \"stores\"\n    }}>{`Stores`}</h2>\n    <h3 {...{\n      \"id\": \"cookie-session\"\n    }}>{`Cookie Session`}</h3>\n    <p>{`We are using `}<inlineCode parentName=\"p\">{`cookie-session`}</inlineCode>{` in this example, but you nees to be careful about whether or not this encrpytion method is understood across different languages.`}</p>\n    <p>{`You need to check the encryption method.`}</p>\n    <p>{`JWTs are tamper resistent so are not encrypted in this example.`}</p>\n    <h3 {...{\n      \"id\": \"generating-a-jwt\"\n    }}>{`Generating a JWT`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// generating a JWT\nconst payload = { key: 'somethingAboutUser', id: 123, email: 'user@email.com' };\nconst userJwt = jwt.sign(payload, 'secret');\n\n// storing on session\nreq.session = {\n  jwt: userJwt,\n};\n`}</code></pre>\n    <p>{`If you head to JWT.io, you can see with a token that the information passed can be decoded. However, if you do not pass the signing key, it will not be a valid token.`}</p>\n    <h2 {...{\n      \"id\": \"verifying-the-token\"\n    }}>{`Verifying the token`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`// middleware for the user\nimport jwt from 'jsonwebtoken';\n\nexport const currentUser = (req, res, next) => {\n  if (!req.session?.jwt) {\n    return next();\n  }\n\n  try {\n    const payload = jwt.verify(req.session.jwt, process.env.JWT_KEY!)\n    req.currentUser = payload;\n  } catch (e) {\n  }\n  next();\n};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"storing-secrets\"\n    }}>{`Storing Secrets`}</h2>\n    <p>{`You never want to hardcode the secret. Based on what you are running (Kubernetes, Lambda, etc.) you will want to keep the secret stored as a secret based on your approach.`}</p>\n    <h2 {...{\n      \"id\": \"typing-aside\"\n    }}>{`Typing aside`}</h2>\n    <p>{`Extending types:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`interface UserPayload {\n  id: string;\n  email: string;\n}\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      currentUser?: UserPayload;\n    }\n  }\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}