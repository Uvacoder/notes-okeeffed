{"version":3,"sources":["webpack:///../manual/gRPC/gRPC-with-Go.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---manual-g-rpc-g-rpc-with-go-md-d14a67d4ffcb00b97a25.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/dennis.okeeffe/Project-Imposter/developer-notes/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"grpc-with-golang\"\n    }}>{`gRPC with Golang`}</h1>\n    <h2 {...{\n      \"id\": \"resources\"\n    }}>{`Resources`}</h2>\n    <ol>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://www.udemy.com/course/grpc-golang/\"\n        }}>{`gRPC course Udemy`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://grpc.io/\"\n        }}>{`gRPC.io`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://imagekit.io/demo/http2-vs-http1\"\n        }}>{`HTTP2 vs HTTP1 image loading website`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/grpc/grpc-go\"\n        }}>{`gRPC-Go`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/golang/protobuf\"\n        }}>{`Go Protobuf`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://blog.coinbase.com/grpc-to-aws-lambda-is-it-possible-4b29a9171d7f\"\n        }}>{`gRPC with Lambda`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://github.com/twitchtv/twirp\"\n        }}>{`Twirp`}</a></li>\n      <li parentName=\"ol\"><a parentName=\"li\" {...{\n          \"href\": \"https://rynop.com/2018/01/23/twirpl-twirp-go-framework-running-completely-serverless/\"\n        }}>{`Twirpl 2018 post`}</a></li>\n    </ol>\n    <h2 {...{\n      \"id\": \"intro\"\n    }}>{`Intro`}</h2>\n    <p>{`gRPC is there to attempt to solve the difficulties of API design.`}</p>\n    <p>{`gRPC is an open-source framework developed by Google which is now part of CNCF.`}</p>\n    <p>{`At a high level, it allows you to define REQUEST and RESPONSE for RPCs and handles the rest.`}</p>\n    <h3 {...{\n      \"id\": \"benefits\"\n    }}>{`Benefits`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Fast + efficient`}</li>\n      <li parentName=\"ol\">{`Built on HTTP/2`}</li>\n      <li parentName=\"ol\">{`Low latenvy`}</li>\n      <li parentName=\"ol\">{`Supports streaming`}</li>\n      <li parentName=\"ol\">{`Language independent`}</li>\n      <li parentName=\"ol\">{`Easy to plug in with integrated auth, load balancing, logging and monitoring`}</li>\n    </ol>\n    <h2 {...{\n      \"id\": \"remote-procedural-call\"\n    }}>{`Remote Procedural Call`}</h2>\n    <p>{`In the CLIENT code, it looks like you're just callng a function on the SERVER.`}</p>\n    <p>{`With gRPC, it is implemented cleanly and solves a lot of problems.`}</p>\n    <h2 {...{\n      \"id\": \"getting-started\"\n    }}>{`Getting started`}</h2>\n    <p>{`At the core of gRPC, you need to define the messages and services using `}<inlineCode parentName=\"p\">{`Protocol Buffers`}</inlineCode>{`.`}</p>\n    <p>{`The rest of the gRPC code will be generated for you and you'll have to provide and implementation for it.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`One `}<inlineCode parentName=\"p\">{`.proto`}</inlineCode>{` file can be used for over 12 different languages.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"example-proto-file\"\n    }}>{`Example proto file`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-proto\"\n      }}>{`syntax = 'proto3';\n\nmessage Greeting {\n  string first_name = 1;\n}\n\nmessage GreetRequest {\n  Greeting greeting = 1;\n}\n\nmessage Greeting {\n  string result = 1;\n}\n\nservice GreetService {\n  rpc Greet(GreetRequest) returns (GreetResponse) {};\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"why-protocol-buffers\"\n    }}>{`Why Protocol Buffers?`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Language agnostic.`}</li>\n      <li parentName=\"ul\">{`Code can be generated for pretty much any language.`}</li>\n      <li parentName=\"ul\">{`Data is binary and efficiently serialized (small payloads).`}</li>\n      <li parentName=\"ul\">{`Very convenient for transporting a lot of data.`}</li>\n      <li parentName=\"ul\">{`Protocol Buffers allows for easy API evolution using rules.`}</li>\n      <li parentName=\"ul\">{`Easy to write messag definition.`}</li>\n      <li parentName=\"ul\">{`Definition of API independent from implementation.`}</li>\n      <li parentName=\"ul\">{`A hug amount of code can be generated, in any language, from a simple `}<inlineCode parentName=\"li\">{`.proto`}</inlineCode>{` file.`}</li>\n      <li parentName=\"ul\">{`Payload is binary, therefore very efficient to send/receive on a network and serialize/de-serialize on a CPU.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"protocol-buffers--interoperability\"\n    }}>{`Protocol Buffers & Interoperability`}</h3>\n    <p>{`One benefit Protobuf is used the size of the messsage and savings through network benefit. A JSON comparison of an object for \"person\" vs a Protobuf shows a 55 byte vs 20 byte difference, event with small messages.`}</p>\n    <p>{`Parsing Protocol Buggers (binary format) means faster and more efficient communication. This has added benefit for mobile devices with slower CPUs.`}</p>\n    <h3 {...{\n      \"id\": \"grpc-languages\"\n    }}>{`gRPC languages`}</h3>\n    <p>{`Java, Go and C have native, pure bindings. The rest rely on GRPC-C.`}</p>\n    <h2 {...{\n      \"id\": \"http2-vs-http1\"\n    }}>{`HTTP/2 vs HTTP/1`}</h2>\n    <h3 {...{\n      \"id\": \"http1\"\n    }}>{`HTTP/1`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Released in 1997.`}</li>\n      <li parentName=\"ul\">{`Opens a new TCP connection for each request.`}</li>\n      <li parentName=\"ul\">{`Does not compress headers (which are plaintext).`}</li>\n      <li parentName=\"ul\">{`Only works with Req/Res mechanism (no server push).`}</li>\n      <li parentName=\"ul\">{`Original composed of GET and POST.`}</li>\n      <li parentName=\"ul\">{`80 assets for load will request headers sent for every request. 80 assets = 80 TCP connections. Inefficient for latency and increases network packet size.`}</li>\n    </ul>\n    <h3 {...{\n      \"id\": \"http2\"\n    }}>{`HTTP/2`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`2015 release but battle tested by Google.`}</li>\n      <li parentName=\"ul\">{`Supports multiplexing (parallel messages pushed).`}</li>\n      <li parentName=\"ul\">{`Supports server push (multiple messages for one client request).`}</li>\n      <li parentName=\"ul\">{`Supports header compression.`}</li>\n      <li parentName=\"ul\">{`HTTP/2 is binary. Any binary protocol is a great match.`}</li>\n      <li parentName=\"ul\">{`HTTP/2 is secure (SSL not required by recommended by default).`}</li>\n      <li parentName=\"ul\">{`\"Less chatter\". Less bandwidth, reduced latency, increased security.`}</li>\n    </ul>\n    <blockquote>\n      <p parentName=\"blockquote\">{`gRPC only uses HTTP/2.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"4-types-of-api-in-grpc\"\n    }}>{`4 Types of API in gRPC`}</h2>\n    <ol>\n      <li parentName=\"ol\">{`Unary`}</li>\n      <li parentName=\"ol\">{`Server streaming`}</li>\n      <li parentName=\"ol\">{`Client streaming`}</li>\n      <li parentName=\"ol\">{`Bi-directional streaming`}</li>\n    </ol>\n    <p>{`The following shows how easy it is to define the streaming contracts:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-proto\",\n        \"metastring\": \"vs\",\n        \"vs\": true\n      }}>{`service GreetService {\n  // Unary\n  rpc Greet(GreetRequest) returns (GreetResponse) {};\n\n  // Streaming Server\n  rpc GreetManyTimes(GreetManyTimesRequest) returns (stream GreetManyTimesResponse) {};\n\n  // Streaming Client\n  rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {};\n\n  // Bidirectional Streaming\n  rpc GreetEveryone(stream GreetEveryoneRequest) returns (stream GreetEveryoneResponse) {};\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"grpc-scalability\"\n    }}>{`gRPC Scalability`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Async by default (ie non-blocking).`}</li>\n      <li parentName=\"ul\">{`Can serve millions of reqs in parallel.`}</li>\n      <li parentName=\"ul\">{`gRPC clients can be async or sync. Client decides on modal best for performance needs.`}</li>\n      <li parentName=\"ul\">{`gRPC Clients can perform clientside load balancing.`}</li>\n    </ul>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Google have 10 billion gRPC reqs per second internally.`}</p>\n    </blockquote>\n    <h2 {...{\n      \"id\": \"grpc-security\"\n    }}>{`gRPC Security`}</h2>\n    <ul>\n      <li parentName=\"ul\">{`Strongly advocats for SSL in API.`}</li>\n      <li parentName=\"ul\">{`gRPC has security as a first class citizen.`}</li>\n      <li parentName=\"ul\">{`ach language will provide an API to load gRPC with required certificates and provide encyption out-of-the-box.`}</li>\n      <li parentName=\"ul\">{`Additionally using Intercepts, can provide auth.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"getting-started-with-grpc-go\"\n    }}>{`Getting Started with gRPC Go`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`go get -u google.golang.org/grpc\ngo get -u google.golang.org/protobuf\n`}</code></pre>\n    <p>{`After cloning `}<inlineCode parentName=\"p\">{`https://github.com/simplesteph/grpc-go-course`}</inlineCode>{` and changing into `}<inlineCode parentName=\"p\">{`Greet/greetpb`}</inlineCode>{`, we can run `}<inlineCode parentName=\"p\">{`protoc greet.proto --go_out=plugins=grpc:.`}</inlineCode>{` to test the code generation.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Running `}<inlineCode parentName=\"p\">{`protoc greet/greetpb/greet.proto --go_out=plugins=grpc:.`}</inlineCode>{` will output the file to `}<inlineCode parentName=\"p\">{`greet/greetpb/greet.pb.go`}</inlineCode>{`.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"a-hello-service\"\n    }}>{`A Hello Service`}</h3>\n    <p>{`Instead of installing the above, you can do it manually. Inside of `}<inlineCode parentName=\"p\">{`hello/hellopb/hello.proto`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-proto\"\n      }}>{`syntax = \"proto3\";\n\npackage hello;\noption go_package = \"hello/hellopb\";\n\nservice HelloService {}\n`}</code></pre>\n    <p>{`Run `}<inlineCode parentName=\"p\">{`protoc hello/hellopb/hello.proto --go_out=plugins=grpc:.`}</inlineCode>{` to generate `}<inlineCode parentName=\"p\">{`hello/hellopb/hello.pb.go`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"server-boilerplate\"\n    }}>{`Server Boilerplate`}</h2>\n    <p>{`This will show how to properly start & stop the Server on the defined `}<inlineCode parentName=\"p\">{`port`}</inlineCode>{`.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`You may need to run `}<inlineCode parentName=\"p\">{`go mod init github.com/okeeffed/project-name`}</inlineCode>{` at the root of the directory prior.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net\"\n\n    \"github.com/okeeffed/grpc-go-course/hello/hellopb\"\n\n    \"google.golang.org/grpc\"\n)\n\ntype server struct{}\n\nfunc main() {\n    fmt.Println(\"Hello world\")\n    // :50051 is default gRPC port\n    lis, err := net.Listen(\"tcp\", \"0.0.0.0:50051\")\n    if err != nil {\n        log.Fatalf(\"Failed to listen: %v\", err)\n    }\n\n    s := grpc.NewServer()\n    hellopb.RegisterHelloServiceServer(s, &server{})\n\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"Failed to serve: %v\", err)\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"client-boilerplate\"\n    }}>{`Client Boilerplate`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/okeeffed/grpc-go-course/hello/hellopb\"\n    \"google.golang.org/grpc\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello from the client\")\n    // WithInsecure for now as we don't have SSL certificates\n    conn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf(\"Could not connect: %v\", err)\n    }\n\n    defer conn.Close()\n\n    c := hellopb.NewHelloServiceClient(conn)\n    fmt.Printf(\"Created client: %f\", c)\n}\n`}</code></pre>\n    <p>{`Now if we start the server and client in two different tabs we can see that we connect!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`# Tab 1\n> go run hello/hello_server/server.go\nHello world\n\n# Tab 2\n>  go run hello/hello_client/client.go\nHello from the client\nCreated client: &{%!f(*grpc.ClientConn=&{0xc0001beb00 0x10e0e70 localhost:50051 {passthrough  localhost:50051} localhost:50051 {<nil> <nil> [] [] <nil> <nil> {{1000000000 1.6 0.2 120000000000}} false false true 0 <nil>  {grpc-go/1.31.0 0x1470140 false [] <nil> <nil> {0 0 false} <nil> 0 0 32768 32768 0 <nil>} [] <nil> 0 false true false <nil> <nil> <nil> <nil> 0x1472400 [] true} 0xc0001aaf40 {<nil> <nil> 0x1470140 0 {passthrough  localhost:50051}} 0xc0002529f0 {{0 0} 0 0 0 0} 0xc0001b2900 0xc00018e6e0 map[0xc0001eb8c0:{}] {0 0 false} pick_first 0xc0001bec00 {<nil>} 0xc0001aaf20 0 0xc0001b6700 {0 0} <nil>})}%\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"creating-a-unary-api-call\"\n    }}>{`Creating a Unary API call`}</h2>\n    <p>{`We need to create a `}<inlineCode parentName=\"p\">{`Request`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Response`}</inlineCode>{`.`}</p>\n    <p>{`We start by writing the definition - here I will do one for \"Hello\".`}</p>\n    <p>{`We update our `}<inlineCode parentName=\"p\">{`Hello`}</inlineCode>{` Protobuffer to define `}<inlineCode parentName=\"p\">{`Greeting`}</inlineCode>{` and a Request + Response:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-proto\"\n      }}>{`syntax = \"proto3\";\n\npackage hello;\noption go_package = \"hello/hellopb\";\n\nmessage Hello {\n  string first_name = 1;\n  string last_name = 2;\n}\n\nmessage HelloRequest { Hello hello = 1; }\n\nmessage HelloResponse { string result = 1; }\n\nservice HelloService {\n  // Unary\n  rpc Hello(HelloRequest) returns (HelloResponse) {}\n}\n`}</code></pre>\n    <p>{`We can now update the `}<inlineCode parentName=\"p\">{`server.go`}</inlineCode>{` file to now handle our call from the Client:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`func (*server) Hello(ctx context.Context, req *hellopb.HelloRequest) (*hellopb.HelloResponse, error) {\n    // from the auto generated info\n    firstName := req.GetHello().GetFirstName()\n\n    result := \"Hello \" + firstName\n    res := &hellopb.HelloResponse{\n        Result: result,\n    }\n\n    return res, nil\n}\n`}</code></pre>\n    <p>{`We can now update the client to get the simple response example.`}</p>\n    <h2 {...{\n      \"id\": \"updating-the-client-to-get-a-response\"\n    }}>{`Updating the client to get a response`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/okeeffed/grpc-go-course/hello/hellopb\"\n    \"google.golang.org/grpc\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello from the client\")\n    // WithInsecure for now as we don't have SSL certificates\n    conn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf(\"Could not connect: %v\", err)\n    }\n\n    defer conn.Close()\n\n    c := hellopb.NewHelloServiceClient(conn)\n    doUnary(c)\n}\n\nfunc doUnary(c hellopb.HelloServiceClient) {\n    fmt.Println(\"Starting doUnary RPC\")\n\n    // Create a request that takes the \"Hello\" struct\n    req := &hellopb.HelloRequest{\n        Hello: &hellopb.Hello{\n            FirstName: \"Dennis\",\n            LastName:  \"O'Keeffe\",\n        },\n    }\n    res, err := c.Hello(context.Background(), req)\n\n    if err != nil {\n        log.Fatalf(\"Error calling greet %v\", err)\n    }\n    log.Printf(\"Response from Greet: %v\", res.Result)\n}\n`}</code></pre>\n    <p>{`If we now start the server and client, you will see the response.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-s\"\n      }}>{`# Tab 1\n> go run hello/hello_server/server.go\nHello world\n# Tab 2\n> go run hello/hello_client/client.go\nHello from the client\nStarting doUnary RPC\n2020/08/10 13:47:24 Response from Greet: Hello Dennis\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"server-streaming\"\n    }}>{`Server Streaming`}</h2>\n    <p>{`Take \"one\" request and return many responses.`}</p>\n    <p>{`For the API, we need to add a receiver function for the server that takes a request and a stream:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`func (*server) HelloManyTimes(req *hellopb.HelloManyTimesRequest, stream hellopb.HelloService_HelloManyTimesServer) error {\n    fmt.Printf(\"Greet many times function was invoked with %v\", req)\n\n    // from the auto generated info\n    firstName := req.GetHello().GetFirstName()\n\n    for i := 0; i < 10; i++ {\n        result := \"Hello \" + firstName + \" number \" + strconv.Itoa(i)\n        res := &hellopb.HelloManyTimesResponse{\n            Result: result,\n        }\n        stream.Send(res)\n        time.Sleep(1000 * time.Millisecond)\n    }\n\n    return nil\n}\n`}</code></pre>\n    <p>{`For the client, it is fairly simple:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n\n    \"github.com/okeeffed/grpc-go-course/hello/hellopb\"\n    \"google.golang.org/grpc\"\n)\n\nfunc main() {\n    fmt.Println(\"Hello from the client\")\n    // WithInsecure for now as we don't have SSL certificates\n    conn, err := grpc.Dial(\"localhost:50051\", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf(\"Could not connect: %v\", err)\n    }\n\n    defer conn.Close()\n\n    c := hellopb.NewHelloServiceClient(conn)\n    doServerStreaming(c)\n}\n\nfunc doServerStreaming(c hellopb.HelloServiceClient) {\n    fmt.Println(\"Starting a Server Streaming RPC\")\n\n    // Create a request that takes the \"Hello\" struct\n    req := &hellopb.HelloManyTimesRequest{\n        Hello: &hellopb.Hello{\n            FirstName: \"Dennis\",\n            LastName:  \"O'Keeffe\",\n        },\n    }\n\n    // returns client and err\n    resStream, err := c.HelloManyTimes(context.Background(), req)\n\n    if err != nil {\n        log.Fatalf(\"Error calling greet %v\", err)\n    }\n    for {\n        msg, err := resStream.Recv()\n        if err == io.EOF {\n            // reached the end\n            break\n        }\n\n        if err != nil {\n            log.Fatalf(\"Error calling greet %v\", err)\n        }\n\n        log.Printf(\"Response from GreetManyTimes: %v\", msg.GetResult())\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"client-streaming\"\n    }}>{`Client Streaming`}</h2>\n    <p>{`The updated Protobuffer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-proto\"\n      }}>{`// ... rest omitted\n\n// Streaming Client\nmessage LongGreetRequest { Hello hello = 1; }\n\nmessage LongGreetResponse { string result = 1; }\n\nservice HelloService {\n  // ... rest omitted\n\n  // Streaming Client\n  rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {}\n}\n`}</code></pre>\n    <p>{`Updating the API:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`// only take a stream this time\nfunc (*server) LongHello(stream hellopb.HelloService_LongHelloServer) error {\n    fmt.Printf(\"LongHello func invoked with streaming req\")\n    result := \"Hello \"\n\n    for {\n        req, err := stream.Recv()\n        if err == io.EOF {\n            // we finished\n            return stream.SendAndClose(&hellopb.LongHelloResponse{\n                Result: result,\n            })\n        }\n\n        if err != nil {\n            log.Fatalf(\"Error while reading client stream: %v\", err)\n        }\n\n        firstName := req.GetHello().GetFirstName()\n        result += \"Hello \" + firstName + \"! \"\n    }\n}\n`}</code></pre>\n    <p>{`As for the client:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`func doClientStreaming(c hellopb.HelloServiceClient) {\n    stream, err := c.LongHello(context.Background())\n\n    requests := []*hellopb.LongHelloRequest{\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Dennis\",\n            }\n        },\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Stacy\",\n            }\n        },\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Tracy\",\n            }\n        },\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Macy\",\n            }\n        }\n    }\n\n    if err != nil {\n        log.Fatalf(\"Error calling hello %v\", err)\n    }\n\n    // iterate over slice and send message individually\n    for _, req := range requests {\n        stream.Send(req)\n    }\n\n    stream.Send(*hellopb.HelloManyTimesRequest)\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bidi-streaming\"\n    }}>{`BiDi Streaming`}</h2>\n    <p>{`BiDi is new thanks to HTTP/2. It can be used for things such as chat, etc.`}</p>\n    <p>{`We can also use it for a long-running client where we want to stream back and forward.`}</p>\n    <p>{`For the Protocol Buffer:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-proto\"\n      }}>{`// BiDi\nmessage HelloEveryoneRequest { Hello hello = 1; }\n\nmessage HelloEveryoneResponse { Hello result = 1; }\n\nservice HelloService {\n  // ... rest omitted\n\n  // BiDi\n  rpc HelloEveryone(stream HelloEveryoneRequest)\n      returns (stream HelloEveryoneResponse) {}\n}\n`}</code></pre>\n    <p>{`For server:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`func (*server) HelloEveryone(stream hellopb.HelloService_HelloEveryoneServer) error {\n    fmt.Printf(\"HelloEveryone fn invoked w/ streaming req\\\\n\")\n    result := \"\"\n    for {\n        req, err := stream.Recv()\n\n        if err == io.EOF {\n            // we finished\n            return stream.Send(&hellopb.HelloEveryoneResponse{\n                Result: result,\n            })\n        }\n\n        if err != nil {\n            log.Fatalf(\"Error reading client stream: %v\", err)\n            return err\n        }\n\n        firstName := req.GetHello().GetFirstName()\n        result += \"Hello \" + firstName + \"! \"\n    }\n}\n`}</code></pre>\n    <p>{`For client:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-go\"\n      }}>{`func doBiDiStreaming(c hellopb.HelloServiceClient) {\n    fmt.Println(\"Starting to do BiDi Streaming RPC\")\n\n    // we create a stream by invoking the client\n    stream, err := c.HelloEveryone(context.Background())\n    if err != nil {\n        log.Fatalf(\"Error while creating stream: %v\", err)\n        return\n    }\n\n    requests := []*hellopb.HelloEveryoneRequest{\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Dennis\",\n            },\n        },\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Stacy\",\n            },\n        },\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Tracy\",\n            },\n        },\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: \"Macy\",\n            },\n        },\n    }\n\n    waitc := make(chan struct{})\n    // we send a bunch of messages to the client\n    go func() {\n        // func to send a bunch\n        for _, req := range requests {\n            fmt.Printf(\"Sending message: %v\\\\n\", req)\n            stream.Send(req)\n        }\n        stream.CloseSend()\n    }()\n\n    // we receive a bunch\n    go func() {\n        for {\n            res, err := stream.Recv()\n            if err == io.EOF {\n                break\n            }\n\n            if err != nil {\n                log.Fatalf(\"Error while receiving: %v\", err)\n            }\n\n            fmt.Printf(\"Received: %v\", res.GetResult())\n        }\n\n        close(waitc)\n    }()\n\n    // block until everything is done\n    <-waitc\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}