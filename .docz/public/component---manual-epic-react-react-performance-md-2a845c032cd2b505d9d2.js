(window.webpackJsonp=window.webpackJsonp||[]).push([[245],{NWKA:function(e,n,t){e.exports=t.p+"static/force-rerender-without-memoization-80ee0f7831f420c5cf03b9736292b59e.png"},cT3E:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return i})),t.d(n,"default",(function(){return c}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var o=t("/FXl"),a=t("TjRS");t("aD51");function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}var i={};void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/Epic-React/React-Performance.md"}});var s={_frontmatter:i},l=a.a;function c(e){var n=e.components,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,["components"]);return Object(o.b)(l,r({},s,a,{components:n,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"react-performance"},"React Performance"),Object(o.b)("p",null,"React in general is fast. That being said, there are tools to help aid us when we need those tools to help optimize particular scenarios."),Object(o.b)("p",null,"What is important is to know what tool to grab at the appropriate time."),Object(o.b)("h2",{id:"code-splitting"},"Code Splitting"),Object(o.b)("p",null,"The single, biggest impact you can have on your performance. It will help lazily load code when required."),Object(o.b)("p",null,"In this first example, we simple used ",Object(o.b)("inlineCode",{parentName:"p"},"React.lazy")," to lazy import a file and then used the ",Object(o.b)("inlineCode",{parentName:"p"},"Suspense")," library to handle the fallback."),Object(o.b)("p",null,"What is important to do to test and see the visual changes:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Check the network tab"),Object(o.b)("li",{parentName:"ol"},"Check the coverage tab")),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// üí£ remove this import\n\n// üê® use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(() => import('../globe'));\n\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // üê® wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // üí∞ try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// ü¶â Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;\n")),Object(o.b)("h3",{id:"eager-loading"},"Eager Loading"),Object(o.b)("p",null,'Given a certain "indication" that a user may click, we can load earlier.'),Object(o.b)("p",null,"We can enter a ",Object(o.b)("inlineCode",{parentName:"p"},"onMouseEnter")," and ",Object(o.b)("inlineCode",{parentName:"p"},"onFocus")," to fire an eager import:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Code splitting\n// http://localhost:3000/isolated/exercise/01.js\n\nimport * as React from 'react';\n// üí£ remove this import\n\nconst loadGlobe = () => import('../globe');\n// üê® use React.lazy to create a Globe component which using a dynamic import\n// to get the Globe component from the '../globe' module.\nconst Globe = React.lazy(loadGlobe);\nconst Fallback = () => <div>loading...</div>;\n\nfunction App() {\n  const [showGlobe, setShowGlobe] = React.useState(false);\n\n  // üê® wrap the code below in a <React.Suspense /> component\n  // with a fallback.\n  // üí∞ try putting it in a few different places and observe how that\n  // impacts the user experience.\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        height: '100%',\n        padding: '2rem',\n      }}\n    >\n      <label style={{ marginBottom: '1rem' }}>\n        <input\n          type=\"checkbox\"\n          checked={showGlobe}\n          onChange={e => setShowGlobe(e.target.checked)}\n          onMouseEnter={loadGlobe}\n          onFocus={loadGlobe}\n        />\n        {' show globe'}\n      </label>\n\n      <div style={{ width: 400, height: 400 }}>\n        <React.Suspense fallback={<Fallback />}>\n          {showGlobe ? <Globe /> : null}\n        </React.Suspense>\n      </div>\n    </div>\n  );\n}\n// ü¶â Note that if you're not on the isolated page, then you'll notice that this\n// app actually already has a React.Suspense component higher up in the tree\n// where this component is rendered, so you *could* just rely on that one.\n\nexport default App;\n")),Object(o.b)("h3",{id:"webpack-magic-comments"},"Webpack Magic Comments"),Object(o.b)("p",null,"A comment like the following will allow you to start pre-fetching some other resources. Webpack has an API for you to hook into."),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"import(/* webpackPrefetch: true */ './some-module.js');\n")),Object(o.b)("p",null,"You can confirm this prefetch work based on what shows in the elements tab under the ",Object(o.b)("inlineCode",{parentName:"p"},"head")," tag to see the prefetch links have been added."),Object(o.b)("h3",{id:"suspense-position"},"Suspense Position"),Object(o.b)("p",null,"In future React, there will be some implications for React Suspense for when it is mounted as opposed to updated."),Object(o.b)("p",null,"It is also very important for the position of your Suspense tool to be correct."),Object(o.b)("p",null,'There is also the capability to click a button to "suspend" the component and see what is looks like from the React DevTools.'),Object(o.b)("h3",{id:"understanding-the-coverage-report"},"Understanding the coverage report"),Object(o.b)("p",null,"When you check the coverage of the before and after, you see there are less files in the after and a significant amount of savings."),Object(o.b)("p",null,"Clicking on the individual files also shows you chunks with lines that have and have not been used."),Object(o.b)("h2",{id:"usememo"},"useMemo"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"useMemo")," is the hero you need for expensive calculations and how the API works."),Object(o.b)("p",null,"The example shows a massive list that should not recalculate with the same input value:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// useMemo for expensive calculations\n// http://localhost:3000/isolated/exercise/02.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../filter-cities';\nimport { useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  // üê® wrap getItems in a call to `React.useMemo`\n  const allItems = React.useMemo(() => getItems(inputValue), [inputValue]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"using-a-web-worker"},"Using a Web Worker"),Object(o.b)("p",null,"There is information about this more ",Object(o.b)("a",r({parentName:"p"},{href:"https://kentcdodds.com/blog/speed-up-your-app-with-web-workers"}),"on Kent's blog"),"."),Object(o.b)("p",null,"There is a ",Object(o.b)("inlineCode",{parentName:"p"},"workerize")," Webpack loader that can be used with Webpack that helps this process."),Object(o.b)("h2",{id:"reactmemo"},"React.memo"),Object(o.b)("p",null,"The lifecycle of a React app goes ",Object(o.b)("inlineCode",{parentName:"p"},"render -> reconciliation -> commit -> state change -> repeat"),"."),Object(o.b)("p",null,"React is fast at doing this, but sometimes it needs help for Performance."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: you should fix slow renders before you fix re-renders.")),Object(o.b)("p",null,'In the React DevTools profile, you can shift through each "commit" on the top "bar chart". We can rectify some of these issues using ',Object(o.b)("inlineCode",{parentName:"p"},"pureComponent")," or ",Object(o.b)("inlineCode",{parentName:"p"},"memo"),"."),Object(o.b)("p",null,"We seriously improved the experience with this:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// üê® Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// üê® Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"custom-comparator"},"Custom Comparator"),Object(o.b)("p",null,"We can create a custom comparator to define when we should re-render."),Object(o.b)("p",null,"In the above, you may notice that highlighting a component is forcing all items to re-render."),Object(o.b)("p",null,"We can get around this using a custom comparator in ",Object(o.b)("inlineCode",{parentName:"p"},"React.memo")," as the second argument for the ",Object(o.b)("inlineCode",{parentName:"p"},"ListItem"),"."),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          selectedItem={selectedItem}\n          highlightedIndex={highlightedIndex}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// üê® Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  selectedItem,\n  highlightedIndex,\n  ...props\n}) {\n  const isSelected = selectedItem?.id === item.id;\n  const isHighlighted = highlightedIndex === index;\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// üê® Memoize the ListItem here using React.memo and use Domain Specific Knowledge\n// to help React know when it should trigger a re-render.\nListItem = React.memo(ListItem, (prevProps, nextProps) => {\n  if (prevProps.getItemProps !== nextProps.getItemProps) return false;\n  if (prevProps.items !== nextProps.items) return false;\n  if (prevProps.index !== nextProps.index) return false;\n  if (prevProps.selectItem !== nextProps.selectItem) return false;\n\n  if (prevProps.highlightedIndex !== nextProps.highlightedIndex) {\n    const wasPrevHighlighed = prevProps.highlightedIndex === prevProps.index;\n    const isNowHighlighted = nextProps.highlightedIndex === nextProps.index;\n\n    return wasPrevHighlighed === isNowHighlighted;\n  }\n\n  return true;\n});\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"primitive-values"},"Primitive values"),Object(o.b)("p",null,"Here we want to reduce the size of the custom comparator by only passing primitive values."),Object(o.b)("p",null,"Now that we are passing primities, we don't need our custom comparator!"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// React.memo for reducing unnecessary re-renders\n// http://localhost:3000/isolated/exercise/03.js\n\nimport * as React from 'react';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n}) {\n  return (\n    <ul {...getMenuProps()}>\n      {items.map((item, index) => (\n        <ListItem\n          key={item.id}\n          getItemProps={getItemProps}\n          item={item}\n          index={index}\n          isSelected={selectedItem?.id === item.id}\n          isHighlighted={highlightedIndex === index}\n        >\n          {item.name}\n        </ListItem>\n      ))}\n    </ul>\n  );\n}\n// üê® Memoize the Menu here using React.memo\nMenu = React.memo(Menu);\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isSelected,\n  isHighlighted,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          fontWeight: isSelected ? 'bold' : 'normal',\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n        },\n        ...props,\n      })}\n    />\n  );\n}\n// üê® Memoize the ListItem here using React.memo\nListItem = React.memo(ListItem);\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: allItems, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n  const items = allItems.slice(0, 100);\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h2",{id:"window-large-lists-with-react-virtual"},"Window Large Lists with react-virtual"),Object(o.b)("p",null,"This updates an incredibly large list to use react-virtual which can make a ",Object(o.b)("inlineCode",{parentName:"p"},"ul")," absolute and then we use a custom styled ",Object(o.b)("inlineCode",{parentName:"p"},"li")," in addition to the list item to provide the items:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Window large lists with react-virtual\n// http://localhost:3000/isolated/exercise/04.js\n\nimport * as React from 'react';\n// üê® import the useVirtual hook from react-virtual\nimport { useVirtual } from 'react-virtual';\nimport { useCombobox } from '../use-combobox';\nimport { getItems } from '../workerized-filter-cities';\nimport { useAsync, useForceRerender } from '../utils';\n\n// üí∞ I made this for you, you'll need it later:\nconst getVirtualRowStyles = ({ size, start }) => ({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  width: '100%',\n  height: size,\n  transform: `translateY(${start}px)`,\n});\n\nfunction Menu({\n  items,\n  getMenuProps,\n  getItemProps,\n  highlightedIndex,\n  selectedItem,\n  // üê® accept listRef, virtualRows, totalHeight\n  listRef,\n  virtualRows,\n  totalHeight,\n}) {\n  return (\n    // üê® pass the listRef to the `getMenuProps` prop getter function below:\n    // üí∞  getMenuProps({ref: listRef})\n    <ul {...getMenuProps({ ref: listRef })}>\n      {/* üê® add a li here with an inline style for the height set to the totalHeight */}\n      <li style={{ height: totalHeight }} />\n      {/*\n        ü¶â this is to ensure that the scrollable area of the <ul /> is the\n        same height it would be if we were actually rendering everything\n      */}\n      {/* instead of mapping the \"items\" we're going to map over the virtualRows */}\n      {/* üê® swap `items` with `virtualRows` */}\n      {/*\n        üí∞ a virtual row is an object with the following properties:\n        - index: you can use this to get the `item` via `items[index]`\n        - size: set the \"height\" style to this value\n        - start: this is how many pixels from the scrollTop this item should be\n      */}\n      {virtualRows.map(({ index, size, start }) => {\n        const item = items[index];\n        return (\n          <ListItem\n            key={item.id}\n            getItemProps={getItemProps}\n            item={item}\n            index={index}\n            isSelected={selectedItem?.id === item.id}\n            isHighlighted={highlightedIndex === index}\n            // üê® pass a style prop, you can get the inline styles from getVirtualRowStyles()\n            // make sure to pass an object with the size (the height of the row)\n            // and start (where the row starts relative to the scrollTop of its container).\n            style={getVirtualRowStyles({ size, start })}\n          >\n            {item.name}\n          </ListItem>\n        );\n      })}\n    </ul>\n  );\n}\n\nfunction ListItem({\n  getItemProps,\n  item,\n  index,\n  isHighlighted,\n  isSelected,\n  // üê® accept the style prop\n  style,\n  ...props\n}) {\n  return (\n    <li\n      {...getItemProps({\n        index,\n        item,\n        style: {\n          backgroundColor: isHighlighted ? 'lightgray' : 'inherit',\n          fontWeight: isSelected ? 'bold' : 'normal',\n          // üê® spread the incoming styles onto this inline style object\n          ...style,\n        },\n        ...props,\n      })}\n    />\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  const [inputValue, setInputValue] = React.useState('');\n\n  const { data: items, run } = useAsync({ data: [], status: 'pending' });\n  React.useEffect(() => {\n    run(getItems(inputValue));\n  }, [inputValue, run]);\n\n  // üê® create a listRef with React.useRef\n  // which will be used for the parentRef option you pass to useVirtual\n  // and should be applied to the <ul /> for our menu. This is how react-virtual\n  // knows how to scroll our items as the user scrolls.\n  const listRef = React.useRef();\n\n  // üê® call useVirtual with the following configuration options:\n  // - size (the number of items)\n  // - parentRef (the listRef you created above)\n  // - estimateSize (a memoized callback function that returns the size for each item)\n  //   üí∞ in our case, every item has the same size, so this will do: React.useCallback(() => 20, [])\n  // - overscan (the number of additional rows to render outside the scrollable view)\n  //   üí∞ You can play around with that number, but you probably don't need more than 10.\n  // üê® you can set the return value of your useVirtual call to `rowVirtualizer`\n  const rowVirtualizer = useVirtual({\n    size: items.length,\n    parentRef: listRef,\n    estimateSize: React.useCallback(() => 20, []),\n    overscan: 10,\n  });\n\n  const {\n    selectedItem,\n    highlightedIndex,\n    getComboboxProps,\n    getInputProps,\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    selectItem,\n  } = useCombobox({\n    items,\n    inputValue,\n    onInputValueChange: ({ inputValue: newValue }) => setInputValue(newValue),\n    onSelectedItemChange: ({ selectedItem }) =>\n      alert(\n        selectedItem\n          ? `You selected ${selectedItem.name}`\n          : 'Selection Cleared',\n      ),\n    itemToString: item => (item ? item.name : ''),\n    // we want to override Downshift's scrollIntoView functionality because\n    // react-virtual will handle scrolling for us:\n    // üê® set scrollIntoView to a \"no-op\" function\n    // üí∞ scrollIntoView: () => {},\n    scrollIntoView: () => {},\n    // üê® when the highlightedIndex changes, then tell react-virtual to scroll\n    // to that index.\n    // üí∞ onHighlightedIndexChange: ({highlightedIndex}) => highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n    onHighlightedIndexChange: ({ highlightedIndex }) =>\n      highlightedIndex !== -1 && rowVirtualizer.scrollToIndex(highlightedIndex),\n  });\n\n  return (\n    <div className=\"city-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <label {...getLabelProps()}>Find a city</label>\n        <div {...getComboboxProps()}>\n          <input {...getInputProps({ type: 'text' })} />\n          <button onClick={() => selectItem(null)} aria-label=\"toggle menu\">\n            &#10005;\n          </button>\n        </div>\n        <Menu\n          items={items}\n          getMenuProps={getMenuProps}\n          getItemProps={getItemProps}\n          highlightedIndex={highlightedIndex}\n          selectedItem={selectedItem}\n          // üê® pass the following props:\n          listRef={listRef}\n          virtualRows={rowVirtualizer.virtualItems}\n          totalHeight={rowVirtualizer.totalSize}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h2",{id:"optimize-context-value"},"Optimize Context Value"),Object(o.b)("p",null,"In this challenge, we are memoizing the value we are passing as the value to the Context Provider."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},'"The way that context works is that whenever the provided value changes from one render to another, it triggers a re-render of all the consuming components (which will re-render whether or not they‚Äôre memoized)."')),Object(o.b)("p",null,"A ",Object(o.b)("a",r({parentName:"p"},{href:"https://github.com/kentcdodds/kentcdodds.com/blob/319db97260078ea4c263e75166f05e2cea21ccd1/content/blog/how-to-optimize-your-context-value/index.md"}),"post from Kent")," highlights when it is important to memoize the context value:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Your context value changes frequently"),Object(o.b)("li",{parentName:"ol"},"Your context has many consumers"),Object(o.b)("li",{parentName:"ol"},"You are bothering to use React.memo (because things are legit slow)"),Object(o.b)("li",{parentName:"ol"},"You've actually measured things and you know it's slow and needs to be optimized")),Object(o.b)("p",null,"In the example given, we needed to ensure the provider was memoized so that the lower children were helped when ",Object(o.b)("inlineCode",{parentName:"p"},"App")," was force re-rendered:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n  // üê® memoize this value with React.useMemo\n  const value = React.useMemo(() => [state, dispatch], [state, dispatch]);\n  // const value = [state, dispatch]\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const [, dispatch] = useAppState();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const [state, dispatch] = useAppState();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("p",null,"The results can be seen in these screenshots:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"Force rerender without memoization",src:t("NWKA")})),Object(o.b)("p",null,Object(o.b)("img",{alt:"Force rerender with memoization",src:t("oSn5")})),Object(o.b)("h3",{id:"separate-the-contexts"},"Separate the contexts"),Object(o.b)("p",null,'Another issue we run into is that when we click on a grid item, our state is updating. Because the state "did update", we are getting a new array in the memoised ',Object(o.b)("inlineCode",{parentName:"p"},"AppProvider")," and therefore this change is re-rendering everything that consumes the state (even though the ",Object(o.b)("inlineCode",{parentName:"p"},"Grid")," only needs to consume the dispatch!)"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Optimize context value\n// http://localhost:3000/isolated/exercise/05.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n    grid: initialGrid,\n  });\n\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const cell = state.grid[row][column];\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  const state = useAppState();\n  const dispatch = useAppDispatch();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\n\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: at the end of this challenge on production, we'll see that we didn't make ",Object(o.b)("em",{parentName:"p"},"huge changes")," to the timing.")),Object(o.b)("h2",{id:"fix-perf-deatch-by-a-thousand-cuts"},"Fix Perf Deatch by a Thousand Cuts"),Object(o.b)("p",null,"In this example, we had to fix an input that was operating horrifically slow. The reason we come to find is related to a requirement of state colocation with the component."),Object(o.b)("p",null,"It is important NOT to just add everything to the state context willy nilly. There are a lot of Performance implications with this."),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Fix \"perf death by a thousand cuts\"\n// http://localhost:3000/isolated/exercise/06.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nAppStateContext.displayName = 'AppStateContext';\nconst AppDispatchContext = React.createContext();\nAppDispatchContext.displayName = 'AppDispatchContext';\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    // we're no longer managing the dogName state in our reducer\n    // üí£ remove this case\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // üê® replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [dogName, setDogName] = React.useState('');\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    setDogName(newDogName);\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogNameInput />\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"separate-contexts"},"Separate Contexts"),Object(o.b)("p",null,"This solution is about going for a different approach. The approach here is to handle when things are global. We can separate context out for different domains."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"It is really important to also measure after to see if you've made serious Performance improvements and not just added complexity.")),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"import * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n\nconst AppStateContext = React.createContext();\nconst AppDispatchContext = React.createContext();\nconst DogContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_GRID_CELL': {\n      return { ...state, grid: updateGridCellState(state.grid, action) };\n    }\n    case 'UPDATE_GRID': {\n      return { ...state, grid: updateGridState(state.grid) };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    grid: initialGrid,\n  });\n  return (\n    <AppStateContext.Provider value={state}>\n      <AppDispatchContext.Provider value={dispatch}>\n        {children}\n      </AppDispatchContext.Provider>\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = React.useContext(AppDispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction dogReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction DogProvider(props) {\n  const [state, dispatch] = React.useReducer(dogReducer, {\n    dogName: '',\n  });\n\n  const value = [state, dispatch];\n\n  return <DogProvider value={value} {...props} />;\n}\n\nfunction useDogContext() {\n  const context = React.useContext(DogContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  const dispatch = useAppDispatch();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => dispatch({ type: 'UPDATE_GRID' });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\nGrid = React.memo(Grid);\n\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = React.memo(Cell);\n\nfunction DogNameInput() {\n  // üê® replace the useAppState and useAppDispatch with a normal useState here\n  // to manage the dogName locally within this component\n  const [state, dispatch] = useDogContext();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    // üê® change this to call your state setter that you get from useState\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <AppProvider>\n        <div>\n          <DogProvider>\n            <DogNameInput />\n          </DogProvider>\n          <Grid />\n        </div>\n      </AppProvider>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: Because the ",Object(o.b)("inlineCode",{parentName:"p"},"AppProvider")," not longer impacts anything other than the grid, we can also change the Providers to focus more where is matters:")),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),'function App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className="grid-app">\n      <button onClick={forceRerender}>force rerender</button>\n      <div>\n        <DogProvider>\n          <DogNameInput />\n        </DogProvider>\n        <AppProvider>\n          <Grid />\n        </AppProvider>\n      </div>\n    </div>\n  );\n}\n')),Object(o.b)("h3",{id:"consuming-components"},"Consuming Components"),Object(o.b)("p",null,"If we check our profiling after the changes that we made above, we will see that when we click a button, there are still all these smaller re-renderings that are happening."),Object(o.b)("p",null,"In this particular scenario, it is the ",Object(o.b)("inlineCode",{parentName:"p"},"const cell = state.grid[row][column]")," line that we want to take out from the cell and calculate prior."),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// This is like a \"man-in-middle\" that cares about state and can take that,\n// pass it down and then the rendering of the CellImpl can take advantage of memoisation\nfunction Cell({ row, column }) {\n  const state = useAppState();\n  const cell = state.grid[row][column];\n  return <CellImpl cell={cell} row={row} column={column} />;\n}\nCell = React.memo(Cell);\n\nfunction CellImpl({ cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCellImpl = React.memo(CellImpl);\n")),Object(o.b)("h3",{id:"slice-of-app-state"},"Slice of App State"),Object(o.b)("p",null,'"I\'m not super jazzed about making an intermediary component". Instead, we can make a higher-order component to take care of it for us instead.'),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"function withStateSlice(Comp, slice) {\n  const MemoComp = React.memo(Comp);\n  function Wrapper(props, ref) {\n    const state = useAppState();\n    return <MemoComp ref={ref} state={slice(state, props)} {...props} />;\n  }\n  Wrapper.displayName = `withStateSlice${Comp.dispayName || Comp.name}`;\n  return React.memo(React.forwardRef(Wrapper));\n}\n\nfunction Cell({ state: cell, row, column }) {\n  const dispatch = useAppDispatch();\n  const handleClick = () => dispatch({ type: 'UPDATE_GRID_CELL', row, column });\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\nCell = withStateSlice(\n  Cell,\n  (state, { row, column }) => state.grid[row][column],\n);\n")),Object(o.b)("h3",{id:"use-recoil"},"Use Recoil"),Object(o.b)("p",null,"For the specific problem we have with the massive grid (if we want to use something like that), we can use Recoil to resolve the problems that we run into."),Object(o.b)("p",null,"It is worth noting that there is a complexity cost for using Recoil, but in our specific usecase, it is something that Recoil was built to solve:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Starting point for the Recoil Extra Credit\n// üíØ use recoil (exercise)\n// http://localhost:3000/isolated/exercise/06.extra-4.js\n\nimport * as React from 'react';\nimport {\n  useForceRerender,\n  useDebouncedState,\n  AppGrid,\n  updateGridState,\n  updateGridCellState,\n} from '../utils';\n// üê® you're gonna need these:\nimport {\n  RecoilRoot,\n  useRecoilState,\n  useRecoilCallback,\n  atomFamily,\n} from 'recoil';\n\nconst AppStateContext = React.createContext();\n\nconst initialGrid = Array.from({ length: 100 }, () =>\n  Array.from({ length: 100 }, () => Math.random() * 100),\n);\n\n// üê® create an atomFamily called `cellAtoms` here where the\n// default callback function accepts an object with the\n// `row` and `column` and returns the value from the initialGrid\n// üí∞ initialGrid[row][column]\nconst cellAtoms = atomFamily({\n  key: 'cells',\n  default: () => ({ row, column }) => initialGrid[row][column],\n});\n\n// üí∞ I'm going to give this hook to you as it's mostly here for our contrived\n// example purposes. Just comment this in when you're ready to use it.\n// Here's how it's used:\n// const updateGrid = useUpdateGrid()\n// then later: updateGrid({rows, columns})\nfunction useUpdateGrid() {\n  return useRecoilCallback(({ set }) => ({ rows, columns }) => {\n    for (let row = 0; row < rows; row++) {\n      for (let column = 0; column < columns; column++) {\n        if (Math.random() > 0.7) {\n          set(cellAtoms({ row, column }), Math.random() * 100);\n        }\n      }\n    }\n  });\n}\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'TYPED_IN_DOG_INPUT': {\n      return { ...state, dogName: action.dogName };\n    }\n    default: {\n      throw new Error(`Unhandled action type: ${action.type}`);\n    }\n  }\n}\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = React.useReducer(appReducer, {\n    dogName: '',\n  });\n  // ü¶â notice that we don't even need to bother memoizing this value\n  const value = [state, dispatch];\n  return (\n    <AppStateContext.Provider value={value}>\n      {children}\n    </AppStateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  const context = React.useContext(AppStateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within the AppProvider');\n  }\n  return context;\n}\n\nfunction Grid() {\n  // üê® we're no longer storing the grid in our app state, so instead you\n  // want to get the updateGrid function from useUpdateGrid\n  const updateGrid = useUpdateGrid();\n  const [rows, setRows] = useDebouncedState(50);\n  const [columns, setColumns] = useDebouncedState(50);\n  const updateGridData = () => updateGrid({ rows, columns });\n  return (\n    <AppGrid\n      onUpdateGrid={updateGridData}\n      rows={rows}\n      handleRowsChange={setRows}\n      columns={columns}\n      handleColumnsChange={setColumns}\n      Cell={Cell}\n    />\n  );\n}\n\nfunction Cell({ row, column }) {\n  const [cell, setCell] = useRecoilState(cellAtoms({ row, column }));\n  const handleClick = () => setCell(Math.random() * 100);\n\n  return (\n    <button\n      className=\"cell\"\n      onClick={handleClick}\n      style={{\n        color: cell > 50 ? 'white' : 'black',\n        backgroundColor: `rgba(0, 0, 0, ${cell / 100})`,\n      }}\n    >\n      {Math.floor(cell)}\n    </button>\n  );\n}\n\nfunction DogNameInput() {\n  const [state, dispatch] = useAppState();\n  const { dogName } = state;\n\n  function handleChange(event) {\n    const newDogName = event.target.value;\n    dispatch({ type: 'TYPED_IN_DOG_INPUT', dogName: newDogName });\n  }\n\n  return (\n    <form onSubmit={e => e.preventDefault()}>\n      <label htmlFor=\"dogName\">Dog Name</label>\n      <input\n        value={dogName}\n        onChange={handleChange}\n        id=\"dogName\"\n        placeholder=\"Toto\"\n      />\n      {dogName ? (\n        <div>\n          <strong>{dogName}</strong>, I've a feeling we're not in Kansas anymore\n        </div>\n      ) : null}\n    </form>\n  );\n}\nfunction App() {\n  const forceRerender = useForceRerender();\n  return (\n    <div className=\"grid-app\">\n      <button onClick={forceRerender}>force rerender</button>\n      <RecoilRoot>\n        <AppProvider>\n          <div>\n            <DogNameInput />\n            <Grid />\n          </div>\n        </AppProvider>\n      </RecoilRoot>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("p",null,"Read more on ",Object(o.b)("a",r({parentName:"p"},{href:"https://recoiljs.org/docs/introduction/motivation"}),"Recoil")," from their docs."),Object(o.b)("h2",{id:"production-performance-monitoring"},"Production Performance Monitoring"),Object(o.b)("p",null,"A great way to prevent changes from regressions, we can use production performance monitoring."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Note: There is a small performance cost involved with profiling. Facebook A/B serves a version with profiling involved.")),Object(o.b)("p",null,"This exercise looks at using the ",Object(o.b)("a",r({parentName:"p"},{href:"https://reactjs.org/docs/profiler.html"}),"React Profiler API"),"."),Object(o.b)("p",null,"The usage and callback:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),'<App>\n  <Profiler id="Navigation" onRender={onRenderCallback}>\n    <Navigation {...props} />\n  </Profiler>\n  <Main {...props} />\n</App>;\n\n// callback\nfunction onRenderCallback(\n  id, // the "id" prop of the Profiler tree that has just committed\n  phase, // either "mount" (if the tree just mounted) or "update" (if it re-rendered)\n  actualDuration, // time spent rendering the committed update\n  baseDuration, // estimated time to render the entire subtree without memoization\n  startTime, // when React began rendering this update\n  commitTime, // when React committed this update\n  interactions, // the Set of interactions belonging to this update\n) {\n  // Aggregate or log render timings...\n}\n')),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},'"It‚Äôs important to note that unless you build your app using react-dom/profiling and scheduler/tracing-profiling this component won‚Äôt do anything."')),Object(o.b)("p",null,"Kent also has a ",Object(o.b)("a",r({parentName:"p"},{href:"https://kentcdodds.com/blog/react-production-performance-monitoring/"}),"blog post")," on the profiling."),Object(o.b)("p",null,"The solution to record one:"),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"// Production performance monitoring\n// http://localhost:3000/isolated/exercise/07.js\n\nimport * as React from 'react';\n// üê® you're going to need the reportProfile function\n// üí∞ here, let me help you with that..\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  const increment = () => setCount(c => c + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      üê® Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("h3",{id:"tracing-api"},"Tracing API"),Object(o.b)("p",null,'So we don\'t know "why" the user caused the rerendering so we can use an ',Object(o.b)("inlineCode",{parentName:"p"},"unstable_trace")," to check."),Object(o.b)("pre",null,Object(o.b)("code",r({parentName:"pre"},{className:"language-js"}),"import * as React from 'react';\nimport { unstable_trace as trace } from 'scheduler/tracing';\nimport reportProfile from '../report-profile';\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  // We can wrap the setCount callback to use the trace API\n  const increment = trace('click', performance.now(), () =>\n    setCount(c => c + 1),\n  );\n  return <button onClick={increment}>{count}</button>;\n}\n\nfunction App() {\n  return (\n    <div>\n      {/*\n      üê® Wrap this div in a React.Profiler component\n      give it the ID of \"counter\" and pass reportProfile\n      to the onRender prop.\n      */}\n      <React.Profiler id=\"counter\" onRender={reportProfile}>\n        <div>\n          Profiled counter\n          <Counter />\n        </div>\n      </React.Profiler>\n      <div>\n        Unprofiled counter\n        <Counter />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n")),Object(o.b)("p",null,"That is it! Now when the user clicks, we can get more information thanks to the trace that comes under the ",Object(o.b)("inlineCode",{parentName:"p"},"interactions")," value."),Object(o.b)("p",null,"With the ",Object(o.b)("inlineCode",{parentName:"p"},"trace")," API, we can also start to use the ",Object(o.b)("inlineCode",{parentName:"p"},"user interactions")," section of the React profile!"))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/Epic-React/React-Performance.md"}}),c.isMDXComponent=!0},oSn5:function(e,n,t){e.exports=t.p+"static/force-rerender-with-memoization-b63b1632d8dcc8bf32c8eade5c4ce2a9.png"}}]);
//# sourceMappingURL=component---manual-epic-react-react-performance-md-2a845c032cd2b505d9d2.js.map