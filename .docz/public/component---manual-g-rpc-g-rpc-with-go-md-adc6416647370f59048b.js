(window.webpackJsonp=window.webpackJsonp||[]).push([[257],{"7C+S":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return a})),t.d(n,"default",(function(){return c}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var l=t("/FXl"),r=t("TjRS");t("aD51");function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var l in t)Object.prototype.hasOwnProperty.call(t,l)&&(e[l]=t[l])}return e}).apply(this,arguments)}var a={};void 0!==a&&a&&a===Object(a)&&Object.isExtensible(a)&&!a.hasOwnProperty("__filemeta")&&Object.defineProperty(a,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/gRPC/gRPC-with-Go.md"}});var i={_frontmatter:a},s=r.a;function c(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,l,r={},o=Object.keys(e);for(l=0;l<o.length;l++)t=o[l],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,["components"]);return Object(l.b)(s,o({},i,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("h1",{id:"grpc-with-golang"},"gRPC with Golang"),Object(l.b)("h2",{id:"resources"},"Resources"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://www.udemy.com/course/grpc-golang/"}),"gRPC course Udemy")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://grpc.io/"}),"gRPC.io")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://imagekit.io/demo/http2-vs-http1"}),"HTTP2 vs HTTP1 image loading website")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://github.com/grpc/grpc-go"}),"gRPC-Go")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://github.com/golang/protobuf"}),"Go Protobuf")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://blog.coinbase.com/grpc-to-aws-lambda-is-it-possible-4b29a9171d7f"}),"gRPC with Lambda")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://github.com/twitchtv/twirp"}),"Twirp")),Object(l.b)("li",{parentName:"ol"},Object(l.b)("a",o({parentName:"li"},{href:"https://rynop.com/2018/01/23/twirpl-twirp-go-framework-running-completely-serverless/"}),"Twirpl 2018 post"))),Object(l.b)("h2",{id:"intro"},"Intro"),Object(l.b)("p",null,"gRPC is there to attempt to solve the difficulties of API design."),Object(l.b)("p",null,"gRPC is an open-source framework developed by Google which is now part of CNCF."),Object(l.b)("p",null,"At a high level, it allows you to define REQUEST and RESPONSE for RPCs and handles the rest."),Object(l.b)("h3",{id:"benefits"},"Benefits"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"Fast + efficient"),Object(l.b)("li",{parentName:"ol"},"Built on HTTP/2"),Object(l.b)("li",{parentName:"ol"},"Low latenvy"),Object(l.b)("li",{parentName:"ol"},"Supports streaming"),Object(l.b)("li",{parentName:"ol"},"Language independent"),Object(l.b)("li",{parentName:"ol"},"Easy to plug in with integrated auth, load balancing, logging and monitoring")),Object(l.b)("h2",{id:"remote-procedural-call"},"Remote Procedural Call"),Object(l.b)("p",null,"In the CLIENT code, it looks like you're just callng a function on the SERVER."),Object(l.b)("p",null,"With gRPC, it is implemented cleanly and solves a lot of problems."),Object(l.b)("h2",{id:"getting-started"},"Getting started"),Object(l.b)("p",null,"At the core of gRPC, you need to define the messages and services using ",Object(l.b)("inlineCode",{parentName:"p"},"Protocol Buffers"),"."),Object(l.b)("p",null,"The rest of the gRPC code will be generated for you and you'll have to provide and implementation for it."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"One ",Object(l.b)("inlineCode",{parentName:"p"},".proto")," file can be used for over 12 different languages.")),Object(l.b)("h3",{id:"example-proto-file"},"Example proto file"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-proto"}),"syntax = 'proto3';\n\nmessage Greeting {\n  string first_name = 1;\n}\n\nmessage GreetRequest {\n  Greeting greeting = 1;\n}\n\nmessage Greeting {\n  string result = 1;\n}\n\nservice GreetService {\n  rpc Greet(GreetRequest) returns (GreetResponse) {};\n}\n")),Object(l.b)("h2",{id:"why-protocol-buffers"},"Why Protocol Buffers?"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Language agnostic."),Object(l.b)("li",{parentName:"ul"},"Code can be generated for pretty much any language."),Object(l.b)("li",{parentName:"ul"},"Data is binary and efficiently serialized (small payloads)."),Object(l.b)("li",{parentName:"ul"},"Very convenient for transporting a lot of data."),Object(l.b)("li",{parentName:"ul"},"Protocol Buffers allows for easy API evolution using rules."),Object(l.b)("li",{parentName:"ul"},"Easy to write messag definition."),Object(l.b)("li",{parentName:"ul"},"Definition of API independent from implementation."),Object(l.b)("li",{parentName:"ul"},"A hug amount of code can be generated, in any language, from a simple ",Object(l.b)("inlineCode",{parentName:"li"},".proto")," file."),Object(l.b)("li",{parentName:"ul"},"Payload is binary, therefore very efficient to send/receive on a network and serialize/de-serialize on a CPU.")),Object(l.b)("h3",{id:"protocol-buffers--interoperability"},"Protocol Buffers & Interoperability"),Object(l.b)("p",null,'One benefit Protobuf is used the size of the messsage and savings through network benefit. A JSON comparison of an object for "person" vs a Protobuf shows a 55 byte vs 20 byte difference, event with small messages.'),Object(l.b)("p",null,"Parsing Protocol Buggers (binary format) means faster and more efficient communication. This has added benefit for mobile devices with slower CPUs."),Object(l.b)("h3",{id:"grpc-languages"},"gRPC languages"),Object(l.b)("p",null,"Java, Go and C have native, pure bindings. The rest rely on GRPC-C."),Object(l.b)("h2",{id:"http2-vs-http1"},"HTTP/2 vs HTTP/1"),Object(l.b)("h3",{id:"http1"},"HTTP/1"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Released in 1997."),Object(l.b)("li",{parentName:"ul"},"Opens a new TCP connection for each request."),Object(l.b)("li",{parentName:"ul"},"Does not compress headers (which are plaintext)."),Object(l.b)("li",{parentName:"ul"},"Only works with Req/Res mechanism (no server push)."),Object(l.b)("li",{parentName:"ul"},"Original composed of GET and POST."),Object(l.b)("li",{parentName:"ul"},"80 assets for load will request headers sent for every request. 80 assets = 80 TCP connections. Inefficient for latency and increases network packet size.")),Object(l.b)("h3",{id:"http2"},"HTTP/2"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"2015 release but battle tested by Google."),Object(l.b)("li",{parentName:"ul"},"Supports multiplexing (parallel messages pushed)."),Object(l.b)("li",{parentName:"ul"},"Supports server push (multiple messages for one client request)."),Object(l.b)("li",{parentName:"ul"},"Supports header compression."),Object(l.b)("li",{parentName:"ul"},"HTTP/2 is binary. Any binary protocol is a great match."),Object(l.b)("li",{parentName:"ul"},"HTTP/2 is secure (SSL not required by recommended by default)."),Object(l.b)("li",{parentName:"ul"},'"Less chatter". Less bandwidth, reduced latency, increased security.')),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"gRPC only uses HTTP/2.")),Object(l.b)("h2",{id:"4-types-of-api-in-grpc"},"4 Types of API in gRPC"),Object(l.b)("ol",null,Object(l.b)("li",{parentName:"ol"},"Unary"),Object(l.b)("li",{parentName:"ol"},"Server streaming"),Object(l.b)("li",{parentName:"ol"},"Client streaming"),Object(l.b)("li",{parentName:"ol"},"Bi-directional streaming")),Object(l.b)("p",null,"The following shows how easy it is to define the streaming contracts:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-proto",metastring:"vs",vs:!0}),"service GreetService {\n  // Unary\n  rpc Greet(GreetRequest) returns (GreetResponse) {};\n\n  // Streaming Server\n  rpc GreetManyTimes(GreetManyTimesRequest) returns (stream GreetManyTimesResponse) {};\n\n  // Streaming Client\n  rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {};\n\n  // Bidirectional Streaming\n  rpc GreetEveryone(stream GreetEveryoneRequest) returns (stream GreetEveryoneResponse) {};\n}\n")),Object(l.b)("h2",{id:"grpc-scalability"},"gRPC Scalability"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Async by default (ie non-blocking)."),Object(l.b)("li",{parentName:"ul"},"Can serve millions of reqs in parallel."),Object(l.b)("li",{parentName:"ul"},"gRPC clients can be async or sync. Client decides on modal best for performance needs."),Object(l.b)("li",{parentName:"ul"},"gRPC Clients can perform clientside load balancing.")),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"Google have 10 billion gRPC reqs per second internally.")),Object(l.b)("h2",{id:"grpc-security"},"gRPC Security"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Strongly advocats for SSL in API."),Object(l.b)("li",{parentName:"ul"},"gRPC has security as a first class citizen."),Object(l.b)("li",{parentName:"ul"},"ach language will provide an API to load gRPC with required certificates and provide encyption out-of-the-box."),Object(l.b)("li",{parentName:"ul"},"Additionally using Intercepts, can provide auth.")),Object(l.b)("h2",{id:"getting-started-with-grpc-go"},"Getting Started with gRPC Go"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-s"}),"go get -u google.golang.org/grpc\ngo get -u google.golang.org/protobuf\n")),Object(l.b)("p",null,"After cloning ",Object(l.b)("inlineCode",{parentName:"p"},"https://github.com/simplesteph/grpc-go-course")," and changing into ",Object(l.b)("inlineCode",{parentName:"p"},"Greet/greetpb"),", we can run ",Object(l.b)("inlineCode",{parentName:"p"},"protoc greet.proto --go_out=plugins=grpc:.")," to test the code generation."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"Running ",Object(l.b)("inlineCode",{parentName:"p"},"protoc greet/greetpb/greet.proto --go_out=plugins=grpc:.")," will output the file to ",Object(l.b)("inlineCode",{parentName:"p"},"greet/greetpb/greet.pb.go"),".")),Object(l.b)("h3",{id:"a-hello-service"},"A Hello Service"),Object(l.b)("p",null,"Instead of installing the above, you can do it manually. Inside of ",Object(l.b)("inlineCode",{parentName:"p"},"hello/hellopb/hello.proto"),":"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-proto"}),'syntax = "proto3";\n\npackage hello;\noption go_package = "hello/hellopb";\n\nservice HelloService {}\n')),Object(l.b)("p",null,"Run ",Object(l.b)("inlineCode",{parentName:"p"},"protoc hello/hellopb/hello.proto --go_out=plugins=grpc:.")," to generate ",Object(l.b)("inlineCode",{parentName:"p"},"hello/hellopb/hello.pb.go"),"."),Object(l.b)("h2",{id:"server-boilerplate"},"Server Boilerplate"),Object(l.b)("p",null,"This will show how to properly start & stop the Server on the defined ",Object(l.b)("inlineCode",{parentName:"p"},"port"),"."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"You may need to run ",Object(l.b)("inlineCode",{parentName:"p"},"go mod init github.com/okeeffed/project-name")," at the root of the directory prior.")),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "log"\n    "net"\n\n    "github.com/okeeffed/grpc-go-course/hello/hellopb"\n\n    "google.golang.org/grpc"\n)\n\ntype server struct{}\n\nfunc main() {\n    fmt.Println("Hello world")\n    // :50051 is default gRPC port\n    lis, err := net.Listen("tcp", "0.0.0.0:50051")\n    if err != nil {\n        log.Fatalf("Failed to listen: %v", err)\n    }\n\n    s := grpc.NewServer()\n    hellopb.RegisterHelloServiceServer(s, &server{})\n\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf("Failed to serve: %v", err)\n    }\n}\n')),Object(l.b)("h2",{id:"client-boilerplate"},"Client Boilerplate"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "fmt"\n    "log"\n\n    "github.com/okeeffed/grpc-go-course/hello/hellopb"\n    "google.golang.org/grpc"\n)\n\nfunc main() {\n    fmt.Println("Hello from the client")\n    // WithInsecure for now as we don\'t have SSL certificates\n    conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf("Could not connect: %v", err)\n    }\n\n    defer conn.Close()\n\n    c := hellopb.NewHelloServiceClient(conn)\n    fmt.Printf("Created client: %f", c)\n}\n')),Object(l.b)("p",null,"Now if we start the server and client in two different tabs we can see that we connect!"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-s"}),"# Tab 1\n> go run hello/hello_server/server.go\nHello world\n\n# Tab 2\n>  go run hello/hello_client/client.go\nHello from the client\nCreated client: &{%!f(*grpc.ClientConn=&{0xc0001beb00 0x10e0e70 localhost:50051 {passthrough  localhost:50051} localhost:50051 {<nil> <nil> [] [] <nil> <nil> {{1000000000 1.6 0.2 120000000000}} false false true 0 <nil>  {grpc-go/1.31.0 0x1470140 false [] <nil> <nil> {0 0 false} <nil> 0 0 32768 32768 0 <nil>} [] <nil> 0 false true false <nil> <nil> <nil> <nil> 0x1472400 [] true} 0xc0001aaf40 {<nil> <nil> 0x1470140 0 {passthrough  localhost:50051}} 0xc0002529f0 {{0 0} 0 0 0 0} 0xc0001b2900 0xc00018e6e0 map[0xc0001eb8c0:{}] {0 0 false} pick_first 0xc0001bec00 {<nil>} 0xc0001aaf20 0 0xc0001b6700 {0 0} <nil>})}%\n")),Object(l.b)("h2",{id:"creating-a-unary-api-call"},"Creating a Unary API call"),Object(l.b)("p",null,"We need to create a ",Object(l.b)("inlineCode",{parentName:"p"},"Request")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Response"),"."),Object(l.b)("p",null,'We start by writing the definition - here I will do one for "Hello".'),Object(l.b)("p",null,"We update our ",Object(l.b)("inlineCode",{parentName:"p"},"Hello")," Protobuffer to define ",Object(l.b)("inlineCode",{parentName:"p"},"Greeting")," and a Request + Response:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-proto"}),'syntax = "proto3";\n\npackage hello;\noption go_package = "hello/hellopb";\n\nmessage Hello {\n  string first_name = 1;\n  string last_name = 2;\n}\n\nmessage HelloRequest { Hello hello = 1; }\n\nmessage HelloResponse { string result = 1; }\n\nservice HelloService {\n  // Unary\n  rpc Hello(HelloRequest) returns (HelloResponse) {}\n}\n')),Object(l.b)("p",null,"We can now update the ",Object(l.b)("inlineCode",{parentName:"p"},"server.go")," file to now handle our call from the Client:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'func (*server) Hello(ctx context.Context, req *hellopb.HelloRequest) (*hellopb.HelloResponse, error) {\n    // from the auto generated info\n    firstName := req.GetHello().GetFirstName()\n\n    result := "Hello " + firstName\n    res := &hellopb.HelloResponse{\n        Result: result,\n    }\n\n    return res, nil\n}\n')),Object(l.b)("p",null,"We can now update the client to get the simple response example."),Object(l.b)("h2",{id:"updating-the-client-to-get-a-response"},"Updating the client to get a response"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "context"\n    "fmt"\n    "log"\n\n    "github.com/okeeffed/grpc-go-course/hello/hellopb"\n    "google.golang.org/grpc"\n)\n\nfunc main() {\n    fmt.Println("Hello from the client")\n    // WithInsecure for now as we don\'t have SSL certificates\n    conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf("Could not connect: %v", err)\n    }\n\n    defer conn.Close()\n\n    c := hellopb.NewHelloServiceClient(conn)\n    doUnary(c)\n}\n\nfunc doUnary(c hellopb.HelloServiceClient) {\n    fmt.Println("Starting doUnary RPC")\n\n    // Create a request that takes the "Hello" struct\n    req := &hellopb.HelloRequest{\n        Hello: &hellopb.Hello{\n            FirstName: "Dennis",\n            LastName:  "O\'Keeffe",\n        },\n    }\n    res, err := c.Hello(context.Background(), req)\n\n    if err != nil {\n        log.Fatalf("Error calling greet %v", err)\n    }\n    log.Printf("Response from Greet: %v", res.Result)\n}\n')),Object(l.b)("p",null,"If we now start the server and client, you will see the response."),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-s"}),"# Tab 1\n> go run hello/hello_server/server.go\nHello world\n# Tab 2\n> go run hello/hello_client/client.go\nHello from the client\nStarting doUnary RPC\n2020/08/10 13:47:24 Response from Greet: Hello Dennis\n")),Object(l.b)("h2",{id:"server-streaming"},"Server Streaming"),Object(l.b)("p",null,'Take "one" request and return many responses.'),Object(l.b)("p",null,"For the API, we need to add a receiver function for the server that takes a request and a stream:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'func (*server) HelloManyTimes(req *hellopb.HelloManyTimesRequest, stream hellopb.HelloService_HelloManyTimesServer) error {\n    fmt.Printf("Greet many times function was invoked with %v", req)\n\n    // from the auto generated info\n    firstName := req.GetHello().GetFirstName()\n\n    for i := 0; i < 10; i++ {\n        result := "Hello " + firstName + " number " + strconv.Itoa(i)\n        res := &hellopb.HelloManyTimesResponse{\n            Result: result,\n        }\n        stream.Send(res)\n        time.Sleep(1000 * time.Millisecond)\n    }\n\n    return nil\n}\n')),Object(l.b)("p",null,"For the client, it is fairly simple:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "context"\n    "fmt"\n    "io"\n    "log"\n\n    "github.com/okeeffed/grpc-go-course/hello/hellopb"\n    "google.golang.org/grpc"\n)\n\nfunc main() {\n    fmt.Println("Hello from the client")\n    // WithInsecure for now as we don\'t have SSL certificates\n    conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())\n    if err != nil {\n        log.Fatalf("Could not connect: %v", err)\n    }\n\n    defer conn.Close()\n\n    c := hellopb.NewHelloServiceClient(conn)\n    doServerStreaming(c)\n}\n\nfunc doServerStreaming(c hellopb.HelloServiceClient) {\n    fmt.Println("Starting a Server Streaming RPC")\n\n    // Create a request that takes the "Hello" struct\n    req := &hellopb.HelloManyTimesRequest{\n        Hello: &hellopb.Hello{\n            FirstName: "Dennis",\n            LastName:  "O\'Keeffe",\n        },\n    }\n\n    // returns client and err\n    resStream, err := c.HelloManyTimes(context.Background(), req)\n\n    if err != nil {\n        log.Fatalf("Error calling greet %v", err)\n    }\n    for {\n        msg, err := resStream.Recv()\n        if err == io.EOF {\n            // reached the end\n            break\n        }\n\n        if err != nil {\n            log.Fatalf("Error calling greet %v", err)\n        }\n\n        log.Printf("Response from GreetManyTimes: %v", msg.GetResult())\n    }\n}\n')),Object(l.b)("h2",{id:"client-streaming"},"Client Streaming"),Object(l.b)("p",null,"The updated Protobuffer:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-proto"}),"// ... rest omitted\n\n// Streaming Client\nmessage LongGreetRequest { Hello hello = 1; }\n\nmessage LongGreetResponse { string result = 1; }\n\nservice HelloService {\n  // ... rest omitted\n\n  // Streaming Client\n  rpc LongGreet(stream LongGreetRequest) returns (LongGreetResponse) {}\n}\n")),Object(l.b)("p",null,"Updating the API:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'// only take a stream this time\nfunc (*server) LongHello(stream hellopb.HelloService_LongHelloServer) error {\n    fmt.Printf("LongHello func invoked with streaming req")\n    result := "Hello "\n\n    for {\n        req, err := stream.Recv()\n        if err == io.EOF {\n            // we finished\n            return stream.SendAndClose(&hellopb.LongHelloResponse{\n                Result: result,\n            })\n        }\n\n        if err != nil {\n            log.Fatalf("Error while reading client stream: %v", err)\n        }\n\n        firstName := req.GetHello().GetFirstName()\n        result += "Hello " + firstName + "! "\n    }\n}\n')),Object(l.b)("p",null,"As for the client:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'func doClientStreaming(c hellopb.HelloServiceClient) {\n    stream, err := c.LongHello(context.Background())\n\n    requests := []*hellopb.LongHelloRequest{\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Dennis",\n            }\n        },\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Stacy",\n            }\n        },\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Tracy",\n            }\n        },\n        &hellopb.LongHelloRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Macy",\n            }\n        }\n    }\n\n    if err != nil {\n        log.Fatalf("Error calling hello %v", err)\n    }\n\n    // iterate over slice and send message individually\n    for _, req := range requests {\n        stream.Send(req)\n    }\n\n    stream.Send(*hellopb.HelloManyTimesRequest)\n}\n')),Object(l.b)("h2",{id:"bidi-streaming"},"BiDi Streaming"),Object(l.b)("p",null,"BiDi is new thanks to HTTP/2. It can be used for things such as chat, etc."),Object(l.b)("p",null,"We can also use it for a long-running client where we want to stream back and forward."),Object(l.b)("p",null,"For the Protocol Buffer:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-proto"}),"// BiDi\nmessage HelloEveryoneRequest { Hello hello = 1; }\n\nmessage HelloEveryoneResponse { Hello result = 1; }\n\nservice HelloService {\n  // ... rest omitted\n\n  // BiDi\n  rpc HelloEveryone(stream HelloEveryoneRequest)\n      returns (stream HelloEveryoneResponse) {}\n}\n")),Object(l.b)("p",null,"For server:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'func (*server) HelloEveryone(stream hellopb.HelloService_HelloEveryoneServer) error {\n    fmt.Printf("HelloEveryone fn invoked w/ streaming req\\n")\n    result := ""\n    for {\n        req, err := stream.Recv()\n\n        if err == io.EOF {\n            // we finished\n            return stream.Send(&hellopb.HelloEveryoneResponse{\n                Result: result,\n            })\n        }\n\n        if err != nil {\n            log.Fatalf("Error reading client stream: %v", err)\n            return err\n        }\n\n        firstName := req.GetHello().GetFirstName()\n        result += "Hello " + firstName + "! "\n    }\n}\n')),Object(l.b)("p",null,"For client:"),Object(l.b)("pre",null,Object(l.b)("code",o({parentName:"pre"},{className:"language-go"}),'func doBiDiStreaming(c hellopb.HelloServiceClient) {\n    fmt.Println("Starting to do BiDi Streaming RPC")\n\n    // we create a stream by invoking the client\n    stream, err := c.HelloEveryone(context.Background())\n    if err != nil {\n        log.Fatalf("Error while creating stream: %v", err)\n        return\n    }\n\n    requests := []*hellopb.HelloEveryoneRequest{\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Dennis",\n            },\n        },\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Stacy",\n            },\n        },\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Tracy",\n            },\n        },\n        &hellopb.HelloEveryoneRequest{\n            Hello: &hellopb.Hello{\n                FirstName: "Macy",\n            },\n        },\n    }\n\n    waitc := make(chan struct{})\n    // we send a bunch of messages to the client\n    go func() {\n        // func to send a bunch\n        for _, req := range requests {\n            fmt.Printf("Sending message: %v\\n", req)\n            stream.Send(req)\n        }\n        stream.CloseSend()\n    }()\n\n    // we receive a bunch\n    go func() {\n        for {\n            res, err := stream.Recv()\n            if err == io.EOF {\n                break\n            }\n\n            if err != nil {\n                log.Fatalf("Error while receiving: %v", err)\n            }\n\n            fmt.Printf("Received: %v", res.GetResult())\n        }\n\n        close(waitc)\n    }()\n\n    // block until everything is done\n    <-waitc\n}\n')))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/gRPC/gRPC-with-Go.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-g-rpc-g-rpc-with-go-md-adc6416647370f59048b.js.map