(window.webpackJsonp=window.webpackJsonp||[]).push([[682],{zzOo:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return s})),t.d(n,"default",(function(){return c}));t("1c7q"),t("abGl"),t("gZHo"),t("Fdmb"),t("Ir+3"),t("2mQt"),t("mXGw");var r=t("/FXl"),a=t("TjRS");t("aD51");function o(){return(o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}var s={};void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"manual/TypeScript/Production-TypeScript-Course.md"}});var l={_frontmatter:s},i=a.a;function c(e){var n=e.components,t=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,["components"]);return Object(r.b)(i,o({},l,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"production-grade-typescript-course"},"Production-Grade TypeScript Course"),Object(r.b)("p",null,"This course goes over some of the features from early on as opposed to the entire course."),Object(r.b)("h2",{id:"resources"},"Resources"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("a",o({parentName:"li"},{href:"https://frontendmasters.com/courses/production-typescript/"}),"Production-Grade TypeScript Course"))),Object(r.b)("h2",{id:"optional-chaining--nullish-coalescing"},"Optional Chaining & Nullish Coalescing"),Object(r.b)("p",null,"Optional chaining which is used for early termination from object access. Note that this adds complexity to managin the code."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"const value = obj.levelOneKey?.value // levelOneKey may not be defined\n")),Object(r.b)("p",null,"Nullish Coalescing:"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"class Foo {\n  name;\n\n  constructor(rawName?: string) {\n    this.name = rawName ?? '(no name)'\n  }\n\n  log() {\n    console.log(this.name)\n  }\n}\n")),Object(r.b)("h2",{id:"true-privacy"},"True Privacy"),Object(r.b)("p",null,"If you had ",Object(r.b)("inlineCode",{parentName:"p"},"private name: string")," in a class and someone runs a debugger, previously the variable would ",Object(r.b)("strong",{parentName:"p"},"still be visible"),"."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"class Foo {\n  #name;\n\n  constructor(rawName?: string) {\n    this.#name = rawName ?? '(no name)'\n  }\n\n  log() {\n    console.log(this.#name)\n  }\n}\n")),Object(r.b)("p",null,"At runtime, it won't be there anymore, whereas with ",Object(r.b)("inlineCode",{parentName:"p"},"private")," it would be!"),Object(r.b)("h2",{id:"tuple-types--recursive-type-aliases"},"Tuple Types & Recursive Type Aliases"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"type Foo<T extends any[]> = [boolean, ...T, boolean];\n")),Object(r.b)("p",null,"Before TS 4, you could only put ",Object(r.b)("inlineCode",{parentName:"p"},"...T")," at the end, however now you do not."),Object(r.b)("h3",{id:"labelled-tuple-types"},"Labelled tuple types"),Object(r.b)("p",null,"There are also ",Object(r.b)("strong",{parentName:"p"},"labelled tuple types"),":"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"type Address = [number, string, number, string];\n\n// take everything from address in order\nfunction printAddress(...address: Address) {\n  // omitted\n}\n\n// we get a terrible typing experience that doesn't explain much\nprintAddress()\n\n// We can fix this with labelled tuple types!\ntype Address = [streetNumber: number, city: string, state: string, postal: number]\n\n// take everything from address in order\nfunction printAddress(...address: Address) {\n  // omitted\n}\n\n// Happier experience that gives more information for the tuple!\nprintAddress()\n")),Object(r.b)("h3",{id:"type-aliases-and-interfaces"},"Type aliases and interfaces"),Object(r.b)("p",null,"A good example of this is now it can be used for JSON."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"// old way from TS v3\ntype JSONValue = string | number | boolean | null | JSONArray | JSONObject;\ninterface JSONArray extends Array<JSONValues> {}\n\n// new way from TS v4\ntype JSONValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JSONValue[]\n  | {\n      [k: string]: JSONValue;\n    };\n")),Object(r.b)("h3",{id:"template-type-literals"},"Template type literals"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"type Corner = `${'top'|'bottom'}-${'left'|'right'}`\n")),Object(r.b)("h2",{id:"ts-errors"},"TS Errors"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"@ts-expect-error")," helps suppress an error. That being said, if there IS no error, it will throw an error!"),Object(r.b)("h2",{id:"error-handling-with-unknown"},"Error Handling with Unknown"),Object(r.b)("p",null,"You SHOULD use ",Object(r.b)("inlineCode",{parentName:"p"},"unknown")," for throwing errors now."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"function somethingRisky() {}\n\ntry {\n  somethingRisky();\n  // in case it removes itself, this should be `err: unknown`\n} catch (err) {\n  // DON'T forces us to handle the error type\n  console.log(err.stack);\n  // DO\n  if (err instanceof Error) {\n    console.log(err.stack);\n  } else {\n    console.log(err);\n  }\n}\n")),Object(r.b)("p",null,"We can also add a function ",Object(r.b)("strong",{parentName:"p"},"which should only be used for testing"),"."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"// before TS 3.7\nfunction isError(err: any): err is Error {\n  return err instanceof Error\n}\n\n// after - described as something that should be more in a test suite\nfunction assertIsError(err:any): asserts err is Error {\n  if (!(err instanceof Error)) throw new Error(`Not an error: ${err}`)\n}\n\nfunction somethingRisky() {}\n\ntry {\n  somethingRisky();\n  // in case it removes itself, this should be `err: unknown`\n} catch (err) {\n  assertIsError(err)\n  console.log(err.stack);\n}\n")),Object(r.b)("h2",{id:"declaration-files--type-only-imports"},"Declaration Files & Type-only imports"),Object(r.b)("p",null,"You can now generate type files for JS."),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-json"}),'{\n  "compilerOptions": {\n    "allowJs": true,\n    "checkJs": true\n  }\n}\n')),Object(r.b)("h3",{id:"type-only-import"},"type-only import"),Object(r.b)("pre",null,Object(r.b)("code",o({parentName:"pre"},{className:"language-ts"}),"import type { useAsyncDataEffect } from 'path/to/module'\n\n// now just uses their type `useAsyncDataEffect`\n")))}c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"manual/TypeScript/Production-TypeScript-Course.md"}}),c.isMDXComponent=!0}}]);
//# sourceMappingURL=component---manual-type-script-production-type-script-course-md-07a43b9de991e31a0be6.js.map